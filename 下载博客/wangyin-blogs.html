<h1>数学和编程<h1>
<h1>谈程序的正确性<h1>
<h1>评《侏罗纪世界》<h1>
<h1>DRY原则的误区<h1>
<h1>所谓软件工程<h1>
<h1>编程的宗派<h1>
<h1>智商的圈套<h1>
<h1>我为什么不再公开开发Yin语言<h1>
<h1>设计的重要性<h1>
<h1>我为什么在乎这一个A+<h1>
<h1>不要做聪明人<h1>
<h1>怎样尊重一个程序员<h1>
<h1>所谓“人为错误”<h1>
<h1>创造者的思维方式<h1>
<h1>人的价值<h1>
<h1>牛校综合征<h1>
<h1>我和 Google 的故事（2015 修订版）<h1>
<h1>在三藩的两年<h1>
<h1>恶评《星际穿越》<h1>
<h1>RSS与三不主义<h1>
<h1>谈创新<h1>
<h1>谦虚不是一种美德<h1>
<h1>怎样成为一个天才<h1>
<h1>休息，休息一会儿<h1>
<h1>SQL，NoSQL 以及数据库的实质<h1>
<h1>对 Go 语言的综合评价<h1>
<h1>黑客文化的精髓<h1>
<h1>电视编剧的问题<h1>
<h1>天下第一萌程序<h1>
<h1>学术腐败是历史的必然<h1>
<h1>一个对 Dijkstra 的采访视频<h1>
<h1>程序语言与它们的工具<h1>
<h1>RubySonar：一个 Ruby 静态分析器<h1>
<h1>程序语言与……<h1>
<h1>我和权威的故事<h1>
<h1>PySonar2 开源了<h1>
<h1>丘奇和图灵<h1>
<h1>Pydiff Python结构化程序比较工具<h1>
<h1>原因与证明<h1>
<h1>Ydiff 结构化的程序比较<h1>
<h1>程序语言不是工具<h1>
<h1>编辑器与IDE<h1>
<h1>程序语言的常见设计错误(2) - 试图容纳世界<h1>
<h1>关于语言的思考<h1>
<h1>Yoda 表示法错在哪里<h1>
<h1>几个超炫的专业词汇<h1>
<h1>一种新的操作系统设计<h1>
<h1>Markdown 的一些问题<h1>
<h1>谈程序的“通用性”<h1>
<h1>什么是启发<h1>
<h1>Scheme 编程环境的设置<h1>
<h1>我为什么离开 Cornell<h1>
<h1>谈“测试驱动的开发”<h1>
<h1>爱因斯坦谈教育<h1>
<h1>谈谈 Currying<h1>
<h1>谈惰性求值<h1>
<h1>对函数式语言的误解<h1>
<h1>什么是“脚本语言”<h1>
<h1>Chez Scheme 的传说<h1>
<h1>Lisp 已死，Lisp 万岁！<h1>
<h1>论对东西的崇拜<h1>
<h1>“解决问题”与“消灭问题”<h1>
<h1>程序语言的常见设计错误(1) - 片面追求短小<h1>
<h1>谈语法<h1>
<h1>Oberon 操作系统：被忽略的珍宝<h1>
<h1>谈 Linux，Windows 和 Mac<h1>
<h1>解密“设计模式”<h1>
<h1>Braid - 一个发人深思的游戏<h1>
<h1>TeXmacs：一个真正“所见即所得”的排版系统<h1>
<h1>怎样写一个解释器<h1>
<h1>什么是语义学<h1>
<h1>GTF - Great Teacher Friedman<h1>
<h1>什么是“对用户友好”<h1>
<body>

    <h2>谈程序的正确性</h2>

    <p>不管在学术圈还是在工业界，总有很多人过度的关心所谓“程序的正确性”，有些甚至到了战战兢兢，舍本逐末的地步。下面举几个例子：</p>

<ul>
<li><p>很多人把测试（test）看得过于重要。代码八字还没一撇呢，就吵着要怎么怎么严格的测试，防止“将来”有人把代码改错了。这些人到后来往往被测试捆住了手脚，寸步难行。不但代码bug百出，连测试里面也很多bug。</p></li>
<li><p>有些人对于“使用什么语言”这个问题过度的在乎，仿佛只有用最新最酷，功能最多的语言，他们才能完成一些很基本的任务。这种人一次又一次的视一些新语言为“灵丹妙药”，然后一次又一次的幻灭，最后他们什么有用的代码也没写出来。</p></li>
<li><p>有些人过度的重视所谓“类型安全”（type safety），经常抱怨手头的语言缺少一些炫酷的类型系统功能，甚至因此说没法写代码了！他们没有看到，即使缺少一些由编译器静态保障的类型安全，代码其实一点问题都没有，而且也许更加简单。</p></li>
<li><p>有些人走上极端，认为所有的代码都必须使用所谓“形式化方法”（formal methods），用机器定理证明的方式来确保它100%的没有错误。这种人对于证明玩具大小的代码乐此不疲，结果一辈子也没写出过能解决实际问题的代码。</p></li>
</ul>


<p>100%可靠的代码，这是多么完美的理想！可是到最后你发现，天天念叨着要“正确性”，“可靠性”的人，几乎总是眼高手低，说的比做的多。自己没写出什么解决实际问题的代码，倒是很喜欢对别人的“代码质量”评头论足。这些人自己的代码往往复杂不堪，喜欢使用各种看似高深的奇技淫巧，用以保证所谓“正确”。他们的代码被很多所谓“测试工具”和“类型系统”捆住手脚，却仍然bug百出。到后来你逐渐发现，对“正确性”的战战兢兢，其实是这些人不解决手头问题的借口。</p>

<h3>衡量程序最重要的标准</h3>

<p>这些人其实不明白一个重要的道理：你得先写出程序，才能开始谈它的正确性。看一个程序好不好，最重要的标准，是看它能否有效地解决问题，而不是它是否正确。如果你的程序没有解决问题，或者解决了错误的问题，或者虽然解决问题但却非常难用，那么这程序再怎么正确，再怎么可靠，都不是好的程序。</p>

<p>正确不等于简单，不等于优雅，不等于高效。一个不简单，不优雅，效率低的程序，就算你费尽周折证明了它的正确，它仍然不会很好的工作。这就像你得先有了房子，才能开始要求房子是安全的。想想吧，如果一个没有房子的流浪汉，路过一座没有人住的房子，他会因为这房子“不是100%安全”，而继续在野外风餐露宿吗？写出代码就像有了房子，而代码的正确性，就像房子的安全性。写出可以解决问题的程序，永远是第一位的。而这个程序的正确性，不管它如何的重要，永远是第二位的。对程序的正确性的强调，永远不应该高于写出程序本身。</p>

<p>每当谈起这个问题，我就喜欢打一个比方：如果“黎曼猜想”被王垠证明出来了，它会改名叫“王垠定理”吗？当然不会。它会被叫做“黎曼定理”！这是因为，无论一个人多么聪明多么厉害，就算他能够证明出黎曼猜想，但这个猜想并不是他最先想出来的。如果黎曼没有提出这个猜想，你根本不会想到它，又何谈证明呢？所以我喜欢说，一流的数学家提出猜想，二流的数学家证明别人的猜想。同样的道理，写出解决问题的代码的人，比起那些去证明（测试）他的代码正确性的人，永远是更重要的。因为如果他没写出这段代码，你连要证明（测试）什么都不知道！</p>

<h3>如何提高程序的正确性</h3>

<p>话说回来，虽然程序的正确性相对于解决问题，处于相对次要的地位，然而它确实是不可忽视的。但这并不等于天天鼓吹要“测试”，要“形式化证明”，就可以提高程序的正确性。</p>

<p>如果你深入研究过程序的逻辑推导就会知道，测试和形式化证明的能力都是非常有限的。测试只能测试到最常用的情况，而无法覆盖所有的情况。别被所谓“测试覆盖”（test coverage）给欺骗了。一行代码被测试覆盖而没有出错，并不等于在那里不会出错。一行代码是否出错，取决于在它运行之前所经过的所有条件。这些条件的数量是组合爆炸关系，基本上没有测试能够覆盖所有这些前提条件。</p>

<p>形式化方法对于非常简单直接的程序是有效的，然而一旦程序稍微大点，形式化方法就寸步难行。你也许没有想到，你可以用非常少的代码，写出<a href="https://en.wikipedia.org/wiki/Collatz_conjecture">Collatz Conjecture</a>这样至今没人证明出来的数学猜想。实际使用中的代码，比这种数学猜想要复杂不知道多少倍。你要用形式化方法去证明所有的代码，基本上等于你永远也没法完成项目。</p>

<p>那么提高程序正确性最有效的方法是什么呢？在我看来，最有效的方法莫过于对代码反复琢磨推敲，让它变得简单，直观，直到你一眼就可以看得出它不可能有问题。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>所谓软件工程</h2>

    <p>很多编程的人包括我，头衔叫做“软件工程师”（software engineer），然而我却不喜欢这个名字。我喜欢把自己叫做“程序员”（programmer）或者“计算机科学家”（computer scientist）。这是为什么呢？这需要从“软件工程”（software engineering）在现实中的涵义谈起。</p>

<p>有人把软件工程这个领域的本质总结为：“How to program if you cannot？”（如果你不会编程，那么你如何编程？）我觉得这句话说得很好，因为我发现软件工程这整个领域，基本就是吹牛扯淡卖“减肥药”的。软件行业的大部分莫名其妙的愚昧行为，很多是由所谓“软件工程专家”发明的。总有人提出一套套的所谓“方法论”或者“原则”，比如Extreme Programming，Design Patterns，Agile，Pair Programming，Test Driven Development（TDD），DRY principle，…… 他们把这些所谓方法论兜售给各个软件公司，鼓吹它们的各种好处，说使用这些方法，就可以用一些平庸的“软件工程师”，制造出高质量低成本的软件。这就跟减肥药的广告一样：不用运动，不用节食，一个星期瘦20斤。你开头还不以为然，觉得这些肤浅的说法能造成什么影响。结果久而久之，这些所谓“方法论”和“原则”成为了整个行业的教条，造成了文化大革命一样的风气。违反这些教条的人，必然被当成菜鸟一样的鄙视，当成小学生一样的教育，当成“反革命”一样的批斗。就算你技术比这些教条的提出者还高明不知道多少倍也一样。</p>

<p>打破这些软件工程专家们制造的幻觉的一个办法，就是实地去看看这些所谓专家们自己用这些方法论做出了什么好东西。你会惊奇的发现，这些提出各种玄乎其玄的新名词的所谓“专家”，几乎都是从不知道什么旮旯里冒出来的民科，没有一个做出过什么有技术含量的东西，他们根本没有资格对别人编程的方式做出指导。这些人做出来少数有点用的东西（比如JUnit），其实非常容易，以至于每个初学编程的人都应该做得出来。可世界上就是有这样划算的职业，你虽然写不出好的代码，你对计算原理的理解非常肤浅，却可以通过一些手段，得到评价别人的“代码质量”的权力，占据软件公司的管理层位置。久而久之，别人还以为你是什么泰斗。你仔细看过提出Java Design Pattern的四个人（GoF），到底做出过什么厉害的东西吗？没有。提出“DRY Principle”的作者，做出过什么好东西吗？没有。再看看Agile，Pair Programming，TDD……的提出者？全都是一群饭桶。他们其实根本就不懂很多编程的东西，写出文章和书来也是极其肤浅，一知半解。</p>

<p>所谓“软件工程”，并不像土木工程，机械工程，电机工程，是建立在实际的，科学的基础上的。跟这些“硬工程”不一样，软件弄得不好不会出人命，也不会跟做芯片的公司那样，出一个bug立即导致上亿的损失，身败名裂。所以研究软件工程，似乎特别容易钻空子，失败了之后容易找借口和替罪羊。如果你说我的方法不好，你有什么证据吗？口说无凭，我浪费了你多少时间呢？你的具体执行是不是完全照我说的来的呢？你肯定有什么细节没按我说的做，所以才会失败。总之，如果你用了我的办法不管用，那是你自己的问题！</p>

<p>想起这些借口我就想起一个笑话：两夫妻睡觉发现床上有跳蚤，身上被咬了好多大包。去买了号称“杀伤率100%”的跳蚤药，撒了好多在床上。第二天早上起来，发现又被咬了好多新的大包。妻子责怪丈夫，说他没看说明书就乱撒。结果丈夫打开说明书一看，内容如下：</p>

<blockquote><p>本跳蚤药使用方法：</p>

<ol>
<li>抓住跳蚤</li>
<li>掰开跳蚤的嘴</li>
<li>把药塞进跳蚤嘴里</li>
<li>合上跳蚤的嘴</li>
</ol>
</blockquote>

<p>我发现很多软件工程的所谓方法论失败之后的借口，跟这跳蚤药的说明书很像 :)</p>

<p>人都想省钱，雇用高质量的程序员不容易呀，所以很多公司还是上钩了。他们请这些“软件工程专家”来到公司，推行各种各样的软件方法论，可是发现最后都失败了。这是为什么呢？因为再高明的方法论，也无法代替真正的，精华的计算机科学教育。直到今天还有很多公司推行所谓的Agile，煞有介事的搞一些stand-up meeting, scrum之类的形式主义东西，以为这些过家家似的做法就能提高开发质量和效率。很多开发人员也很把一些软件工程的工具当回事，喜欢折腾Git，Maven等工具一些偏僻的“新功能”。他们很在乎所谓的版本控制，测试等东西，以为熟练的掌握这些就能开发出高质量，可靠的代码。可是你最后发现，无论你如何高效的使用这些工具，它们都只能起到辅助的，次要的作用。编程工具永远不是程序本身，对编程工具的熟练掌握，永远也无法代替真正的对程序和计算的理解。过分强调这些工具的使用，是本末倒置的，让工程走上失败道路的作法。</p>

<p>编程真的是一门艺术，它完全符合艺术的各种特征，编程界也充满了艺术界的独有特征。有些初学艺术的人（比如10年前的我），总是挑剔手上的工具，非要用最新最炫的工具，用它们最偏僻最难用的“特性”，才觉得自己能够做出优秀的作品。很多人照不出好的照片，就怪相机不好。买了几万块钱的笨重高档相机，照出来的照片还不如别人用手机照的。这些人不明白，好的摄影师和不好的摄影师，区别在于眼睛，而不是相机。一个真正的艺术家，可以用任何在手上的工具创造出色的作品。有些甚至可以用一些废品垃圾，拙劣的工具，做出杰出的，别具风味的艺术品。因为艺术存在于人的心里，而不在他们使用的工具里面。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>智商的圈套</h2>

    <p>上次买了个<a href="http://www.jianshu.com/p/b501a1675f4d">任天堂3DS</a>游戏机，觉得里面的游戏很无聊，所以第二天就把游戏机连同游戏一起，转手倒卖给了别人。从那天之后，我开始琢磨一个问题——到底是什么让我觉得一个游戏好玩或者不好玩。我似乎对事物有一种很特别的品味，很多别人说“好玩”，“有趣”的游戏或者电影，我一看就觉得很无趣，或者很自虐。我一生中玩过最好玩的游戏，其实没有几个，可能掰着手指头都数得出来：<a href="http://braid-game.com">Braid</a>，<a href="http://en.wikipedia.org/wiki/Limbo_%28video_game%29">Limbo</a>，<a href="http://en.wikipedia.org/wiki/Klonoa:_Door_to_Phantomile">Klonoa</a>（風のクロノア door to phantomile），《<a href="https://itunes.apple.com/cn/app/ji-nian-bei-gu/id728293409">纪念碑谷</a>》，<a href="http://en.wikipedia.org/wiki/Metal_Gear_Solid">Metal Gear Solid</a>，……</p>

<p><img src="http://www.yinwang.org/images/Klonoa.jpg"></p>

<p>如果你觉得我智商太高，所以才觉得很多游戏没有挑战性，不好玩，那么你其实并不了解我。我并不是一个“智商达人”，我不追求挑战性。我觉得很多游戏缺乏的不是挑战性和“难度”，而是设计的巧妙。很多游戏我根本没法玩过关，却只是觉得呆板，繁琐，老套，公式化。我并不会因为游戏玩不过关，作业做不出来，或者书看不懂而沮丧。恰恰相反，我认为我的智力根本就不应该是用来干这些事情的。如果有事情让我觉得沮丧，我一般都认为是这个事情有问题，而不是我有问题。如果说我也有错的话，那么我的错误就在于选择了参与这项活动，我根本不应该做这件事情。这就是为什么我大部分时候都比一般人开心。</p>

<p>我觉得很多人有一种奇怪的倾向，他们喜欢挑战或者彰显自己的智商。每当我向人推荐类似Braid的游戏，他们就会认为我喜欢“解谜题”，于是他们给我推荐类似<a href="http://www.zelda.com">Zelda</a>或者<a href="http://www.antichamber-game.com">Antichamber</a>之类的游戏，告诉我它们很考智力。可是这样的游戏，我一般玩不到几分钟就开始觉得无聊。这说明我并不是喜欢“解谜题”，而是因为另外一些特征而喜欢某些游戏。喜欢玩Zelda，Antichamber，或者《生化危机》一类游戏的人，往往有一种自虐倾向。这种人似乎很在乎自己的智商，所以游戏玩了不久之后，就会被“套牢”。他们会认为能够把某个游戏打通关，是对自己智商的认可。如果你跟他说这游戏太难太麻烦，他就会开始鄙视你的智力，吹嘘自己只花了多么短的时间就玩通关了。</p>

<p>然而如果你退后一步，就会发现这些游戏，其实都存在某种“<a href="http://www.jianshu.com/p/b501a1675f4d">设计公式</a>”。一旦掌握了这些公式，你就可以轻而易举地制造出这样的游戏。然后你就会发现，热衷于这些游戏的人，其实并不聪明，因为他们被游戏的设计者玩弄于鼓掌之中，而没能发现其中的设计公式。这些人为了得到别人的认可，检验或者训练所谓的“智力”，甚至为了“合群”，选择了这类只能叫做“自虐型”的游戏。</p>

<p>这种游戏玩到后来，你就会发现这不是在娱乐，而是在完成任务，不是你在玩游戏，而是游戏在玩你。你盼望它早点结束，但却无法立即罢手，因为你对自己说：“如果现在半途而废，我就是一个懦夫，一个笨蛋，就不再是一个天才……” 你在虚拟的空间中来回的游走，摸索和寻找那些能打开机关的“钥匙”，而它们被游戏的设计者故意放在一些让人恼火的地方。你感觉到的不是快乐，而是繁琐，沮丧和空虚。</p>

<p>我发现容易落入这种圈套的人，他们在日常生活和工作中也容易出现类似的倾向。总的说来，这种人正如卓别林的《大独裁者》最后的<a href="http://tinyurl.com/bbqfs6s">演讲</a>所描述的，“想得太多，感觉太少”（think too much, feel too little）。这种人如果沿着这条道路发展下去，就会变成像机器一样思考的人。正是这种人，给世界带来了灾难。希特勒就是这样一种人的典型代表，他太在乎自己是否优秀和聪明，却感觉不到人间的爱和痛苦，所以他对自己认为是劣等民族的人进行残酷的屠杀。</p>

<p>所以，我其实并不是因为智力上的挑战性而喜欢Braid，Limbo，Klonoa等游戏。我喜欢它们，是因为它们充满了创意和想象力，却又不让人觉得繁琐和累赘。在这样的游戏里，你能做一些你从前根本没想到过的事情，它们的设计可以用“妙不可言”来形容。这种游戏的逻辑很连贯流畅，你不需要到处瞎撞，来回跑动，而是一气呵成，行云流水，却又不乏波澜起伏和机智巧妙之处。这就像自己在演出一场出神入化的电影。你感觉到的不是沮丧，迷茫，不是对自己智力的考验和评价，而是真正的愉悦和解脱。</p>

<p>当我推荐Klonoa给一个朋友的时候，我说：“玩这个游戏就感觉是在梦里……” 结果他对我说：“你知道另外一个叫什么什么的游戏里面，也有个四维空间吗？……” 其实我根本不是在跟他讨论“梦是什么”这种学术问题，而是在说“梦幻的感觉”。这位朋友就属于我前面提到的，“想得太多”的类型。我说像是在梦里，说的是一种感觉，只有心才看得见；而他所理解的“梦”，是一种很理论的东西，就像数学里的多维空间，需要用脑才分析得出来。由于过度理性，他总是忙于分析一些“深层次”的理论，而看不见我能轻松感觉到的乐趣。我对他的建议是：少想一点，少分析一点，多用心感觉。只有用心去体会，你才会理解，Klonoa这样的游戏的价值，其实不在于智力和难度，而在于它让你感觉到的梦幻，创意，自由，想象力，和艺术。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>设计的重要性</h2>

    <p>我曾经在一篇<a href="http://www.yinwang.org/blog-cn/2014/07/17/rest">文章</a>里谈过关于设计的问题，然而那篇文章由于标题不够醒目，可能很多人没有注意看。我觉得现在有必要把里面的内容专门提出来讲一下，因为设计在我的心目中具有至关重要的地位，却被很多计算机科学家和程序员所轻视。</p>

<p>我觉得自己不但是一个计算机科学家和程序员，在很大程度上我还是一个设计师。我不但是一个程序语言的设计师，而且是其它很多东西的设计师。我设计的东西不但常常比别人的简洁好用，而且我经常直接看出其他人的设计里面的问题。我写的代码不仅自己容易看懂，而且别人也容易理解。我有时候受命修补前人的BUG，结果没法看懂他们的代码。在这种情况下，我的解决方案是推翻重写。经我重写之后的代码，不仅没有BUG，而且简洁很多。</p>

<p>很多人自己的设计有问题，太复杂不易用，到头来却把责任推在用户身上，使用类似“皇帝的新装”的技巧，让用户有口难言。之前一篇<a href="http://www.yinwang.org/blog-cn/2015/02/24/human-errors">文章</a>提到的严重交通事故，就是一个设计问题，却被很多人归结为“人为错误”。这种出人命的事情都这么难引起人们对设计的关注，就更不要说软件行业那些无关性命的恼人之处了。有些人写的代码过度复杂，BUG众多，却仿佛觉得自己可以评估其他人的智商，打心眼里觉得自己是专家，看不懂他代码的人都是笨蛋。</p>

<p>很多程序员有意把“用户”和自己区别开来，好像程序员应该高人一等，不能以用户的标准。所以他们觉得程序员就是应该会用各种难用的工具，难用的操作系统，程序语言，编辑器，…… 他们觉得只要你追求这些东西的“易用性”或者“直观性”，就说明你智商有问题。只要你说某个东西太复杂，另一个东西好用些，他们就会跟你说：“专家才用这个，你那个是菜鸟用的。” 这些人不明白，程序员其实也是用户，而且他们是自己的代码的用户，每一次调用自己写的函数，自己都是自己的用户。可是这种鄙视用户的风气之胜行，带来了整个行业不但设计过度复杂，而且以复杂为豪的局面。</p>

<p>经常有人自豪的声称自己的项目有多少万行代码，仿佛代码的行数是衡量一个软件质量的标准，行数越多质量越好，然而事实却恰恰相反。你可能需要经历过Indiana式的教育才能真正的理解这一点。如果你拿一些引以为豪的代码给Dan Friedman看，他可能瞟一眼就说：“太长了。当年这个东西我两行代码就写出来了……” 你摸着脑袋怀疑他是不是在吹牛，怎么可能！然后过了几个星期，你把代码重写了好多遍之后，真的发现只需要两行！这时候他才会微笑着点点头，一副龟仙人的味道。就是这样的教育，让我能够在短短几个星期之内，完成Google一个小组的人花几年也没法完成的项目。看过我写的代码，你也许会理解这句<a href="http://zh.wikipedia.org/wiki/%E5%AE%89%E6%89%98%E4%B8%87%C2%B7%E5%BE%B7%E5%9C%A3%E5%9F%83%E5%85%8B%E7%B5%AE%E4%BD%A9%E9%87%8C">《小王子》作者</a>的<a href="http://www.brainyquote.com/quotes/quotes/a/antoinedes121910.html">名言</a>：“一个设计师知道他达到了完美，并不是当他不能再加进任何东西，而是当没有任何东西可以被去掉。”</p>

<p>如果你跟我一样关心设计，却发现身边的人喜欢显示自己能搞懂复杂的东西，跟你说容易的东西都是菜鸟用的，那么你需要一个朋友。书籍是人类最好的朋友，因为它的作者可以跨越时间和空间的限制，给你最需要的支持和鼓励。这就是当我阅读这本1988年出版的《<a href="http://www.amazon.com/Design-Everyday-Things-Revised-Expanded-ebook/dp/B00E257T6C">The Design of Everyday Things</a>》（简称DOET）时的感觉。我觉得，终于有人懂我了！有趣的是，它的作者 Don Norman 曾经是 Apple Fellow，也是《<a href="http://web.mit.edu/~simsong/www/ugh.pdf">The Unix-Haters Handbook</a>》一书序言的作者。</p>

<p><img src="http://www.yinwang.org/images/doet.jpg"></p>

<p>DOET 不但包含并且支持了我的博文《<a href="http://www.yinwang.org/blog-cn/2014/04/11/hacker-culture">黑客文化的精髓</a>》以及《<a href="http://www.yinwang.org/blog-cn/2014/01/25/pl-and">程序语言与……</a>》里的基本观点，而且提出了比《<a href="http://www.yinwang.org/blog-cn/2012/05/18/user-friendliness">什么是“对用户友好”</a>》更精辟可行的解决方案。</p>

<p>我觉得这应该是每个程序员必读的书籍。为什么每个程序员必读呢？因为虽然这本书是设计类专业的必读书籍，而计算机及其编程语言和工具，其实才是作者指出的缺乏设计思想的“重灾区”。看了它，你会发现很多所谓的“人为错误”，其实是工具的设计不合理造成的。一个设计良好的工具，应该只需要很少量的文档甚至不需要文档。这本书将提供给你改进一切事物的原则和灵感。你会恢复你的人性。</p>

<p>值得一提的是，虽然 Don Norman 曾经是 Apple Fellow，但我觉得 Apple 产品设计的人性化程度与 Norman 大叔的思维高度还是有一定的差距的。因为我看了这书之后，立马发现了iPhone的一些设计问题。</p>

<p>如果你跟我一样不想用眼睛看书，可以到 Audible 买本<a href="http://www.audible.com/pd/Science-Technology/The-Design-of-Everyday-Things-Audiobook/B005I5MDGQ">有声书</a>来听。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>所谓“人为错误”</h2>

    <p>昨天是一个让人悲哀的日子。旧金山湾区主要的上下班交通工具Caltrain，在24小时之内发生三次事故，撞死三人。其中一次事故发生在Menlo Park，一辆汽车被困在铁轨上，因为被前后的车辆堵塞而无法逃避，终于被飞驰而来的列车撞成一堆废铁。开车人被消防队员从残骸里切割出来，送往医院后不久死亡。(<a href="http://www.ktvu.com/story/28193228/driver-killed-in-menlo-park-caltrain-accident-was-trapped-on-tracks">新闻视频</a>）</p>

<p><a href="http://www.ktvu.com/story/28193228/driver-killed-in-menlo-park-caltrain-accident-was-trapped-on-tracks">
<img src="http://www.yinwang.org/images/caltrain-accident1.jpg" width="90%"></a></p>

<p><img src="http://www.yinwang.org/images/caltrain-accident2.jpg" width="90%"></p>

<p>我为生命的殒灭而悲哀，然而让我更加悲哀的是，每当这样的事故发生，总有人指责说是“人为错误”。比如，Twitter上有人说这事故是因为死者没有遵守交通规则，才导致自己的汽车被困在铁轨之上，所以她死的活该。</p>

<p><img src="http://www.yinwang.org/images/caltrain-accident-twitter.png" width="90%"></p>

<p>真的是因为她不遵守交通规则吗？真的有人愿意把车停在铁轨上等死吗？也许是这规则没法遵守，或者设计得让人很容易“违反”呢？</p>

<p>首先，规则必须要让人理解，切实可行，才能叫做规则。</p>

<p><img src="http://www.yinwang.org/images/ravenswood-ave-crossing.png" width="90%"></p>

<p>但是请看看铁轨交叉路口上的指令：“不要停在铁轨上（DO NOT STOP ON TRACKS）”，“保持路口畅通（KEEP CLEAR）”。我也不想停在铁轨上啊，可是我刚开到铁轨上，前面的车就停下来了，过不去怎么办？另外什么叫做clear？一定要等到路口里面完全没有车才可以进去吗？如果路口里面虽然有车，然而它们都以每小时30英里的速度行驶？这时我还该停下来吗？如果前面车的速度不到每小时5英里呢？如果前面车辆貌似很快，结果我一进路口它就慢下来了怎么办？</p>

<p>如果“不要停在铁轨上”的指令我想遵守都不可能，如果连clear这个单词都定义不清楚，这还叫什么“交通规则”呢？既然规则都不清楚，又怎么能责怪别人不遵守？我要有多么高的预知未来的能力，才能猜得到前面的车会不会正好在我开到铁轨上的时候停下来，把我堵在铁轨上呢？也许你已经看出来了，这其实不是开车人的错误，它最多算一个“判断失误”。每个人都有可能在那种模棱两可的情况下发生判断失误，因为你没法知道前面的车会怎样运动。记者在现场采访的几个开车人都说：“过那个路口要极度小心，因为你不知道前面的车会怎么样走。”</p>

<p>如果你仔细看看卫星图，就会发现铁轨前方的道路狭窄，而且不远处有一个红绿灯。如果这个红绿灯变红，那么就有可能把直到铁轨处的车辆全都叫停。如果你熟悉湾区的道路，就知道红灯处是82号公路（El Camino Real），上那条路的红灯经常等很久。也就是说，可能有很多车在那里等红灯，一直到铁轨的地方！</p>

<p><img src="http://www.yinwang.org/images/ravenswood-ave.png" width="90%"></p>

<p>如果你再仔细一点，用Google Map的street view去实地看一下那个路口，就会发现，地面上的"KEEP CLEAR"字样，其实是用来给被堵在铁轨上的车预留后路的。然后你就发现，如果后面的车不遵守KEEP CLEAR的指令，那么它们就会断掉铁轨上的车的退路。所以，其实不是铁轨上的车自己等死，而是后面那些不遵守KEEP CLEAR指令的车，把它逼上了绝路。然而就像我之前提到的，想要遵守KEEP CLEAR又是很模棱两可的事情，后面的车有可能以为你过得去，所以才跟上的。所以你死了，不能怪火车，不能怪你自己，不能怪前面的车，还不能怪后面的车！怪谁呢？只能怪路口的“设计”！</p>

<p>这种路口交通规则还有一个致命的特征，那就是后果的严重性不明显，人不会敏锐的感觉到犯了错误的结果是车毁人亡。一般人都不闯红灯，因为很显然，如果你红灯不停就会被另一个方向的车撞上。可是违反这铁道路口的规则，后果不是立显的，有可能什么事也没有，也有可能呆在那里几分钟之后才出事，到时候想逃都逃不了。这就像把活青蛙放进冷水里，然后慢火加热一样，它不会立即被烫得跳出来，而会死在里面！等你慢慢的开到铁轨上，才发现前面的车不走了（因为更前面路口亮了红灯），后面的车又抵上来。过一会儿，当当当，栏杆放下来，火车来了…… 你这是在设陷阱诱捕野生动物吗？</p>

<p>如此容易出现的失误（甚至不叫做自己的失误），真的值得一个人用生命来偿还吗？按照这样的逻辑，我就可以把地雷埋在大街上，插上标志牌说：“下面有地雷，不要踩！”如果你踩了，那我就可以怪你没遵守规则，自己找死！</p>

<p>如果你回头看看历史就会发现，Caltrain几乎每个月都会撞上至少一辆汽车，所以这次的事故绝不是偶然，它有更深层的原因。上一个月，我乘坐的一列Caltrain，就因为前面一趟列车撞上了汽车而延误了好几个小时。当时我就在Twitter上看到有人责备开车的人，说他脑子秀逗了，不该把车停在铁轨上。当时我就在Twitter上警告@Caltrain，说你们应该仔细分析一下这个交叉路口的设计，也许是因为设计有问题。没有人回应我。这次出了三条人命，交叉路口的设计问题才终于受到了重视。</p>

<p>出了人命的大事故，也许能唤醒人们一点理智，认识到所谓的“人为错误”，其实在很多时候是设计错误。在这个例子中，交叉路口的设计是不合理的。一旦你因为判断失误把车开进去了，就有可能出现无路可逃，车毁人亡的局面。然而很多生活中的设计失误所引发的“人为错误”都是不致命的，有点像慢性毒药。这种貌似无关痛痒的设计错误，更加容易被忽视，它们就潜伏在我们的身边。</p>

<p>在我所在的软件行业里，就有很多这样的设计错误。在我看来，整个软件行业基本就是建立在一堆堆的设计失误之上。做程序员如此困难和辛苦，大部分原因就是因为软件系统里面积累了大量前人的设计失误，所以我们需要做大量的工作来弥补或者绕过。举个例子，Unix/Linux操作系统就是一个重大的设计失误。Unix系统的命令行，系统API，各种工具程序，编辑器，程序语言（C，C++等），设计其实都很糟糕。很多工具程序似乎故意设计得晦涩难用，让人摸不着头脑，需要大量时间学习，而且容易出错。出错之后难以发现，难以弥补。</p>

<p>然而一般程序员都没有意识到这里面的设计错误，知道了也不敢指出来，他们反而喜欢显示自己死记硬背得住这些稀奇古怪的规则。这就导致了软件行业的“皇帝的新装现象”——没有人敢说工具的设计有毛病，因为如果你说出来，别人就会认为你在抱怨，那你不是经验不足，就是能力不行。这就像你不敢说皇帝没穿衣服，否则别人就会认为你就是白痴或者不称职的人！Unix系统的同盟者和后裔们（Linux，C语言，Go语言），俨然形成了这样一种霸权，他们鄙视觉得它们难用，质疑它们的设计的人。他们嘲笑这些用户为失败者，即使其实有些“用户”水平比Unix的设计者还要高。久而久之，他们封住了人们的嘴，让人误以为难用的东西就是好的。</p>

<p>我体会很深的一个例子就是Git版本控制工具。有人很把这种东西当回事，引以为豪记得住如何用一些稀奇古怪的Git命令（比如git rebase, git submodule之类）。好像自己知道了这些就真的是某种专家一样，每当遇到不会用这些命令的人，都在心底默默地鄙视他们。作为一个比Git的作者还要高明的程序员，我却发现自己永远无法记住那些命令。在我看来，这些命令晦涩难懂，很有可能是因为没设计好造成的。因为如果一个东西设计好了，以我的能力是不可能不理解的。可是Linus Torvalds的名气之大，威望之高，有谁敢说：“我就是不会用你设计的破玩意儿！你把我怎么着？”</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>DRY原则的误区</h2>

    <p>很多编程的人，喜欢鼓吹各种各样的“原则”，比如KISS原则，DRY原则…… 总有人把这些所谓原则奉为教条或者秘方，以为兢兢业业地遵循这些，空喊几个口号，就可以写出好的代码。同时，他们对违反这些原则的人嗤之以鼻——你不知道，不遵循或者藐视这些原则，那么你就是菜鸟。所谓“<a href="http://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY原则</a>”（Don't Repeat Yourself，不要重复你自己）就是这些教条其中之一。盲目的迷信DRY原则，在实际的工程中带来了各种各样的问题，却经常被忽视。</p>

<p>简言之，DRY原则鼓励对代码进行抽象，但是鼓励得过了头。DRY原则说，如果你发现重复的代码，就把它们提取出去做成一个“模板”或者“框架”。对于抽象我非常的在行，实际上程序语言专家做的许多研究，就是如何设计更好的抽象。然而我并不奉行所谓DRY原则，并不是尽一切可能避免“重复”。“避免重复”并不等于“抽象”。有时候适当的重复代码是有好处的，所以我有时候会故意的进行重复。</p>

<h3>抽象与可读性的矛盾</h3>

<p>代码的“抽象”和它的“可读性”（直观性），其实是一对矛盾的关系。适度的抽象和避免重复是有好处的，它甚至可以提高代码的可读性，然而如果你尽“一切可能”从代码里提取模板，甚至把一些微不足道的“共同点”也提出来进行“共享”，它就开始有害了。这是因为，模板并不直接显示在“调用”它们的位置。提取出模板，往往会使得阅读代码时不能一目了然。如果由此带来的直观性损失超过了模板所带来的好处时，你就应该考虑避免抽象了。要知道，代码读的次数要比写的次数多很多。很多人为了一时的“写的快感”，过早的提取出不必要的模板，其实损失了读代码时的直观性。如果自己的代码连自己都不能一目了然，你就不能写出优雅的代码。</p>

<p>举一个实际的例子。奉行DRY原则的人，往往喜欢提取类里面的“共同field”，把它们放进一个父类，然后让原来的类继承这个父类。比如，本来的代码可能是：</p>

<pre><code class="java">class A {
  int a;
  int x;
  int y;
}

class B {
  int a;
  int u;
  int v;
}
</code></pre>

<p>奉行DRY原则的人喜欢把它改成这样：</p>

<pre><code class="java">class C {
  int a;
}

class A extends C {
  int x;
  int y;
}

class B extends C {
  int u;
  int v;
}
</code></pre>

<p>后面这段代码有什么害处呢？它的问题是，当你看到<code>class A</code>和<code>class B</code>的定义时，你不再能一目了然的看到<code>int a</code>这个field。“可见性”，对于程序员能够产生直觉，是非常重要的。这种无关紧要的field，其实大部分时候都没必要提出去，造出一个新的父类。很多时候，不同类里面虽然有同样的<code>int a</code>这样的field，然而它们的含义却是完全不同的。有些人不管三七二十一就来个“DRY”，结果不但没带来好处，反而让程序难以理解。</p>

<h3>抽象的时机问题</h3>

<p>奉行DRY原则的人还有一个问题，就是他们随时都在试图发现“将来可能重用”的代码，而不是等到真的出现重复的时候再去做抽象。很多时候他们提取出一个貌似“经典模板”，结果最后过了几个月发现，这个模板在所有代码里其实只用过一次。这就是因为他们过早的进行了抽象。</p>

<p>抽象的思想，关键在于“发现两个东西是一样的”。然而很多时候，你开头觉得两个东西是一回事，结果最后发现，它们其实只是肤浅的相似，而本质完全不同。同一个<code>int a</code>，其实可以表示很多种风马牛不及的性质。你看到都是<code>int a</code>就提出来做个父类，其实反而让程序的概念变得混乱。还有的时候，有些东西开头貌似同类，后来你增添了新的逻辑之后，发现它们的用途开始特殊化，后来就分道扬镳了。过早的提取模板，反而捆住了你的手脚，使得你为了所谓“一致性”而重复一些没用的东西。这样的一致性，其实还不如针对每种情况分别做特殊处理。</p>

<p>防止过早抽象的方法其实很简单，它的名字叫做“等待”。其实就算你不重用代码，真的不会死人的。时间能够告诉你一切。如果你发现自己仿佛正在重复以前写过代码，请先不要停下来，请坚持把这段重复的代码写完。如果你不把它写出来，你是不可能准确的发现重复的代码的，因为它们很有可能到最后其实是不一样的。</p>

<p>你还应该避免没有实际效果的抽象。如果代码才重复了两次，你就开始提取模板，也许到最后你会发现，这个模板总共也就只用了两次！只重复了两次的代码，大部分时候是不值得为它提取模板的。因为模板本身也是代码，而且抽象思考本身是需要一定代价的。所以最后总的开销，也许还不如就让那两段重复的代码待在里面。</p>

<p>这就是为什么我喜欢一种懒懒的，笨笨的感觉。因为我懒，所以我不会过早的思考代码的重用。我会等到事实证明重用一定会带来好处的时候，才会开始提取模板，进行抽象。经验告诉我，每一次积极地寻找抽象，最后的结果都是制造一些不必要的模板，搞得自己的代码自己都看不懂。很多人过度强调DRY，强调代码的“重用”，随时随地想着抽象，结果被这些抽象搅混了头脑，bug百出，寸步难行。如果你不能写出“可用”（usable）的代码，又何谈“可重用”（reusable）的代码呢？</p>

<h3>谨慎的对待所谓原则</h3>

<p>说了这么多，我是在支持DRY，还是反对DRY呢？其实不管是支持还是反对它，都会表示我在乎它，而其实呢，我完全不在乎这类原则，因为它们非常的肤浅。这就像你告诉我说你有一个重大的发现，那就是“1+1=2”，我该支持你还是反对你呢？我才懒得跟你说话。人们写程序，本来自然而然就会在合适的时候进行抽象，避免重复，怎么过了几十年后，某个菜鸟给我们的做法起了个名字叫DRY，反而他成了“大师”一样的人物，我倒要用“DRY”这个词来描述我一直在干的事情呢？所以我根本不愿意提起“DRY”这个名字。</p>

<p>所以我觉得这个DRY原则根本就不应该存在，它是一个根本没有资格提出“原则”的人提出来的。看看他鼓吹的其它低劣东西（比如Agile，Ruby），你就会发现，他是一个兜售减肥药的“软件工程专家”。世界上有太多这样的肤浅的所谓原则，我不想对它们一一进行评价，这是在浪费我的时间。世界上有比这些喜欢提出“原则”的软件工程专家深邃很多的人，他们懂得真正根本的原理。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>不要做聪明人</h2>

    <p>世界上有三种人：聪明人，傻瓜，傻b。傻瓜和傻b的区别是，傻b是令人讨厌的傻瓜。很多人想做聪明人，比其他人都聪明，结果他们变成了傻b。为什么会这样呢？</p>

<p>其实很多人所谓的“聪明”，要么是能够高效的完成一些机械化的任务，要么是能够高效的绕过一些前人的设计失误。他们的所谓“知识”，建立在一堆历史遗留的糟粕之上，他们以记得住这些脆弱的“知识”为豪。所以，这些人连聪明是什么都不知道，又怎么可能成为聪明人？有些人很傻，只会死记硬背，却自认为很聪明，所以他们让人厌恶，进而升级成为傻b。</p>

<p>如果你想做聪明人，那你往往不可能成为聪明人。想做聪明人的欲望，很容易让人变成傻b。有些人随时都在担心自己不如别人聪明，随时都在比较，害怕别人比他更聪明。纳什（John Nash）因为一辈子都在跟人计较谁更聪明，结果发疯了。他还算好点的，很多“天才”因为跟人计较谁更聪明，最后自杀了。世界上最傻的事情，就是拿自己跟别人作比较。跟人比较的结果，最终都是不快乐，甚至给自己的身心带来伤害。</p>

<p>想做聪明人的欲望，让人变得喜欢争执，喜欢咄咄逼人的想证明自己是对的。它也使人变得固执和盲从，仓促而盲目的相信或者排斥一些事物。有趣的是，这些人选择相信或者排斥的条件，往往在于最后的结果是否能让自己显得聪明。想做聪明人的人，往往只关心自己知道的那点东西，发现别人貌似不懂就穷追猛打，抓住小辫子不放，教育这些不懂的人！却没发现自己有多么无知。因为想证明自己比别人聪明，所以解决问题的时候，总喜欢选择更困难，更复杂，看似更高深的解决方案。结果不但劳神费力，还阻碍了技术的简化和进步。</p>

<p>聪明是可遇而不可求的。聪明可能是一种结果，一种事实，却不可以是一种欲望，一种目标。想要成为聪明人的欲望，多半会让人变成傻b。世界上所有试图成为聪明人的人，终究都会悟出一个道理。他们发现，自己更愿意做一个傻瓜。很多人所谓的“聪明才智”，越来越多的被机器所代替和超越。随着科技的进步，人们耐以生存所需要的死知识，会越来越少。这个世界越来越不需要聪明人，它更需要的是可爱的人。傻瓜往往很可爱。</p>

<p>未来的世界属于傻瓜。所以，我觉得每个人都应该放弃做聪明人的企图，反而应该有做傻瓜的欲望。做一个傻瓜，才能给你真正意义上的实惠和幸福。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>我和 Google 的故事（2015 修订版）</h2>

    <p>2009 和 2010 年，两年的夏天我都在 Google 实习，然而最后毕业的时候我却没有为 Google 工作。虽然我心里很清楚这里面的原因，可总有些人觉得不解，为什么居然有人不想为 Google 工作？如果你是这些人其中之一，那你可能想知道我在 Google 时的切身感受。</p>

<p>直到将近 2015 年新年的今天，我发现这篇文章仍然具有普遍的意义。面对 Google 的员工，我仍然是同样的感觉。他们很多人太拿自己的公司当回事了，自高自大，放弃自己的尊严来舔这个公司的屁股。这些人总觉得好像所有人都希望为 Google 工作，即使进不了 Google，都想去 Google “蹭饭”似的。如果一个人说“我很厉害”，我也许会尊敬他，可是如果他说“我为 Google 工作”，以此来显得厉害，我就会鄙视他。我只尊敬那些尊敬他们自己的人。以自己的公司名声来抬高自己的人，是最被我瞧不起的，因为他们跟仗着人势的狗没什么区别。</p>

<p><img src="http://www.yinwang.org/images/google-engineer.gif" width="90%"></p>

<h3>进 Google 很难吗？</h3>

<p>每当我告诉别人我在 Google 实习过，总有人说：“哇，你好厉害。Google 很难进的！”我说：“一点也不难啊。”他就会说：“你一定是从 MIT 之类的牛校毕业的吧？”然后我就无语了，我不屑于跟这样的人说话。首先，进 Google 的门槛真的很低。说白了，Google 只需要一些低级码农而已！世界上有很多比 Google 技术精深而且尊重个人的公司，所以 Google 并不是很多有志之士的首选。其次，我厉害并不是因为我从 MIT 或者其它什么牛校毕业，而是因为我自己的资质。这种资质不是读了 MIT 或者 Stanford 之类就可以得到的，所以其实我根本不把这些牛校当回事。相反，我看不起这些学校，觉得它们不但徒有虚名，而且相当浮躁。所以说这话的人原意是奉承，结果反倒贬低了我的个人价值，招致我的轻视。</p>

<p>能进 Google 确实是因为我很厉害，但其实比我弱很多的人也可以进 Google，所以能进 Google 根本不能说明我的实力。你认为我到 Google 实习，我的导师们很高兴，很支持，觉得很荣耀吗？恰恰相反，他们觉得我贱卖了自己，我本来应该去更好的地方。当我回到学校，我发现自己成了师兄，老师们的嘲笑对象。有个在 Google，微软研究院等地方都实习过的师兄说：“Google 那种地方去一次就够了，你居然去了两次！”有新同学问道，从我们这毕业，将来能去 Google 工作吗？有个老教授笑笑说：“那个还不容易？Google 招收任何可以做出他们题目的人！”其实正当我在 Google 实习的时候，有在微软研究院的同学来找我，很不解的样子，说：“你为什么不来微软研究院？Google 根本不是搞研究的地方。”后来我才发现，微软对员工个人价值的尊重，明显好于 Google。在微软工作，你至少不需要舔微软的屁股。</p>

<p>那么既然不是那么喜欢 Google，我为什么还要去 Google 实习呢？其实原因很简单很世俗，我当时需要一些钱，而 Google 是最容易进去挣点钱的地方。我这人从来不担心所谓的“前途”或者“事业”，因为我知道自己能力有多么强大。我不觉得为任何公司工作是一种荣耀，我只是有时候拿我很小的一部分技术，出去换点吃的回来。看上去很市井小民吧？但这个世界就是如此，我只是跟它做交易。我就像一个雇佣杀手，专门搞定别人都搞不定的事情。得到这些技术的公司（包括 Google，Coverity，Sourcegraph），其实都很是赚了一笔，因为我卖给他们的东西，比他们给我的工资，价值要高很多。如果没有我，他们可能永远也不会做出具有同样高品质的东西。我敢打赌！</p>

<p>好了，还是来看看我在 Google 的时候都发生了些什么吧。</p>

<h3>受命于危难</h3>

<p>先说说我的项目是怎么开始的吧。当我加入的时候，我的老板 Steve Yegge 的小组试图制造一个跨语言的“服务器”式的编程工具，叫做 Grok。你可以把它想象成 Eclipse, 但是 Grok 的设计目标不只是像 Eclipse 那样检索和分析本机的某一种语言的代码，而是大规模的检索和分析 Google 的所有项目，所有语言，所有代码。这包括 Google 的“四大语言”：C++, Java, JavaScript, Python，一些工具性的语言：Sawzall，protobuf 等，还有一些“build file”和所有第三方的库。Grok 的初期设计目标是一个静态的代码索引服务，只要程序员点击任何一个变量或者函数名，就能“准确”的跳转到它定义的位置。动态的编辑功能稍后也在陆续加入。</p>

<p>这种检索不是像 ctags, etags 那种简单的正则表达式匹配，而是像 Eclipse 和 Visual Studio 那样的准确的“语义检索”，所以它必须真正的理解程序语言的语义。在 Grok 诞生以前，市面上和 Google 内部都没有一个工具能正确的支持所有“四大语言”，所以我不得不说，Steve 的项目比起 Google 的其它跟编程语言相关的项目，是相当先进的。</p>

<p>虽然 Grok 的技术含量很高，但是 Google 的管理层对东西的评价并不是看技术含量的，而是看你有多少“影响力”(impact)，说白了也就是有多少用户。Google 当时本来就只有不到一万个程序员，一个“内部编程工具”能有多少“用户”呢？所以 Grok 比起像 CodeSearch 一类利用正则表达式来查询程序的“低端”项目来说，在管理层心目中并不占任何优势。而且由于其它项目界面好看些，用户多些，Grok 随时有被取消的危险，这使得 Steve 心理压力很大。我就是在这个“危难关头”进入他们的小组的。我当然没蠢到会自己进入这样一个组，但是 Steve 在电话面试时把一切都说得很美好的样子。当时小组里只有三个人：Steve 和另外两个组员。</p>

<h3>不安全感，恐惧和疑惑</h3>

<p>在整个实习的过程中，我都感觉到我所在小组成员的不安全感，这引起了他们的恐惧和疑惑。这种不好的心理状态持续了整个实习过程，使得我在别人的怀疑当中生活了三个月！我不知道如何安慰他们或者让他们相信我的能力，就像我不知道如何安慰一个没有安全感的女朋友。这种感觉，就像是一个女生不相信自己的魅力可以招来这么好的男朋友，所以各种怀疑，纠结，蛮缠。对于 Google 来说，就是不相信自己可以招到这么厉害的实习生。</p>

<p>当我开始的时候，Grok 小组已经初步完成了 Java 和 JavaScript 的检索模块。但是他们的检索并不是从头设计的，而是从 Eclipse (JDT) 和 JSCompiler 里面分别“挖取”了对 Java 和 JavaScript 语义检索的部分，修改之后插入到项目里的。Eclipse 的设计非常的不模块化，以至于项目进行了一年多，大家还在忙着解决它带来的各种 bug。</p>

<p>最开头的时候 Steve 给了我两个选择：检索 C++ 或者是 Python。我觉得 C++ 的设计太繁琐，所以就选择了看起来好一点的 Python。Steve 就让我去找一个好一点的开源的 Python IDE，然后把里面的语义检索部分挖出来插入到项目里面。可是在看过十个左右的“Python IDE”之后，我发现它们没有一个能够正确的“跳转到定义”。分析其原因，是因为这些 IDE 基本上做的是正则表达式匹配，而完全不理解 Python 的语义。所以我对 Steve 说，我要自己从头写一个。但他反对这个提议，因为他觉得这是三个月的时间之内不可能完成的。不但是我不能，而且就算一个小组的高级程序员也不可能完成。就算完成了，他也不想“维护”这些代码。所以他宁愿让我去拿一个不怎么样的开源项目，因为这样“维护”的工作就转嫁到开源项目身上去了。这也许就是 Google 支持开源运动的原因吧？</p>

<p>可是我很清楚的看到，这样一个语义检索，不过是一个抽象解释器 (abstract interpreter)。写解释器是我最在行的，所以我告诉他这是我可以完成的，而且由于设计上的简洁，我的代码的维护代价会比使用一个开源项目小很多。他没有说话。我同时也在进行一些内部培训，看一些视频，折腾 MapReduce 一类的内部工具教程，就这样过了一个星期。我隐约的感觉到 Steve 的不快，因为他不怎么说话了，可是我也没有太在意，仍然傻乎乎的到处凑热闹。到了周五的时候，Steve 下午很早就回家了。另一个组员还待在哪里，不时的叹气。我对她说：“Steve 是不是不高兴了？我知道我说话有点太自信，可能打击到他了。”她好像打满的气球被开了一个洞：“他怎么会被你打击到？你知道他以前做的项目有多厉害吗？他是怕你做不出来。之前有一些 intern 设的目标太高，以至于到最后没有完成他们的项目。”于是她打开 Eclipse，把 JSCompiler 的代码给我看。“你知道我们以前一个类似的项目 JSCompiler，花了多少时间才完成吗？一个小组的人，四年的时间！”她打开其中一个文件，也就是处理符号表的那个模块，说：“看这一个文件就有 9000 多行代码。你三个月能写出这么多代码吗？”我翻了一下白眼，搞笑似地说：“啊～ 怎么可能有 9000 多行？这些人真的知道怎么写这种代码吗……”</p>

<p>后来具体的对话我忘记了，但是她确实给了我一些压力，再加上 Steve 那个闷声子，真是不好受。所以那个周末我没有出去玩，我下载了一个 Jython，把它的 parser 文件 (ANTLR) 拿出来。然后自己设计了一个更简单的 AST 数据结构，把这个 parser 生成的 AST 转换成我的结构。然后就开始在上面写一个抽象解释器。由于 Java 的限制，我想出了一个更简洁的用 Java 实现解释器的方法，从而避免了使用繁琐的 visitor pattern。一个周末之后，我做出了一个基本的原型。当然因为 Python 语言的复杂性，有很多细节的东西到后来才完全的实现。</p>

<p>等到星期一的时候，我告诉 Steve 我做了一个原型出来，而且因为我拿了 Jython 的 parser，我们以后可以用这个理由把这代码 merge 回 Jython，给他们提供功能，让他们帮我们维护代码，对两方都有好处。他居然一点也不高兴，把我叫到一个白板前面，板着脸说：“来，给我讲一下你打算怎么做。”我就画了一个 AST 的类关系图，在里面每个类插入一个叫 interp 的方法，然后指出这个东西就是一个抽象解释器。最后他豁然开朗了一样，说：“好。我相信你知道你在干什么了。就这样做吧。”</p>

<p>虽然貌似经过我自己的努力和坚持，从头做一个工程的计划被接纳了，但是这却不是说之后就没有压力了。这种感觉就像是“皇帝的新装”里的织布工一样。我扬言自己会做出精美绝伦的布料，皇帝的大臣们却看不见，所以他们就相当的小心。总是对我很敬畏的样子，有时会来问候一下，做得怎么样了。可是一旦扯到深入的话题，却又怕被看穿其实他们不懂很多东西。</p>

<h3>陌路</h3>

<p><a href="http://abstrusegoose.com/212">
<img src="http://www.yinwang.org/images/those_who_know.png" width="80%"></a></p>

<p>在 Google 的整个夏天我都觉得跟其他人没有共同语言。我感兴趣的东西，他们一点都不了解。我觉得不以为然的一些东西，却被他们捧上了天。比如，有一次几个人在谈论一个 Google 的“牛人”，说他做了一个多么了不起的项目，很快就升为了 Staff Software Engineer （“Staff”是比“Senior”高一级的职位，Steve 就是个 Staff）。我去看了一下这项目，发现不过就是 JUnit 的“C++ 版本”。JUnit 这东西技术含量本来就是相当低的，做这样一个东西就能当“Staff”，那我岂不是轻而易举就可以成为“Principal”了？哈哈。我心里这样想，但是没有说出来。一个 Staff 就如此，谈到 Google 的两个创始人的时候，有些人就简直是黑白不分了。对他们的各种武断的甚至愚蠢的做法，居然都津津乐道。创始人在他们眼里俨然就跟皇帝一样，他们做什么都是对的。这种浮夸和互相吹捧之风，恐怕是在其它公司也少见的。Google 要求员工们保持一种“Googley”的态度，原来就是这样的态度，过度“正面”和“积极”。西方所崇尚的“个人主义”和“批判性思维”，我在 Google 还真的没有见到过。</p>

<p>另一些时候，我会遇到一些对某种语言或者技术有宗教情绪的人。有次一个工程师坐到我面前，像是在面试我一样，表情严肃正儿八经的开始自我介绍，后来我们就谈到 C++。我说 C++ 设计实在是太繁琐了，其实很多简单的语言效率并不比 C++ 低，C++ 最近其实在向其它高级语言学一些东西…… 后来这人就不说话了。那天以后我就发现跟他打招呼他都不理了。后来我才发现，在 Google 是不可以指出某种语言，特别是 C++ 的缺点的。C++ 在 Google 的势力之大，连 Java 都只能算二流货色。</p>

<p>最让我受不了的其实是 Google 的气氛。总体感觉就是过度“和谐”，没有人说真话，以至于你不知道什么好，什么不好。很多文档，视频，活动都挂着“Google Confidential”的标签。等你去看了，却发现相当幼稚，其实是众所皆知的东西，没有什么机密可言。可是大部分的实习生们却有一种受宠若惊的感觉，或者假装有这种感觉。每个星期五，都会有一个“TGIF”，两个创始人会像主持人一样组织一个大会。本来无可非议，但是总感觉气氛过于群情激昂了，有点像文化大革命时候念红宝书的感觉。好不容易大家聚在一起，总是在听新闻发布，不然就是谈工作。真正大家一起玩的 party，却非常稀少。所以一些别的公司的人都在疑惑，Google 的员工到底有没有下班的时间。</p>

<p>我就是这样度过在 Google 的每一天，以至于后来我都不怎么在饭桌上吃饭了。自己把饭端到靠墙的吧台去吃，或者坐在“冰激凌吧”跟里面的厨师聊天，省得遇到一些高谈阔论的人无语。我发现自己跟打扫卫生的大妈小妹们也谈得来，她们也喜欢跟我说话。后来我发现有这种感觉的不只是我，另外两个比较厉害的博士生也懒的在那边吃饭了。其中一个说，Google 的人太傻了，他一个星期就把组里给自己三个月的项目做完了，因为这帮人完全不知道自己在干什么。</p>

<h3>压力</h3>

<p>直到有一天，我才发现 Steve 为什么这么紧张。那天有另一个“分舵”的 director 来访。他给我们做了一个关于“创新”（innovation）的演讲。基本内容就是说，技术上的创新，如果吸引不到用户，那就不算什么创新，拉得到用户的东西才叫创新。</p>

<p>那天下午，这个 director 来到我们的办公室。表情严肃的“审问”Steve：“你说你每天有 5000 个用户。可是 Google 总共还不到 10000 个程序员。你是怎么算的？你把接受你的服务的那些下游项目的用户全都算进去了吧！”唉，想不到大名鼎鼎的 Steve Yegge 在这种皇帝的钦差大臣面前也只能唯唯诺诺。</p>

<p>我可以说，这个 Python 的东西，虽然不费我很多力气，但却是 Google 里很少有人可以做出来的。就算 Python 的创造者 Guido van Rossum 恐怕也玄，因为这需要比设计出 Python 这样的语言高深很多的专业知识，比如类型理论（type theory）和抽象解释（abstract interpretation）。所以实际上我的这个东西在很大程度上拯救了这个濒临灭亡的项目，因为一旦 Grok 支持所有的“Google 语言”，就会有很多人注意到这个东西，从而会有“影响力”。这确实是后来发生的事，我走了之后，Grok 开始通过 API 给很多项目提供服务，包括 CodeSearch。</p>

<p>可是这种“上级领导”的压力居然也间接的传到了我身上，而且是以一种不尊重的方式。这种感觉就是，你做得再多再出色，你相对于 Google 的“大拿”们，什么都不算。这也许就是 Google 为什么雇佣 Dennis Ritchie, Brian Kernighan, Ken Thompson, Rob Pike, Guido van Rossum 等大牛吧。因为它就可以说：“看我们 Google 有这些顶尖牛人，相比之下你算个什么，要不断努力！”Steve 不止一次的对我说：“你要为 Google 做出杰出的贡献啊！Google 的东西总是最好的，你要做出 Google 一贯的品质来。你知道 Python 的创造者 Guido 也在 Google 吗？我一定会在他面前给你美言几句。”这种语气，我好像在几十年前的中国听说过呢？“你要为祖国做出杰出的贡献！”他也许以为我会受宠若惊，可是我心里却不是个滋味，因为在我心里，自己的地位一点也不比这些大牛低。“宠为下”的道理，你懂吧？</p>

<p>总之他们就是用这种奉承，利诱，竞争，加威胁的方式，想方设法让我多做事情。可是我心里想的是，Google 老爹，您就给了那么点钱，您想买多少东西啊？本来这系统能做出来就不错了，一个组员却一直催着我写 test。她根本不明白，一个程序并不是写了测试就会是个好程序。这个程序经过我多次的大规模修改甚至推翻重来，即使一早写了测试，那些测试也会很快作废。这种大公司给人灌输的“test-driven”编程方式，在这种创造性的程序设计里是根本就是行不通的。要写出这样一个系统，必须全神贯注，深入到语言的本质。而去写测试，往往会打乱原来的思路，所以测试应该是最后完成之后才写的。当我最后完成这个系统，可以大规模的处理 Python 代码的时候，却听见从她的桌上传来一声沉闷的咆哮：“WRITE--THE--TESTS---”这真的非常的 Googley！</p>

<h3>结果</h3>

<p>最后我顺利完成了整个项目，还没少休息和玩耍。现在它仍然是世界上最精确的 Python 分析器，每天都会把 Google 所有的 Python 代码索引一遍。很多内部工具比如 CodeSearch 里面的 Python 文件上的链接，都是这东西做出来的。我所有的代码加起来才 4000 行。处理符号表的模块只有 600 行。我怎么也想不通为什么 JSCompiler 会有 9000 行来处理这么简单的东西，但是也许这就是为什么 JSCompiler 花费了四年时间。</p>

<h3>总结</h3>

<p>所以你看到了，这就是我对 Google 的印象。那种文化大革命似的气氛和对个人价值的忽视，就是我（以及其他很多有志之士）至今不为 Google 工作的原因。Google 是一个年轻的公司，所以比起 IBM，微软之类成熟稳重的老牌公司，确实难免显得浮躁。也许多年以后等它成熟起来，懂得如何尊重个人价值之后，我们还有合作的机会。</p>

<h3>参考资料</h3>

<p>如果你想从另一个角度看看 Google 的问题，可以参考一下 James Whittaker 的博文《<a href="http://blogs.msdn.com/b/jw_on_tech/archive/2012/03/13/why-i-left-google.aspx">Why I left Google</a>》。这个 James 当时是 Google 的一个 director，是 Steve 的老板。我从来没跟他仔细说过话，所以我不能对他做出任何评价。这个文章仅供参考。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>牛校综合征</h2>

    <p>我在牛校待过（清华，Cornell），也在非牛校待过（川大，Indiana）。我见过许多的牛校与非牛校学生，我感觉牛校的学生确实不一样，他们的脑子貌似有一种病。经过很长一段时间，我终于总结出了这病的基本特征，这些症状被我统称为“牛校综合症”。牛校综合症萌芽于进牛校之前的“奋斗”过程，在牛校的人群中互相传染，茁壮成长，然后在毕业后遗传到一些主要由牛校学生组成的公司。</p>

<p>并不是每个牛校毕业的人都会患牛校综合症，但很多都会。我有一些很好的朋友是牛校毕业的，他们却没有类似的问题。所以如果你碰巧是某牛校毕业的，也没必要对号入座。</p>

<p>牛校综合症的主要症状如下：</p>

<ol>
<li><p>舔牛校的屁股。好不容易进了牛校，结果发现不是你上了牛校，而是牛校上了你。你不但被牛校上了，而且事后为了自己的面子，还不能说它的坏话。在你后半生中的任何时候，你都会毫不留情的把这家丑外扬的人灭口。</p></li>
<li><p>显示牛校的标签。读了牛校，自然想享受不一样的眼光，不一样的待遇。可是如果不贴个标签，自己跟个农民工确实看不出什么区别。所以呢，一个常用的作法就是把自己的网络 ID 加上后缀，比如 shax_thu, shax_pku 一类的。另一种作法就是穿印有巨大校徽字样的衣服（一般是T恤或者hoody）。有些人毕业十几年了还留着母校的衣服，就是因为穿上之后显得牛气一些。</p></li>
<li><p>死记硬背，创造力不强。由于牛校一般都不是“为学生服务”，而是“骑在学生头上”的，所以不管哪个国家的牛校，“世界一流大学”，其实大部分都是填鸭式的教育，跟中国的高中没什么两样。在牛校里，很多教授才不管你听不听得懂呢，照本宣科马不停蹄地写黑板，不懂的话你就是笨蛋，不配待在我们学校！牛校学生一般对抄笔记，做（抄）作业，考试非常的在行，对 GPA 非常的关注，而不是很在乎直觉，精髓和思维方法。牛校学生最常见的心理状态，叫做“人心惶惶”。创造力往往是和轻松悠闲分不开的，在牛校如此的忙碌和压力下，创造力怎么可能产生呢？牛校学生往往喜欢显示自己搞得懂各种看似高深，错综复杂的理论，而不喜欢化繁为简，化难为易，因为如果事情变容易了，他们就没有什么优越感了。知识对牛校学生来说是一种负担，而不是珍贵的礼物。学习对于牛校学生来说是一种任务，而不是一种乐趣。世界上最有创造力的天才，其实很多都不是什么牛校毕业的，有些进了牛校辍学了，有很多甚至是完全自学成才，就是这个原因。</p></li>
<li><p>过度重视知识，忽视人格培养。知识其实和金钱一样，是庸俗的东西。中国有句很俗的古话叫做“书中自有黄金屋，书中自有颜如玉”，其作用就是把男人都变呆子，把女人都变妓女。牛校毕业并不能说明一个人人品的任何方面，因为牛校的所谓“教育”，根本就不是用来塑造人格的，而是用来训练机器或者牛马的。我就亲自领略过毕业于哈佛，普林斯顿，斯坦福，清华，北大等学校的人渣的“风采”。徒有野心和知识，太喜欢“奋斗”，却缺乏“人性”，有些甚至连基本的做人道理都不懂。这些人到了社会上，只会跟希特勒一样，给世界带来灾难。相反，非牛校毕业的人，很多更加随和谦虚，更加有人情味，更加善良，有些在专业上也强很多。</p></li>
<li><p>喜欢膜拜和谈论牛人。很多牛校学生其实自己水平一般，头脑里却都是对各种牛人的膜拜和仰慕。他们喜欢拿这些“校友”的名气为平庸的自己撑腰。他们很在乎自己的学校出过什么名人，而没有清楚的意识到他们自己是什么人。
<a href="http://abstrusegoose.com/212">
<img src="http://www.yinwang.org/images/those_who_know.png" width="80%"></a></p></li>
<li><p>门户观念强，很在乎校友关系。牛校学生对校友有一种莫名的亲切感，毕业多年还喜欢组织校友会，比较排外。非牛校学生跟人交往更加随和，一般都不管你是哪个学校出来的。进入牛校，图的往往不是学识，而是“名气”和“关系”，因为这些穷孩子认为牛校是自己通向“上流社会”的阶梯。所以如果某牛校学生听说你是校友，总是喜欢问“你是几字班的？”然后刨根问底的想了解你的底细和历史。</p></li>
<li><p>歧视外校来的研究生（博士生）。所谓“母校”，只是对本科生而言的。如果你本科不在牛校，而是通过考验或者保送进入了牛校，请注意了：你会被牛校的本科生歧视，融不进他们的圈子！本科生们会认为，你本科考不上这个牛校，本科毕业又没能力出国，而考研或者保送（直博）要比高考容易很多，所以你并不是跟他们一样的天之骄子。很多本科生在背地里议论外校来的博士生，都是：“这个人连XX都不会，不知道是怎么进来的！”就连你博士毕业多年以后参加校友会，别人都会问你是“几字班的？”意思是，本科哪一届的？如果你告诉他你是研究生才进牛校的，你就会受到不一样的礼遇。</p></li>
<li><p>优越感强，幽默感差。牛校学生一般对自己学校的所有事情都很当回事，开不起玩笑。特别是没有自嘲精神，面对别人对自己学校，教授，或者自己公司的不重视，会非常的恼怒。牛校容易出呆子，不管什么事情，总喜欢故作高深的从“理论”上追究个所以然，而忽略自己对它的简单感受，从而显得很无趣。</p></li>
<li><p>爱显示优秀。牛校学生满脑子都是“优秀”，他们太在乎自己和别人是不是优秀。他们所谓的“优秀”其实是非常世俗的，就是将来找得到好工作或者发得了财，而不是给社会带来美，快乐，和平和真正的福利。牛校的女生喜欢找“优秀”的男生做男朋友和丈夫，不顾他们长得是否帅气，是否可爱，善良，浪漫或者有趣。很多女生喜欢一些眼露凶光的“优秀男”，大概是因为她们自己太弱了，没法独立生活吧。牛校学生不关心世界的贫富分化和经济危机，因为他们自己就是这些危机的罪魁祸首。牛校学生喜欢的，其实是一个弱肉强食的野蛮世界。</p></li>
<li><p>爱比较。牛校学生喜欢拿自己和别人比较，为自己制造永无止境的高标准和压力。所以牛校学生似乎永远都快乐不起来，因为他们总是这山望着那山高。如果他们嫉妒你，自己却又没法把你比下去，他们就会故意谈论另一个优秀的人，甚至当面拿你和他做比较。总之，他们所做的一切，就是不择手段的让你更加自卑。牛校学生容易跳楼，就是这个原因，因为他们总是感觉其它人都很优秀，感叹自己不如人，而其实呢他们只不过被其他人设计的假象迷惑了。</p></li>
<li><p>脑子里都是数字。牛校学生满脑子都是数字：学校排名，考试分数，GPA，级别，论文引用数，会议影响因子，存款金额，年龄，身高，体重，罩杯尺寸，…… 喜欢数字的原因是他们爱比较，数字可以很方便的做比较，不像其他非数字的事物。 由于不重视感觉，他们不能理解数字不能衡量的很多东西：直觉，感觉，幽默，感情，爱，艺术……</p></li>
<li><p>缺乏生活情趣和休闲精神，喜欢把娱乐当竞赛。牛校学生对待所有娱乐活动都像专业一样严肃，仿佛他们的生活里除了学习还是学习，除了竞争还是竞争。打个网球喜欢追究挥拍动作的角度，兢兢业业的练习所谓“步法”，喜欢比赛，喜欢参加“分级考试”（又一个爱数字的表现）。跑步喜欢绕着规规矩矩的椭圆或者长方形的路线，喜欢设定固定的距离，跑步时不看风景，不关注身体的感觉，关注的是“成就感”。拍照喜欢用巨大笨重的单反相机，喜欢研究各种专业摄影技巧，拍照的目的主要不是为了自己欣赏，而是为了显示给人看。爬山喜欢追求各种先进装备，拿着个 GPS 去险峻的荒山野岭暴走，不懂得欣赏和享受风景，纯粹的自虐狂。平时喜欢埋头快步走路，因为他们在学校里一般就是这样在宿舍，教室，图书馆三点一线间穿梭。遇到集体爬山郊游活动，牛校男生一般都在前面暴走，把女生远远丢在身后。</p></li>
<li><p>喜欢炒作“美女”。由于牛校女生稀少得像大熊猫，所以牛校的女生宿舍一般被叫做“熊猫馆”。一旦有不戴黑框眼镜，看得顺眼些或者稍微会打扮的女生，很快就会出名，然后被男生评为班花，系花，院花，或者起各种绰号，比如“奶茶妹妹”。其实这些女生到了牛校之外真的很一般，可是由于牛校男生见过的美女太少，而且为了反驳外界关于“牛校美女少”的舆论，所以喜欢炒作她们，想让人知道“我们学校也有美女”。而其实呢，牛校的美女能出名，正好说明了那里的美女少。美女如云的地方，美女是出不了名的——天上的云朵有名字吗？牛校男生的几乎一切古怪特征（喜欢显示优秀，把娱乐当竞赛等），很多都是为了赢得那几个美女的青睐。看我 GPA 4.0，钢琴练到十级，网球都打到五级，所以你应该嫁给我！</p></li>
</ol>



  </body>
<h1>=======================================================<h1>
<body>

    <h2>人的价值</h2>

    <p>我具有世界上最先进的文明。做我的朋友本来应该是一件容易的事，可我却很不容易找到一个朋友，因为很少有人具有跟我匹配的“个人价值”。我对人的“估价”，不是取决于他拥有多少金钱或者知识，而是取决于他的内心认为自己有多大价值，取决于他有多尊重和爱戴他自己。具有高价值的人，不需要通过外在事物来凸显自己。如果A崇拜我看不起的B，那么A会被我同样的看不起。也就是说，一个人崇拜的人的价值，决定了这个人价值的上限。很多人在我面前吹捧和膜拜其它人和事物，结果是贬低了他们自己的价值，也让我感觉跟他们说话是降低了身份。</p>

<p>那么是不是说藐视一切的人，在我心目中就有最大的价值呢？是的，如果他真的能发自心底的做到藐视一切。然而可惜的是，只有非常少的人能够做到这一点。很多人看似目中无人，而其实只是自欺欺人，他们的心底其实很在乎一些人和事物。这些人对自己的估价，其实在很多东西之下。比如很多人认为豪车或者名牌服饰是自己身份的象征，所以总想显示这些。一旦有了这种特征，这人的价值就被我定位在了汽车，衣服这类物品之下。有些人喜欢显示自己为某知名公司工作，穿印有公司徽标的衣服，张口闭口拍公司的马屁。这些人的价值，就被我定义在了那被我鄙视的公司之下。</p>

<p>在我的心目中，物质是卑贱的，是为人服务的。所以我不怜惜钱，车子或者其它物品，不觉得穿了什么衣服或者开了什么车，就凸显了自己的价值。在我的心里，我的价值大于所有的这些：名牌车子，名牌衣服，名牌大学，知名教授，高深的理论，知名公司，亿万富翁，甚至民族传统。我的个人价值如此之大，所以我不惜抛弃名牌大学的学位，我不屑为某些知名大公司工作。我毫不在意别人怎么看我，我毫不在意别人定义的所谓“成功”。我最得意的成就，其实就是我自己。这就是我所谓的“个人价值”，这跟一个人对于其它人的“利用价值”，是完全不同的两回事。</p>

<p>我多希望面前的人能够跟我一样，实际上我总是不切实际的假设他是这样的人。我会在他面前拿各种事物和权威开玩笑，因为我一般都善良的假设这个人是一个朋友，他尊重他自己胜过任何其它事物，所以我尊重他这个人，胜过他穿的衣服，胜过他待过的学校，胜过他所服务的公司。很可惜的是，只有非常少的人能够做到尊重他自己，并且能够理解我的做法。有人甚至因为我拿他们崇拜的人，学校，公司，甚至学术理论开玩笑而感到恼怒。对人的个人价值的高度尊重，反而引起了他的反感。我很遗憾，但却并不可惜，因为他贬低了他自己，而我只在乎那些具有跟我有同等价值的人。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>恶评《星际穿越》</h2>

    <p><img src="http://www.yinwang.org/images/interstellar.png" height="400"></p>

<p>（Spoiler 警告，本文含有大量具体情节！）</p>

<p>上周末受朋友之邀，去看了红极一时的《星际穿越》（Interstellar）。因为是在首映的第二天，人多不说，票价也贵一些。可惜开演没多久，我就发现这片子简直跟新闻联播味同嚼蜡，好不容易熬过那漫长的三个小时，到后面几乎是睁一只眼闭一只眼睡过了。</p>

<p>回来之后却发现人们对它好评如潮，<a href="http://www.imdb.com/title/tt0816692">IMDB</a> 评价居然达到 9.0，真是让我匪夷所思。当我正庆幸自己的欣赏水平还没被好莱坞颠覆的时候，惊闻公司小头目决定组织一次 team building 活动，其内容为“八个男人集体观看 Interstellar”。我哭笑不得，遂决定请假一天 :P</p>

<p>我为什么认为《星际穿越》是烂片呢？原因如下：</p>

<ol>
<li><p>Geeky，呆板。导演似乎不认为自己是个导演，而是史蒂芬·霍金，所以通篇都在炫耀自己懂得多少宇宙学原理。他忘记了电影的主要作用是娱乐，电影最重要的价值在于它的故事性和戏剧性。物理学，宇宙学，飞船术语，看上去貌似很酷，但其实让这电影成为了让人犯困的课堂。自称喜欢这部电影的人，往往在于他们可以在事后炫耀自己懂得多少黑洞的原理。</p></li>
<li><p>说教和煽情。“爱是可以穿越星际的力量，你感觉到了吗？”这屁话前不沾村后不着店的冒出来，唐僧了一遍又一遍，恐怕杨过和小龙女听了都会吐吧 ;) 爱是美好而重要的，然而它的力量和作用范围是有限的，不必如此牵强和夸张吧？而且这种感情的东西最好是从情节的点滴表现出来（比较一下好片《<a href="http://www.imdb.com/title/tt0118799">Life Is Beautiful</a>》或者《<a href="http://www.imdb.com/title/tt0108160">西雅图不眠夜</a>》），这样直白的平铺直叙，就索然无味，起不到效果了。这体现了好莱坞一贯以来的作风，跟我党一样，喜欢对民众进行“思想品德教育”，把观众当低龄甚至弱智儿童对待。这种说教倾向在 Disney 的片子里面最为明显，然而它也贯穿了许多本来旨在给成人看的好莱坞电影。</p></li>
<li><p>主题肤浅，片面追求特效。一部电影应该有一个主题，所有的情节，特效，都应该是为主题服务的。这部电影的主题貌似是关于“爱”，然而它用于支持主题的情节非常牵强扯淡，以至于完全没有力量支持它所期望的主题。“5, 4, 3, 2, 1, 点火！”，炫酷的飞船和宇航服造型，主人公在船舱中的各种装模作样的操作，…… 好像很酷的样子？可是这一切都没法掩盖剧情的苍白无味。相反，剧情的肤浅让这一切的高科技模型，都显得像小孩子玩过家家的道具一样可笑。我看着那些飞船和宇航服，越看越像是泡沫塑料做的。“人间大炮，一级准备……” 好莱坞，多拍点给成人看的片子好不好？</p></li>
<li><p>故作深沉，过于安静，感觉成本很低。片中有大量独白，有好几次就两个人在那里“说真心话”。这种对白如果有好的铺垫，少量出现的话会有效果。然而本片没有做好铺垫，所以这些对白突然出现的时候，让人感觉不自然，不真实，故作深沉，煽情，冗长。搞得整个放映厅里鸦雀无声，观众面面相觑，大气都不敢出，感觉不舒服不自在。片中很多外太空画面是完全的寂静，没有背景音效，让人感觉是不是拍片时资金不足，请不起人来做音乐。整个片子感觉非常“低成本”，低到了吝啬的地步，也许几个人在一个房间里聊聊天，然后用电脑做做特效，就可以拍摄完成。</p></li>
<li><p>严重的“常理漏洞”。有物理民科朋友看了此片之后兴奋的叫好：片子里的物理学，黑洞原理，居然没有破绽！可是这位朋友虽然了解高深的物理学原理，却缺乏一种重要的，普通人都明白的道理，叫做“常理”。常理决定了特定的人在特定的时候该说什么话，该有什么行为。这片中的人物有一些非常严重的，违反常理的漏洞，让人哭笑不得。其中一个就是，快到穿越 wormhole 的时候，副驾驶拿起一张纸，开始循循善诱的给机长（主角）讲解 wormhole 是什么，以及它的工作原理，仿佛机长在这次目的为“穿越 wormhole” 的任务发射升空之前，完全不明白 wormhole 是什么似的。这就像是开着 F-18 到了航母面前，才开始了解它的跑道长度一样！</p>

<p> 我才不管你的 wormhole 理论讲解得有多么透彻多么通俗易懂，因为这样的对话根本就不应该在那个时刻，那个地点，在那些人物之间出现。能犯这样的错误，其最终原因还是因为好莱坞把观众当小孩，喜欢说教。这一番科普，俨然是导演安排讲给观众听的，而不是讲给机长听的。银幕前的小朋友们来看那，wormhole 就是这样的，就像一张纸，被折起来了哦，咔嚓…… 某些人看电影总是很“理性”的跟踪其中所描述的“高深理论”，如果发现没有破绽，“学到了东西”，就觉得是好片。只有当你跳出“学物理，理解宇宙原理”这一思想圈套，才会明白这些人物的行为是多么的可笑，荒唐，不合情理。剧中人物还有很多类似的诡异对话和行为，有待大家进一步发掘。</p></li>
<li><p>又臭又长。故事很烂就算了，如果只有一两个小时还可以忍，可是此片居然有三个小时！所以真是忍无可忍，必须喷了！</p></li>
</ol>


<p>最后，我对观看此片之后深入探讨第一个星球上的大水如何可以弄死人以及最后女宇航员去了哪个星球之类“学术问题”的朋友表示崇高的敬意和深切的慰问！我对此类问题统一的终极答案为：导演的安排！</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>谦虚不是一种美德</h2>

    <p>人们常说谦虚是一种美德，然而我发现其实并不是这样。</p>

<p>首先，谦虚是一种不诚实，虚伪的做法。这是因为谦虚的定义本身就意味着你要对自己的资质有所保留，直白点说就是，你要撒谎说自己其实没那么好！比如一个本来很有才华的人，做出了一个顶尖的研究成果，非要谦虚地说：“哎呀，比起某某大牛的成就，其实还差得远……”这种说法，把他自己的成果掩盖在别人的阴影之下，以至于让人难以看到它的价值，这对于世界的学术水平的提高其实是一种损失。谦虚本身就是一种谎言，你说它能是美德吗？</p>

<p>其次，谦虚的产生跟嫉妒有很大的联系。中国有句古话叫“枪打出头鸟”，就是人们嫉妒情绪的写照。如果一个女人很美，或者穿得很华丽，在场的所有女人就开始嫉妒她。如果一个男人很出类拔萃，同行的男人们都开始嫉妒他。所以呢，如果你称赞一个中国女人很美，她的回答往往不是“谢谢！我也这么觉得！”而是“哪里有~不如那谁谁谁……”如果你称赞一个中国男人很聪明，他往往对你说：“不敢当不敢当！哪有领导您聪明呢~”他们之所以说这样的违心话，就是因为害怕其他人的嫉妒，害怕其他人因为嫉妒而伤害自己。嫉妒是一种极其卑劣的情感，而谦虚经常来源于对嫉妒的恐惧，你说它能是美德吗？</p>

<p>所以，谦虚其实不是一种美德。它是一种虚伪，一种妥协，一种无奈。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>怎样成为一个天才</h2>

    <p>有人说我是天才。我一直“谦虚”得很， 从来不承认。可是纵观像 John Nash，Richard Feynman 这些公认的天才的各种特征和生活遭遇，我发现自己还真是一个天才。我知道这个事实已经很久了，这一方面让我开心，另一方面又让我痛苦。可是除非洗脑技术高度发展，一旦成为了天才，就很难再还原成普通人了。所以目前我只是做一天天才撞一天钟 :)</p>

<p>那么天才到底是什么呢？我想这是很多人都不明白的问题。大部分人都是人云亦云，别人说这人是天才，他们就以为是天才，也不仔细看看这人思想如何，就开始膜拜。所以现在我作为一个天才，本着学究的态度，对天才的本质做一个探讨，然后介绍一下成为天才的方法。</p>

<h3>天才和聪明的区别</h3>

<p>很多人都把天才和“聪明”混为一谈，以为天才就是非常聪明，头脑特别快，或者记性特别好的人。可是天才往往并不显得聪明，想问题也并不快，而且记不住很多东西。天才的价值并不在于快，而在于他们能想出其他人都想不出来的东西。</p>

<p>人们的这一误解往往是因为媒体和传记作家对天才的肆意吹捧。传说有人问过冯诺依曼一个问题：两列火车相距100公里面对面行驶，时速50公里。一只苍蝇以时速75公里在两个火车头之间来回飞，碰到一个火车头就掉头飞向另一个，如此反复。请问苍蝇被这两列火车挤死的时候飞过了多少距离？冯诺依曼眨了一下眼说：“75公里。”这人很惊讶，问冯诺依曼你是不是听说过这道题，用了捷径。 冯诺依曼说：“什么捷径？我只不过做了一个积分而已。”</p>

<p>这就是一个典型的“都市传奇”（urban legend）。我觉得冯诺依曼只不过是幽默了一下，结果就被某些人永远的记录在册。这种故事的负面作用，在于它夸大了天才头脑的“硬件性能”，让其他人觉得成为天才是可望而不可即的事情，从而对其进行膜拜。能快速的心算做积分，真的是很了不起的事情吗？恰恰相反。夸大头脑的速度，其实贬低了冯诺依曼，让人误以为头脑速度快就是他的天才之处。现在如果你把这积分式子输入到 Mathematica 或者 Maple 里面，不到一秒就算出来了。这机器都能做的事情，能说明人是天才吗？冯诺依曼的天才不在于他自己的头脑速度快，而在于他提出的一些理论，导致了比任何人的头脑都要快很多的机器的产生。这些机器产生的目的，是为了帮我们偷懒，把我们从繁琐枯燥的计算活动中解脱出来。</p>

<p>所以，头脑的硬件性能并不是天才的本质特征。头脑速度快的人，跟跑得快的人差不多，只是体力比较好。我欣赏跑得快，体力好的人。大自然赋予了他们其他人没有的财富，但那并不叫做天才。也许那种天赋的速度比天才还要难得，但天才往往不喜欢太快，因为过快的速度会让人变成机器，停止思考，走上歧途。天才喜欢反复审视前进的方向，所以他们经常能找到偷懒的方法。天才喜欢偷懒，并且利用巧妙的设计让大家都可以偷懒。</p>

<h3>从动手中学习（learn by doing）</h3>

<p>如果你看过 John Nash 的传记《A Beautiful Mind》，就会发现他与其他人的不同。Nash 看书只看封面和开头，把这书要讲的问题了解清楚之后，就自己动手解决。最后，他完全依靠自己的“头脑暴力”创造出整本书的内容。Nash 头脑里的数学知识，绝大部分是他自己造出来的，而不是看书看会的。也就是说，他把整个的研究领域作为一道道的练习题，用这种方式独立创造出了大部分的现代数学！Learn by doing, 这就是天才最重要的特征。</p>

<p>另一位天才 Richard Feynman 也有类似的特点。由于他脑子里的东西基本都是自己想出来的，所以同一个名词，在他头脑里关联的概念，其实是跟其他人很不一样的。这种现象体现在他的自传《What Do You Care What Other People Think?》里面，他说：“我不知道这个东西的名字，但我却知道这个东西是什么。”这也体现在他的一些<a href="http://research.microsoft.com/apps/tools/tuva">演讲视频</a>里。看 Feynman 演讲的时候，有时候你发现他用错专业名词，或者想不起来叫什么，跟听众确认了发明这概念的人不在场，然后说：“反正那家伙不在……所以管它叫什么呢。你们知道我在说什么就行！”</p>

<p>天才往往依靠自己的直觉和想象力，而不是经验。这就是为什么爱因斯坦说“想象力比知识更重要”。天才记不住那些吓人的名词，却更深刻地知道那些名词所代表的意义。天才不喜欢显示自己知道很多，不以自己“不知道”为耻，因为虽然他可能暂时不知道一些东西，却总能在需要的时候琢磨透彻，所以知不知道一些东西，很多时候其实是无所谓的。也许这就是所谓“大智若愚”吧。</p>

<h3>怎样成为一个天才</h3>

<p>现在我来讲一下，如何成为一个天才。其实说实话，我现在有点后悔自己为了成为天才费了这么大力气，放弃了那么多的乐趣。所以看过这段之后，你也许就不再想成为天才了。不过如果你执意要做天才，也许会受到一定的启发。</p>

<p>人们常说，天才出于勤奋，所以首要的一点是你必须为此投入巨额的努力，甚至做出巨大的牺牲。从我的经历来看，这一点也不假。天才都是孤独的，因为只有孤独，他们才能有自己的时间和空间来进行思考。为了成为今天的自己，我放弃了很多其他人追逐的东西，可以说是经历了千辛万苦。</p>

<p>仅就孤独这一点，就足以让很多人望而却步了。但仅有艰苦卓绝的勤奋，也不一定能成为天才。你必须把勤奋用在巧妙的地方。在计算机领域，很多人喜欢抱着大部头的专业书籍看，其实那是事倍功半的努力。学而不思则殆，就是这个道理。书籍让你记住了现成的“事实”，却不能让你拥有产生出这些知识的能力。它们只是把你“训练”（train）成了循规蹈矩的流水线工人，而不能让你受到真正的“教育”（education）。真正的好书都是很薄的，“把厚书读薄”这句话其实是误导的。厚书本来就不应该拿来读，最多可以拿来当字典查。所以我的建议是：如果你想成为天才，就避免去读厚书。去寻找简短的书来入门，然后就可以自己思考了。这就是我从 Nash 的故事得到的启发。</p>

<p>笛卡尔（René Descartes）写过一篇文章，讲述如何成为一个天才。他说，在人生中的某个时候，他决定开始仔细检查自己头脑里的思想。他翻出自己所有的想法，寻找它们的最初的“来源”，然后审视它们。这种来源有可能是父母，有可能是传统，有可能是学术权威。当他发现某个来源有问题的时候，他就抛弃从这个来源获得所有想法。我从这篇文章得到了启发，所以我也用了很多年时间，对自己头脑里的想法做了一件差不多的事情。你可能很难想到，一个不知不觉窜到你头脑里的错误想法，会导致你永远无法发现更好的东西，甚至会毁掉你的一生。因为这个原因，我抛弃了很多未经思考就接受的权威的思想，我抛弃了很大部分的中国传统，我审视美国和世界的文化，尽一切可能的防止错误的思想进入我的头脑。所以虽然我并不富裕，我却拥有比很多富有的人更多的自由。这种自由，给了我思考的时间和机会。</p>

<p>要成为天才，必须要能够打破别人设下的思维圈套。去除自己头脑里的各种<a href="http://www.yinwang.org/blog-cn/2014/01/04/authority">权威</a>，是非常重要的事情。你必须首先在心理上把自己放在跟本领域的权威平起平坐的地位，才能有效地对他们的想法做出判断和消化。我喜欢对权威显示出藐视的态度，就是这个原因，这是一种“矫枉过正”的方法。因为他们最开头在我心里还占有很重要的地位，为了把他们轰下去，我最开头是很激烈的藐视。到后来自己的认识因此迅速加深之后，才开始慢慢的理解到他们其中一些想法的启发意义。最后那种激烈的情绪逐渐消亡，他们在我心里也就变成了很普通的人。对于计算机领域的人我想强调一点，你们特别需要注意看到 Unix 系统的缺陷。很多人盲目的崇拜 Unix 的创造者，这使得他们看不到它们的设计缺陷，看不到 Unix 的设计者思想的局限性。不错，胜者为王的心理可以让你找到一份好的工作，但我在这里讲的是如何成为天才。Unix 的创造者并不是天才。</p>

<p>要成为天才，你必须使用直觉（或者图形），而不是符号（或者文字）进行思考。这是很显然的事情，因为人脑根本不是用符号进行思考的。符号只是不同的人脑之间进行信息交互的媒体，就像电脑之间的网线上传输的信号，它并不存在于思维活动中。有些人可能会告诉你，直觉是不可靠的。这些人并不是天才，所以不用听他们说什么。直觉可靠与否，是由你自己的造诣决定的。这些人没有得到可靠的直觉，所以他们就连直觉的价值一起给抹杀了。这里面也许有嫉妒或者故意误导的成分。真正的天才，比如 Nash 和 Feynman，都是用直觉思考的。别人的公式在进入他们头脑里时，首先被翻译成某种“思维模型”，然后他们的头脑对这种模型进行思考。他们通过直觉对这些模型进行变换操作，得出结果。然后他们用符号把这结果表示出来，为的是给其他人看。那些完全用公式进行推导的人，往往是纸上谈兵，只能做出衍生的结果，而不能做出突破性的发现。</p>

<p>为了得到直觉，你必须去接近自然界，必须出去寻找灵感。这就像作家需要出去“采风”，画家需要出去“写生”一样。蹲在家里看书，思考，会让你的思维局限于文字和符号所能表示的东西，没法达到突破。如果你能看到我的头脑如何思考，你就会发现，当我的眼睛看到代码或者公式的时候，我的头脑看到的并不是代码和公式，而是自动把它们翻译成了一些电路，流体导管一类的东西，它们存在于一个具有多重现实和历史的，像 Matrix 一样的世界里。这些直觉都不是从书里来的，也不是老师教的，而是通过观察身边的事物得到的。这就是为什么你听说有位古人洗了一个澡，然后发现了重大的物理学规律。Nash 在酒吧看到一个绝色美女，然后想出了他最著名的成果。</p>

<p>另外，你还需要休息。很多人一天学到晚，一天想到晚，以为这样就可以有所成就。可是人脑需要足够的休息和间歇的时间，才能从你想过的，看过的东西里面提取出精华的东西。Feynman 有个方法我觉得很管用。他说，如果你想成为天才，就在你的头脑里随时准备好12个需要解决的问题。每当你的生活中发生一件事，就把这些问题拿出来检查一下，看其中是否有问题会得到进展。当然，你不一定要准备12个之多，也不需要刻意的去回忆它们，否则你就会很累。这个过程应该是由“潜意识”来完成，而不需要你做出努力。如果经过了比较深入的思考还没有得到结果，你可以出去放松一下，然后说不定忽然间你的问题就被解决掉了！这是因为一旦你启动了有意识的思维，当你停下来去做其他事情的时候，你的头脑并不会停止思考，而会把这问题转交给潜意识。潜意识有一种神奇的力量，它会在接受到外界的某种微妙的激发之后，忽然间顿悟。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>黑客文化的精髓</h2>

    <p>听说“黑客文化”这个词，就像在昨天。想起它，眼前就出现一些头发蓬乱，穿黑色道袍的人。最早的时候，他们努力地向人们澄清：“黑客”不是贬义词，不是指那些入侵电脑网络的罪犯。当人们明白过来之后，他们开始告诉人们如何成为一个黑客，并且把黑客与画家相提并论。当人们受到鼓舞，决心成为黑客之后，他们开始向这些人灌输黑客的“行为守则”，“提问的艺术”等等。总之就是说，你得显示出一些非常重要的特征以证明你是高手，并且教育那些菜鸟们。否则按照我们的标准，你就不是个黑客！</p>

<p>于是忽然间，我来到了这个黑客遍地的世界。体验着，忍受着自己向往已久的“黑客文化”。</p>

<h3>某大牛说……</h3>

<p>一个中等水平的黑客要说服一个菜鸟水平的黑客，方法很简单：引用一个超级黑客的话。至于为什么嘛，我也不知道，总之你照办就是了。最好记住那超级黑客的名字，以后再遇到不懂事的菜鸟就用同样的方法教育他，免得我亲自来动口舌！</p>

<h3>笨蛋才不会用这个工具</h3>

<p>黑客的世界里有很多背着历史包袱，设计拙劣，你却不得不用的工具。黑客文化的其中一个作用就是掩盖这些工具的设计失误。这定律被我叫做“都是用户的错”。</p>

<p>你的智商和能力被一些肤浅的标准所衡量，你每天都在提心吊胆的接受各种审查。这两个 Git 命令的区别都不知道？还当什么黑客！哪个学校毕业的？老师连这都没教过你们？哎，算我面试时看走眼了。</p>

<p>于是为了显示自己有能力，接受过良好的教育，你不敢再问这种问题。为了避免再受伤害，为了掩饰自己的“无知”，你变成了一只刺猬。你开始用自己会的那点东西去审查其他人，伤害其它人，以为这样就可以保护自己。这些被伤害的人又转而去伤害更多的人。</p>

<p>Visitor pattern 都不会写？还当什么黑客！这厮今天终于让我抓住把柄了 :)</p>

<h3>只有天才才能理解它的简单</h3>

<p>某超级大牛说过，我的系统是简单的，但只有天才才能理解它的简单。</p>

<p>你敢说我的系统不简单？哼哼，那你肯定不是像我一样的天才。你知道吗？其实我爷爷的爷爷是给皇帝做衣服的。他的座右铭是：看不见这衣服的人都是白痴或者不称职的人。</p>

<p>所以你不敢说任何东西太复杂，太难用，太不可视化，对用户不友好。否则就会有人鄙视你：菜鸟，白痴，人笨怪刀钝！</p>

<h3>择其难者而从之</h3>

<p>做一件事有两种方法，一种容易一种难，你会选择哪种？</p>

<p>普通人都会选择更容易的，但是很奇怪的是，受到黑客文化熏陶的人，往往会选择困难的那种。如果这选择只是个人的喜好，如果他们尊重其他人的选择，那还无所谓了。但十有八九，选择了明显更加难用的工具的人，并不会从心底尊重那些选择更加容易的工具的人。这貌似是一种必然的结果。</p>

<p>这其实是心理上的优越感在作怪。很多人选择困难的工具，并不是因为真的觉得它们好用，而是因为只有用其他人不会的东西，才能显示出自己的特殊性，显示出高人一等的水平。由于其根本的动机就来自于优越感，所以他们是不可能不找机会利用这得来不易的优越感的。</p>

<p>有些人虽然可能口头上不说，但他们随时都在观察，看其他人选择了哪一种工具。那些选择了（或者倾向于选择）更容易的方法的人，会在他们的印象中产生一种肤浅的感觉，从而不会真正的被尊重。这种不尊重累积起来，就会开始隐约的表现出来，从而导致同事间工作关系的恶化。当然也有人更加露骨一些，直接就问别人选择了什么工具，然后嘲笑那些选择了容易工具的人为菜鸟。</p>

<p>常见例子：</p>

<ul>
<li>VIM 与 Emacs，选择 VIM</li>
<li>Emacs 与 IntelliJ（编辑 Java），选择 Emacs</li>
<li>组合键与方向键（移动光标），选择组合键，因为“并不是每个键盘都有方向键的！”</li>
<li>Linux 与 Windows，Mac，选择 Linux</li>
<li>Gentoo 与 Ubuntu，选择 Gentoo</li>
<li>Terminal 与 GUI，选择 Terminal，使用黑底绿字</li>
<li>TeX 与 Word，选择 TeX，拒收 .docx 附件</li>
<li>C++ 与 Java，选择 C++</li>
</ul>


<h3>RTFM!</h3>

<p>RTFM = Read The Fucking Manual!</p>

<p><a href="http://abstrusegoose.com/227">
<img src="http://www.yinwang.org/images/the_fucking_manual.png" width="60%"></a></p>

<p>（图片来源：<a href="http://abstrusegoose.com/227">Abstruse Goose</a>）</p>

<p>惯用法：有人在#java聊天室问了一个问题，结果大家回答说：“RTFM！”“菜鸟，去读了 API 再来这里混！”</p>

<h3>你不会 Google (百度）吗？</h3>

<p>当这种现象普及开来之后，普通的问题你都不能问别人了。比如：“哎，今天会不会下雨呢？”因为在黑客文化里，别人的回答会是：“你不会 Google 吗！”当然，在中国这句话就是：“你不会百度吗！”</p>

<p>就像 IRC 里面的人一样，我不明白他们为什么在那里面，仿佛他们唯一的乐趣就是告诉别人“你不该问这个问题”，“你浪费了我的时间”。当这种现象普及到更广的社会，你知道会有什么结果吗？任何人都不要再对任何人说话了，因为说话全都是浪费时间。</p>

<p>“你不该问这个问题”这种说法是非常大的攻击行为，它是人类良好社会关系的杀手。其实对别人“该不该问这个问题”的“考虑”本身就是一个错误。我们甚至不应该说“你可以问这个问题”，因为那应该是不言而喻的，想都不用想。</p>

<p>任何人都允许问任何问题并不等于会浪费你的时间，因为你并不是必须回答每一个问题。所以我的做法总结下来就是一句话：我誓死捍卫你问问题的权利和尊严，但我不一定要回答你。比如在 IRC 聊天室，如果遇到有很初级的问题我懒得回答或者太忙，我不吭声就是了。我对问问题的人没有任何反感，我只是等其他人去回答他。但是“你不会 Google 吗！”肯定是非常不礼貌的做法。</p>

<h3>你问我，所以你懂的没我多</h3>

<p>子贡问曰：“孔文子何以谓之文也？”子曰：“敏而好学，不耻下问，是以谓之文也。”</p>

<p>可不要被孔老二误导了！在黑客文化里，这种不耻下问的行为是相当危险的。一次可能还好，多几次之后，我看你不被当成傻b菜鸟才怪。</p>

<h3>希望你向我们学习</h3>

<p>进了新的黑客公司很兴奋哈？可是发现代码里有不大好的地方怎么办呢？如果吭声，立即讨人嫌。如果不吭声，那就等于承认了我们的代码是“模范”咯。跟着学吧，小弟。要学像哦！</p>

<h3>这就是我们的作法</h3>

<p>我们刚从某大公司挖来一个世界级高手。结果他对我们引以为豪的一段代码提出了异议，说那是 premature optimization，思路不清晰。切！</p>

<p>虽然他是世界级的高手，可我们才是这里的地头蛇，所以我们得告诉他：“这就是我们的作法！”</p>

<h3>结束语</h3>

<p>上面的小片段，估计在你自己的生活中已经出现过很多次了吧？它们也在我的生活中出现过很多次。不同的学校或者公司，有可能出现其中的几种或者全部。其实哪里来的什么“黑客文化”？文化就是文化，管你做什么工作。不要忘了黑客不过是一种工作，跟医生，律师，厨师，教师一样的。所谓黑客文化只不过是为一些人的各种无理怪癖找借口，搞特殊化。</p>

<p>按照以上标准，我不认为自己是个黑客。我是一个计算机科学家，我按照几百年来国际通用的礼节行事。计算机科学家与黑客的区别在于他不只按照工具的手册来完成规定的任务。他经常记不住别人设计的复杂工具如何使用，因为他本人是一个更好的设计师。他审视这些工具的设计合理性，发现蹩脚的地方，然后构思更好的设计方案。他总是嘲笑和自嘲，我们其实仍然生活在计算机的石器时代。</p>

<p>在自己的公司里，我希望创造一个更加人性化的氛围，而不是宣扬所谓的黑客文化。让所有人无论男女，无论水平如何都身心舒坦，受到尊重，可以谈天说地，不耻下问。</p>

<p>如果上面有我没有概括到的经典情况，欢迎<a href="mailto:shredderyin@gmail.com">来信</a>告诉我。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>电视编剧的问题</h2>

    <p><img src="http://www.yinwang.org/images/from-star.jpg" width="40%"></p>

<p>听一朋友说“远离韩剧，保护智商”，誓死不看脑残剧《来自星星的你》。觉得好奇，于是乎想看看它为何脑残。开头还觉得挺有创意，风趣幽默，前后呼应，逻辑严密。对它看法大有改观，于是继续看下去。直到第11集的时候开始发现上当，及时悬崖勒马。</p>

<h3>公式</h3>

<p>是什么问题呢？问题在于，当坏人都已经打倒在地，证据在手，可以轻易把他绳之以法的时候，却完全无脑地放过了他，反倒让自己被诬陷。这对于一个拥有超能力的外星人来说是不可原谅的错误，于是我能预测到都教授以后还会继续做类似的事情，继续让人着急。而这部电视剧也从此不再依靠创意，而是靠各种扭捏的伎俩来欺骗观众的时间了。这种招数被我称为“坏人不灭定律”。</p>

<p>就算你要留他活命也不要这么无脑啊。现在我举出几个简单的策划，可以让这剧比较“有脑”地演下去：</p>

<ol>
<li>坏蛋耍花招使暗器，结果不小心被推下悬崖。结果后来找不到尸体，原来是被另一邪恶的外星人救了。后来这俩成了都教授的死对头……</li>
<li>坏蛋其实自己就是外星人。是几年前杀掉了大哥，附在他的躯壳上面的。都教授没有料到，被整了……</li>
</ol>


<h3>对比</h3>

<p>比起美剧 LOST 在第一季25集完结之后才让我悟出一定的道理，《来自星星的你》功力还是不大足。而这两者比起像《Dark Angel》（James Cameron 编剧 ）之类超级顺畅的美剧又差太远了。有时候看电视电影还真得 follow 你所认可的编剧或者作家，而不是演员。另外我也不推荐 Dark Angel 第二季，尽是这怪物那怪物的出来，却没有很有意思的剧情。我猜本来并没有设计第二季，但是看到第一季收视率高，所以想乘火打劫多赚点钱，于是开始现炒现卖，打怪升级。</p>

<p>这样的娱乐到后来就不是娱乐，而是受罪了。同样的原理适用于像《生化危机》那样折腾的游戏。那种游戏到后来就不再是在消遣了，而是像完成任务一样跑来跑去的。累不累啊。</p>

<h3>相关推荐</h3>

<p>虽然后来有了败笔，《来自星星的你》前10集的剧情和主题其实不错的，所以不能全盘否认它的价值。它与其它一些我看过的东西类似，都有一个外星人主角和比较深刻的爱情主题，所以在这里推荐一下：</p>

<ol>
<li>电影《<a href="http://www.imdb.com/title/tt0486655">星尘</a>》（Star Dust）</li>
<li>小说《<a href="http://www.xiaowangzi.org">小王子</a>》</li>
</ol>


<h3>启发</h3>

<p>韩剧的毛病也许不能怪编剧们。没有很多人真的是想要给世界留下什么宝贵的精神财富。为了混饭活命，这拖泥带水的问题从莎士比亚那时代就开始了 :) 学术界的论文其实与电视编剧也有惊人的相似之处。每个领域最初的经典 paper 一般最有价值，而后来的“续集”就往往是为了领域的“生存”而写。所以不要以为心目中的大师们是什么神，他们也跟我们一样是混饭吃的人类。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>天下第一萌程序</h2>

    <p>很多人都以为我最爱的程序是那“传说中的王垠40行代码”。那段代码固然是天神衣袖般的优雅，然而它却没有地球的气息和灵魂。其实我最爱的程序是下面这段 <a href="http://www.racket-lang.org">Racket</a> 代码。有一天，空中出现一道亮光，隐约的听到一些哼哼声，然后我飞速的写下了它。后来发现，这是数学，艺术以及中西方文化的完美结合，绝版的艺术品。</p>

<p><img src="http://www.yinwang.org/images/racket-pig.png" width="80%"></p>

<p>其中猪头照片来源不明，归其版权者所有。“猪头三”原意不明，可以参考 <a href="http://zh.wikipedia.org/wiki/%E7%8C%AA%E5%A4%B4%E4%B8%89">wikipedia</a>，但我对这个词的常用法跟它的愿意有所不同，含有非常可爱的涵义。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>RubySonar：一个 Ruby 静态分析器</h2>

    <p>在过去一个多月时间里，我大部分时间都在做一个 Ruby 的静态分析叫做 <a href="https://github.com/yinwang0/rubysonar">RubySonar</a>。它使用与 PySonar2 类似的技术，不过针对 Ruby 的语义进行了很多调整。现在这个分析器已经能够支持 <a href="https://sourcegraph.com/github.com/rails/rails">Sourcegraph</a> 的 Ruby 代码搜索和浏览。这比起之前的效果是一个很大的进步。</p>

<p><a href="https://sourcegraph.com/github.com/jekyll/jekyll/symbols/ruby/gem/Jekyll/Command/$classmethods/globs">
<img src="http://www.yinwang.org/images/rubysonar1.gif" width="80%">
</a></p>

<p>在 RubySonar 的帮助下，对于很多 repo，Sourcegraph 可以搜索到比以前多几十倍甚至上百倍的符号，当然代码的使用范例也随之增加了。代码定位的准确性有很大提高，基本不会出现错位的情况了，另外还支持了局部变量的加亮，所以看起来有点像个“静态 IDE”的味道。</p>

<p>由于 RubySonar 比起 Sourcegraph 之前用的基于 <a href="http://yardoc.org">YARD</a> 的分析在速度上有上百倍的提高，我们现在可以处理整个 <a href="https://sourcegraph.com/github.com/ruby/ruby">Ruby 标准库</a>（而不只是以前的一小部分）。<a href="https://sourcegraph.com/github.com/rails/rails">Ruby on Rails</a> 的结果也有比较大的改善。另外，以前不支持的像 <a href="https://sourcegraph.com/github.com/Homebrew/homebrew">Homebrew</a> 之类的独立应用，现在也可以分析了。</p>

<p>RubySonar 的静态分析使用跟 PySonar2 相同的跨过程，数据流+控制流分析，而且采用同样的类型推导系统，所以分析的精度是很高的。我还没有跟 Ruby 的 IDE 比较过，不过因为构架的先进性，它应该已经能处理一些现在最好的 Ruby IDE 也搞不定的事情，当然由于时间短，在细节上比起它们肯定也有不足之处。</p>

<p>虽然 Ruby 和 Python 看起来是差不多的语言，为了把 PySonar2 改到 Ruby 上，还是做了不少的工作的。最开头我试图让它们“重用”大部分代码，只是在不一样的地方做一些条件分支进行特殊处理。可是后来发现这样越来越复杂，越来越危险。为了照顾一个语言的特性，很容易破坏掉为另一个语言已经调试好的代码。结果最后决定把它们完全分开，其中共享的代码通过手工拷贝修改。事实证明这个决定是正确的，否则到现在我可能还在为一些莫名其妙的错误伤脑筋。这个经验告诉我，所谓的 DRY（Don't Repeat Yourself）原则其实有它的局限性。有时候真的是宁愿拷贝粘贴代码也不要共享。</p>

<p>目前 RubySonar 还缺少对 native 库代码的支持，但是由于代码始终保持了简单的原则（RubySonar 只有 7000 多行代码），那些东西会比较容易加进去。感兴趣的 Ruby 用户可以看看自己的 repo 是否已经得到处理，如果没有的话可以来信告诉我，也欢迎给我指出其中存在的问题。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>程序语言与它们的工具</h2>

    <p>谈论了这么多程序语言的事情，说得好像语言的好坏就是选择它们的决定性因素。然而我一直没有提到的一个问题是，“程序语言”和“程序语言工具”的设计，其实完全是两码事。一个优秀的程序语言，有可能由于设计者的忽视或者时间短缺，没有提供良好的辅助工具。而一个不怎么好的程序语言，由于用的人多了，往往就会有人花大力气给它设计工具，结果大大的提高了易用性和程序员的生产力。我曾经提到，程序语言其实不是工具，它们是像木头，钉子，胶水一样的材料。如果有公司做出非常好的胶水，粘性极强，但它的包装不好，一打开就到处乱跑，弄得一团糟。你是愿意买这样的胶水还是稍微差一点但粘性足够，包装设计合理，容易涂抹，容易存储的呢？我想大部分人会选择后者，除非后者的粘性实在太弱，那样的话包装再好都白搭。</p>

<p>这就是为什么虽然我这么欣赏 Scheme，却没有用 Scheme 或者 Racket 来构造 PySonar 和 RubySonar，甚至没有选择 Scala 和 Clojure，而是“臭名昭著”的 Java。这不只是因为 PySonar 最初的代码由于项目原因是用 Java 写的，而且因为 Java 正好有足够的表达能力，可以实现这样的系统，但是最重要的其实是，Java 的工具非常成熟和迅捷。很难想象如果缺少了 Eclipse 我还能在三个月内做出像 PySonar 那样的东西。而现在我只用了一个月就做出了 RubySonar，其中很大的功劳在于 IntelliJ。这些 IDE 的跳转功能，让我可以在代码中自由穿梭。而它们的 refactor 功能，让我不必再为变量的命名而烦恼，因为只要临时起个不重复的名字就行，以后改起来小菜一碟。另外我还经常使用这些 IDE 里面的 debugger，利用它们我可以很方便的找到 bug 的起因。PySonar2 在有一段时间变得很慢，看不出是哪里出了问题。最后我下载了一个 JProfiler 试用版，很快就发现了问题的所在。如果这问题出现在 Scheme 代码里面，恐怕就要费很多功夫才能找到，因为 Scheme 没有像 JProfiler 那样的工具。</p>

<p>但这并不等于说学习 Scheme 是没有用处的。恰恰相反，Scheme 的知识在任何时候都是非常有用的。一个只学过 Java 的程序员基本上是不可能写出我那样的 Java 代码的。虽然那看起来是 Java，但是其实 Scheme 的灵魂已经融入到其中了。我从 Scheme 学到的知识不但让我知道 Java 可以怎么用，而且让我知道 Java 本身是如何被造出来的。我知道 Java 哪些地方是好的，哪些地方是不好的，从而能够择其善而避其不善。我的代码没有用任何的“Java 设计模式”，也没有转弯抹角的重载。</p>

<p>其实我有空的时候在设计和实现自己的语言（由于缺乏想象力，暂命名为 Yin），它的实现语言也在最近换成了 Java。Yin 的语法接近于 Scheme，好像理所当然应该用 Scheme 或者 Racket 来实现。有些人可能已经看到了我 GitHub 上面的第一个 prototype 实现（项目已经进入私密状态）用的是 Typed Racket。Racket 在很大程度上是比 Java 好的语言，然而它却有一个让我非常恼火的问题，以至于最后我怀疑自己能否用它顺利实现自己的语言。</p>

<p>这个问题就是，当运行出现错误的时候，Racket 不告诉我出错代码的具体行号，甚至出错的原因都不说清楚。我经常看到这样一些出错信息：</p>

<pre><code>“函数调用参数个数错误”
“变量 a 没有定义，位于 loop 处”
</code></pre>

<p>只说是函数调用，函数叫什么名字不说。只说是 loop，文件里那么多 loop，到底是哪一个不知道。出错信息里面往往有很多别的垃圾信息，把你指向 Racket 系统里面的某一个文件。有时候把代码拷贝进 DrRacket 才能找到位置，可是很多时候甚至 DrRacket 都不行。每当遇到这些就让我思路被打断很长时间，导致代码质量的下降。</p>

<p>其它的 Scheme 实现也有类似的问题，像 Petite Chez 这样的就更加严重，只有商业版的 Chez Scheme 会好一些，所以这里不只是小小的批评一下。这种对工具设计的不在意心理，在 Lisp 和 Scheme 等函数式语言的社区里非常普遍。每当有人抱怨它们出错信息混乱，没有 debugger，没有基本的静态检查，铁杆 Schemer 们就会鄙视你说：“Aziz 说得好，我从来不 debug，因为我从来不写 bug。”“函数式语言编程跟普通语言不一样。你要先把小块的代码调试好了，问题都找到了，再组合起来。”“当程序有问题却找不到在哪里的时候，说明我思路混乱，我就把它重写一遍……”我很无语，天才就是这样被传说出来的 :)</p>

<p>除了由于高傲，Scheme 不提供出错位置的另外一个重要原因，其实是因为它的宏系统。由于 Scheme 的核心非常小，被设计为可以扩展成各种不同的语言，所以绝大部分的代码其实是由宏展开而成的。而由于 Scheme 的宏可以包含非常复杂的代码变换（比 C 语言的宏要强大许多），如果被展开的代码出了问题，是很难回溯找到程序员自己写的那块代码的。即使找到了也很难说清楚那块代码本来是什么东西，因为编译器看到的只是经过宏展开后的代码。如果实现者为了图简单没有把原来的位置信息存起来，那就完全没有办法找到了。这问题有点像有些 C++ 编译器给模板代码的出错信息。</p>

<p>所以出现这样的问题，不仅仅是语言设计者的心态问题，而且是语言自己的设计问题。我觉得 Lisp 的宏系统其实是一个多余的东西，带来的麻烦多于好处。一个语言应该是拿来用的，而不是拿来扩展的。如果连最基本的报错信息都因此不能准确定位，扩展能力再强又有什么意义呢？所以强调一个语言可以扩展甚至变成另外一种语言，其实是过度抽象。一个设计良好的语言应该基本上不需要宏系统，所以 Yin 语言的语法虽然像 Lisp，但我不会提供任何宏的能力。而且由于以上的经历，Yin 语言从一开头就为方便工具的设计做出了努力。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>学术腐败是历史的必然</h2>

    <p>今天想分析一下世界范围内的学术腐败。</p>

<p>我曾经和所有对学术界抱有幻想的人一样，希望有机会发挥自己的才华，过上有智慧的生活。直到最后一个希望破灭之后，我开始分析其中的原因。其结果是非常有趣的，因为我得出的结论是：学术腐败是历史的必然，是人类历史的发展趋势和技术进步的结果。</p>

<p>为什么这么说呢？</p>

<ul>
<li>首先想想在资本主义社会里人靠什么过活？钱</li>
<li>一般人怎么得到钱？工作</li>
<li>谁是人最大的工作竞争对手？机器，电脑，互联网，机器人……</li>
<li>自己的工作被机器取代了怎么办？寻找机器干不了的工作！</li>
<li>什么是机器仍然干不了，而且不久的将来也干不了的工作？搞研究！</li>
<li>搞研究是为了什么？制造更高效更智能的机器！</li>
</ul>


<p>然后你就明白了，这是一个让人类越来越痛苦的怪圈。越来越多的人涌向大学，涌向研究生院，涌向教职岗位，也就是这个原因。他们试图依靠更高的文凭来提高自己在工作上的竞争力，让自己摆脱由于技术进步带来的失业和无家可归的命运。本来貌似情有可原，然而久而久之，之前的这些“可怜人”爬上高位，致使更多的人卷入其中，就导致了世界性的学术腐败现象。记得吸血鬼的故事吗？每一个吸血鬼最开头都是受害者。我们同情那个受害者，然而他一旦变成了吸血鬼之后，就不再值得同情，因为他原来的灵魂已经不在了。</p>

<p>并不是每个人都有足够的好奇心，良好的态度和卓越的聪明才智来完成高精尖的研究的。有些人本来就只适合（或者只愿意）做一些简单劳动的，这些人本来应该受到尊重，他们应该过上安稳的生活。而我们的社会用机器代替了他们的工作岗位，却又不给他们耐以生存的资源，所以他们迫于生活压力，只好硬着头皮去“充电”。他们进了大学，甚至进了研究生院攻读 PhD。他们其实对研究根本不感兴趣，他们在那里完全是为了混口饭吃。知之者不如好之者，好之者不如乐之者。硬碰硬的智力较量他们是敌不过真正爱好研究的人的，所以他们就开始耍一些把戏。</p>

<p>有“志”者事竟成。制度有漏洞，人性有弱点。那么多的人需要高学位，这道防线岂有不破之理？所以呢，你就看到各种勾兑论文，新瓶装老酒，反正以把你搞糊涂混毕业为目标。这就是为什么有些研究课题几句话就可以说清楚，有些人却花了几十年来写各种论文。你要说他们抄袭那又不是抄袭，又没有违法，貌似一切都正大光明，可就是一点用都没有。</p>

<p>最开头教职岗位还比较好找，所以这批人就跟真正优秀的研究者一起，升到了终身教授的职位。可是他们的本性是不会改的，他们对研究不感兴趣，只是想混口饭吃，所以他们就给同类的，以混饭吃为目的的人大开绿灯。为了提高自己的学术地位，尽管知道是扯淡还是让很多人写点论文混毕业。而这些人也极力的吹捧他们，本来没啥意义的研究课题也要说成是有重大意义的。因为真正优秀的研究者的良心，学术界就展开了许多的政治斗争。然而真正的学者搞政治怎么可能是混混的对手，所以不是败下阵来就是看到别人败得很惨就明哲保身了。</p>

<p>早期的时候这一招是比较有效的，很多人找到了教职岗位。可是终身教授的铁饭碗岂是那么容易得到的？它们的数目显然是有限的，而“终身教授”意味着这些人直到寿终正寝都不可能被 fire 掉。通过简单的“非抢占线程调度算法”，你会发现这种职位很快就会饱和，产生瓶颈。如果教授职位饱和了，而你博士毕业要找工作怎么办？等吧，等到有人死了你就有机会了。这就是为什么那么多人拼了六七年的 PhD 之后还要去做 postdoc。有些人在好几个学校做好几年 postdoc 才有机会成为助理教授（Assistant Professor）。</p>

<p>不要高兴得太早。助理教授又是一遭漫长的旅途，一般为期七年左右。这个过程不但是用来考验你是否能胜任终身教授职位的“炼钢炉”，而且是学术界这台机器的上的一个“等待队列”。两三年的 postdoc，加上七年的助理教授，总该有终身教授归西，腾出位置来了吧？可惜的是由于一些肤浅的评价标准，而且里面的渣滓大大的多于优秀的钢材，这个炼钢炉淘掉的经常不是渣滓，而是优秀的钢材。上面讲到的那些混饭吃的人当然是继续耍各种把戏，钻制度的空子，拍正教授的马屁，压榨研究生，甚至压榨跟自己做毕业设计的本科生和硕士生。其唯一的目的是攒够足够的论文，拉拢足够的地位较高者，以支持自己成为终身教授。</p>

<p>当然，随着终身教授职位越来越饱和，这种现象就愈演愈烈。以至于你几乎每次试图跟助理教授合作搞研究都感觉到两个字：贱！Push！有时候你想人家也没有办法啊，都是出来混的。人家可不会承认这一点。总是要举着贞节牌坊，打着一些“高尚”的目标作为幌子。只有跟他们合作的学生才知道里面的底细，但为了自己的饭碗，学生们当然不会告诉你这里面的潜规则。</p>

<p>助理教授以及很多正教授都爱玩一招类似计算机里的“广度优先搜索算法”的研究策略，只不过他们用来执行这些搜索的不是机器，而是人。所以我们暂且把这叫做“人肉广度优先搜索算法”。它的工作原理是这样：现在有 A, B, C 三个课题，都是比较扯淡的，但即便如此其中也最多只有一个发得了论文，但我不知道是哪一个。我就找三个 PhD 来分别进行这三个课题。其中两个人是很可能失败的，但我不告诉他们。我把那三个课题都说成是非常有前途的，伟大的课题，鼓舞着学生们努力向前冲。到时候只要有一个人做出好东西，当然我的名字就在那 paper 上面，而且还是作为 PI（Principal Investigator）。另外那两个失败的家伙，就只能怪他们自己不努力，或者悟性不强喽。我尽量避免让他们互通信息或者合作，因为如果他们做同样的题目，就会失去“广度”和发 paper 的总体概率。我只关心总体的 paper 数，因为不管谁发了 paper 都算我一份，没有人会关心我手里 PhD 的毕业率。而且到时候几个人写差不多的题目，争锋斗角，更加麻烦。这就是为什么大部分助理教授对于 PhD 学生都是“求贤若渴”的样子，随时不忘为自己的“宏伟课题”打广告。遇到这种助理教授你需要特别小心，因为你很可能会被作为他的人肉搜索算法的其中一个“处理器”，最后发现自己搜索的是死路一条。</p>

<p>虽然如此，助理教授仍然是非常辛苦的工作，它往往意味着低廉的工资，昼夜的工作，没有周末可言，工作和生活不分。不但要争取研究经费，还要做研究，指导（操纵）自己的研究生，要教课，还要发论文。学生是最难控制的一种东西，当着他们的面要说空话谎话，他们质疑的时候还要努力“疏导”…… 容易吗我！还有些人结了婚，生了小孩，那就更麻烦了。学校根本不以你的教学质量作为评价标准，所以助理教授上课一般都比较水，管你学得怎么样呢，反正我完成了任务。可是助理教授在七年之后能够拿到正教授的机会有多少呢？呵呵。恐怕比七年之痒之后没有离婚的机会还少吧。</p>

<p>需要指出的是，学术腐败在计算机科学等专业貌似更加厉害一些。一方面是由于计算机比较热门，机会相对较多，还有工业界作为退路。另一方面是因为物理等“硬科学”经过几百年的发展已经非常成熟，可以造成对地球人有意义的理论突破的机会已经很少了。科学都需要经过实验检验，而且论文把关比较严，所以物理等专业的 PhD 非常不容易混毕业，毕业了也不容易找到工作。计算机科学虽然名字里面有“科学”二字，其实根本不是科学，倒有点像艺术或者数学。不是科学没关系，艺术和数学还是很重要的，但它们的从业者比较容易扯淡也没人看得出来，只要随便给自己的理论起个像“后现代艺术”之类的名字就可以了。现在的计算机科学博士论文里的创新程度，基本相当于有些本科生的“毕业设计”，只不过写的让人更头痛一些。这就是为什么大量的不合格研究者混进了计算机等专业。如果你要混饭吃，我建议你去计算机系。如果你想追求自己的兴趣，那就随你的便了。</p>

<p>这就是我对于整个世界学术界的发展趋势的分析了。简言之就是，技术和生产力的高度发展，导致了与资本主义资源分配机制的冲突，以至于大量不适合搞学术的人由于生活没有保障，进行滥竽充数，最终导致学术腐败现象在全世界蔓延。资本主义就像是一个内存分配和处理器调度没做好的操作系统，有些进程占用太多内存和 CPU，却没能有效利用，导致其他进程“饿死”。除非社会的资源分配机制得到改善，否则学术腐败不可能好转，只会恶化。</p>

<p>不要以为所谓的“世界一流大学”里的情况就会好一些，因为没有人可以逃脱社会发展的规律。世界一流大学我见识得多了，本质都一样。而且由于很多人想进去，头破血流的机会还多一些。从那里面出来的人往往都有一种神经症，什么事都跟别人比想看看谁厉害，谁“优秀”，娱乐活动都不例外。以至于你怀疑他们是否知道自己为什么活着。</p>

<p>中国人太多，而且虽然口头上说是什么“有中国特色的稀里糊涂主义”，其实实行的是比资本主义还要不合理的分配制度，社会的资源越来越集中到极少数人手里或者被浪费掉，导致极度的贫富分化。再加上自古以来的科举制度和“书中自有……”的误导，绝大多数人涌向大学，涌向研究生院。所以学术腐败虽然是世界范围的现象，但在中国就更加厉害一些。</p>

<p>关于这种“生产力”和“社会生产关系”的冲突，我们从小上政治课就背过了，不是吗？虽然政治课本大部分是扯淡的教条，但极少数几条不是中国人又不是俄国人发明的理论还真是管用的。死记硬背的东西人是永远不会理解的，只有切合实际才会发现，某些德国大胡子说的其实是真话，是科学道理。</p>

<p>这些都是我们个人没有力量改变的事情。那么这篇文章有什么用呢？</p>

<p>首先，有些知识是有指导意义的，知道了总比不知道的好。知道了学术界的游戏规则有利于我们玩转它，利用它，却避免它的弊端。比如，我早就知道了学术界的鬼把戏，所以我根本没有为成为它的一员做很多努力。从进入 IU 以后我就不在乎自己的考试成绩和论文发表，因为我知道除了学术界，几乎没有人关心这些。我知道有些领域整个都是扯淡的，所以得个高分不但对我一点用都没有，反而浪费了我的时间。所以除了自己喜欢的课程不拿A+都没办法以外，其它的都是按照能拿到学分的最低标准进行。我利用学校的资源学到了自己需要的东西，却没有为一些扯淡的论文之类花很多时间。每次做教授的 RA 都会发现是在做扯淡空洞的话题，所以我后来选择了做 TA。干这种“体力活”避免了脑力的冲突，自己才有机会去研究自己感兴趣，有价值的东西。由于我知道助理教授们的生存现状，心理以及动机，我就比不知道的人做出更好的决定。当同学们怀着崇尚的心情，跟着一些吹牛皮的助理教授做一些没有希望的研究的时候，我自己的研究早就超过了他们很多年。</p>

<p>另外，这篇文章对于广大学术界人士也有一定意义。承认了自己在扯淡总是比举着高尚道德的牌子更加以德服人一些。我鼓励广大正在挣扎中的 PhD 和助理教授们发扬自嘲精神，勇于承认自己的现实和弱点，承认自己其实是不得已为了混饭吃，大家都是混饭吃的。有同情心才会有动力，同学们如果知道了你是在混口饭吃，反而会更加理解你的处境，停止质疑你的做法，进而帮助你继续混下去。</p>

<p>最后，知道事实的人多了，世界自然而然就会改变。很多人进学术界的原因是为了混饭吃，而当社会更多的了解到学术界的这一真相之后，“名校博士”这种东西就会逐渐贬值，失去它原来的光环。人们就会以平常心来看待，最后学术界就不再能吸引那些混饭吃的人，而真正喜欢研究的人也就能自得其所。人们也可以采取甘地的“非暴力不合作”精神，避免成为学术腐败的一部分，就像你知道某个街区经常有吸血鬼出没就不要去一样。这样吸血鬼们找不到食物，邪恶的势力就会逐渐萎缩。知道事实的人们还可以互相鼓舞，发扬正气。腐败的组织慢慢的就会失去人们的支持，走向穷途末路，或者改邪归正。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>丘奇和图灵</h2>

    <table><tr><td><img src="http://www.yinwang.org/images/Alonzo_Church.jpg" height="300"></td><td>&emsp;</td><td><img src="http://www.yinwang.org/images/Alan_Turing.jpg" height="300"></td></tr><tr></tr></table>


<p>丘奇（Alonzo Church）和图灵（Alan Turing）是两位对计算机科学具有最大影响力的人物，然而他们却具有非常对立的观点和相差很多的名气。在我长达16年的计算机科学生涯中，总是感觉到自己的思想反反复复的徘徊于这两个“阵营”之间。丘奇代表了“逻辑”和“语言”，而图灵代表着“物理”和“机器”。在前面的8年中，我对丘奇一无所知，而在后面的8年中，我却很少再听到图灵的名字。他们的观点谁对谁错，是一个无法回答的问题。完全投靠丘奇，或者完全投靠图灵，貌似都是错误的做法。这是一种非常难说清楚的，矛盾的感觉，但是今天我试图把自己的感悟简要的介绍一下。</p>

<h3>丘奇与图灵之争</h3>

<p>想必世界上所有的计算机学生都知道图灵的大名和事迹，因为美国计算机器学会（ACM）每年都会颁发“图灵奖”，它被誉为计算机科学的最高荣誉。大部分的计算机学生都会在某门课程（比如“计算理论”）学习“图灵机”的原理。然而，有多少人知道丘奇是什么人，他做出了什么贡献，他与图灵是什么样的关系呢？我想恐怕不到一半的人吧。</p>

<p>如果你查一下<a href="http://www.genealogy.math.ndsu.nodak.edu/id.php?id=8014">数学家谱图</a>，就会发现丘奇其实是图灵的博士导师。然而从 Andrew Hodges 所著的《<a href="http://www.turing.org.uk/bio/part3.html">图灵传</a>》，你却可以看到图灵的心目中仿佛并没有这个导师，仿佛自己的“全新发明”应得的名气，被丘奇抢走了一样（注意作者的用词：robbed）。事实到底是怎样的，恐怕谁也说不清楚。我只能说，貌似计算机科学从诞生之日开始就充满了各种“宗教斗争”。</p>

<p>虽然现在图灵更加有名，然而在现实的程序设计中，却是丘奇的理论在起着绝大部分的作用。据我的经验，丘奇的理论让很多事情变得简单，而图灵的机器却过度的复杂。丘奇所发明的 lambda calculus 以及后续的工作，是几乎一切程序语言的理论基础。而根据老一辈的计算机工程师们的描述，最早的计算机构架也没有受到图灵的启发，那是一些电机工程师完全独立的工作。然而有趣的是，继承了丘奇衣钵的计算机科学家们拿到的那个大奖，仍然被叫做“图灵奖”。我粗略的算了一下，在迄今所有的图灵奖之中，程序语言的研究者占了近三分之一。</p>

<h3>从图灵机到 lambda calculus</h3>

<p>图灵机永远的停留在了理论的领域，绝大多数被用在“计算理论”（Theory of Computation）中。计算理论其实包括两个主要概念：“可计算性理论”（computability）和“复杂度理论”(complexity）。这两个概念在通常的计算理论书籍（比如 Sipser 的经典教材）里，都是用图灵机来叙述的。在学习计算理论的时候，绝大多数的计算机学生恐怕都会为图灵机头痛好一阵子。</p>

<p>然而在做了研究生“计算理论”课程一个学期的 TA 之后我却发现，其实几乎所有计算理论的原理，都可以用 lambda calculus，或者程序语言和解释器的原理来描述。所谓“通用图灵机”（Universal Turing Machine），其实就是一个可以解释自己的解释器，叫做“元解释器”（meta-circular interpreter）。在 Dan Friedman 的 B621 程序语言理论课程中，我最后的项目就是一个 <a href="https://github.com/yinwang0/old-toys/blob/master/meta-interp.ss">meta-circular interpreter</a>。这个解释器能够完全的解释它自己，而且可以任意的嵌套（也就是说用它自己来解释它自己，再来解释它自己……）。然而我的“元解释器”却是基于 lambda calculus 的，所以我后来发现了一种方法，可以完全的用 lambda calculus 来解释计算理论里面几乎所有的定理。</p>

<p>我为这个发现写了两篇博文：《<a href="http://yinwang0.wordpress.com/2012/03/22/reducibility">A Reformulation of Reducibility</a>》和《<a href="http://yinwang0.wordpress.com/2012/10/25/halting">Undecidability Proof of Halting Problem without Diagonalization</a>》。我把 Sipser 的<a href="http://www.amazon.com/dp/113318779X">计算理论课本</a>里面的几乎整个一章的证明都用我自己的这种方式改写了一遍，然后讲给上课的学生。因为这种表示方法比起通常的“图灵机+自然语言”的方式简单和精确，所以收到了相当好的效果，好些学生对我说有一种恍然大悟的感觉。</p>

<p>我把这一发现告诉了我当时的导师 Amr Sabry。他笑了，说这个他早就知道了。他推荐我去看一本书，叫做《<a href="http://www.diku.dk/~neil/Comp2book.html">Computability and Complexity from a Programming Perspective</a>》，作者是大名鼎鼎的 Neil Jones (他也是“<a href="http://www.itu.dk/~sestoft/pebook/pebook.html">Partial Evaluation</a>”这一重要概念的提出者）。这本书不是用图灵机，而是一种近似于 Pascal，却又带有 lambda calculus  的一些特征的语言（叫做 “WHILE 语言”）来描述计算理论。用这种语言，Jones 不但轻松的证明了所有经典的计算理论定理，而且能够证明一些使用图灵机不能证明的定理。</p>

<p>我曾经一直不明白，为什么可以如此简单的解释清楚的事情，计算理论需要使用图灵机，而且叙述也非常的繁复和含糊。由于这些证明都出于资深的计算理论家们之手，让我不得不怀疑自己的想法里面是不是缺了点什么。可是在看到了 Jones 教授的这本书之后，我倍感欣慰。原来一切本来就是这么的简单！</p>

<p>后来从 CMU 的教授 Robert Harper 的一篇博文《<a href="http://existentialtype.wordpress.com/2011/03/16/languages-and-machines">Languages and Machines</a>》中，我也发现 Harper 跟我具有类似的观点，甚至更加极端一些。他强烈的支持使用 lambda calculus，反对图灵机和其他一切机器作为计算理论的基础。</p>

<h3>从 lambda calculus 到电子线路</h3>

<p>当我在 2012 年的 POPL 第一次见到 Neil Jones 的时候，他跟我解释了许多的问题。当我问到他这本书的时候，他对我说：“我不推荐我的书给你，因为大部分的人都觉得 lambda calculus 难以理解。”Lambda calculus 难以理解？我怎么不觉得呢？我觉得图灵机麻烦多了。然后我才发现，由于经过了这么多年的研究之后，自己对 lambda calculus 的理解程度已经到了深入骨髓的地步，所以我已经全然不知新手对它是什么样的感觉。原来“简单”这个词，在具有不同经历的人头脑里，有着完全不同的含义。</p>

<p>所以其实 Jones 教授说的没错，lambda calculus 也许对于大部分人来说不合适，因为对于它没有一个好的入门指南。Lambda calculus 出自逻辑学家之手，而逻辑学家们最在行的，就是把很简单的“程序”用天书一样的公式表示出来。这难怪老一辈的逻辑学家们，因为他们创造那些概念的时候，计算机还不存在。但是如果现在还用那一堆符号，恐怕就有点落伍了。大部分人在看到 beta-reduction, alpha-conversion, eta-conversion, ... 这大堆的公式的时候，就已经头痛难忍了，怎么还有可能利用它来理解计算理论呢？</p>

<p>其实那一堆符号所表示的东西，终究超越不了现实里的物体和变化，最多不过再幻想一下“多种未来”或者“时间机器”。有了计算机之后，这些符号公式，其实都可以用数据结构和程序语言来表示。所以 lambda calculus 在我的头脑里真的很简单。每一个 lambda 其实就像是一个电路模块。它从电线端子得到输入，然后输出一个结果。你把那些电线叫什么名字根本不重要，重要的是同一根电线的名字必须“一致”，这就是所谓的“alpha-conversion”的原理…… 不在这里多说了，如果你想深入的了解我心目中的 lambda calculus，也许可以看看我的另一篇博文《<a href="http://www.yinwang.org/blog-cn/2012/08/01/interpreter">怎样写一个解释器</a>》，看看这个关于类型推导的<a href="http://www.tudou.com/programs/view/GU9GtDuWSMk">幻灯片</a>的开头，或者进一步，看看如何推导出 <a href="http://yinwang0.wordpress.com/2012/04/09/reinvent-y">Y combinator</a>，或者看看《<a href="http://yinwang0.wordpress.com/2012/09/16/what-is-a-program">What is a program?</a>》。你也可以看看 Matthias Felleisen 和 Matthew Flatt 的《<a href="http://www.cs.utah.edu/~mflatt/past-courses/cs7520/public_html/s06/notes.pdf">Programming Languages and Lambda Calculi</a>》。</p>

<p>所以，也许你看到了在我的头脑里面并存着丘奇和图灵的影子。我觉得丘奇的 lambda calculus 是比图灵机简单而强大的描述工具，然而我却又感染到了图灵对于“物理”和“机器”的执着。我觉得逻辑学家们对 lambda calculus 的解释过于复杂，而通过把它理解为物理的“电路元件”，让我对 lambda calculus 做出了更加简单的解释，把它与“现实世界”联系在了一起。</p>

<p><img src="http://www.yinwang.org/images/lambda-inside.png" width="30%"></p>

<p>所以到最后，丘奇和图灵这两种看似矛盾的思想，在我的脑海里得到了和谐的统一。这些精髓的思想帮助我解决了许多的问题。感谢你们，计算机科学的两位鼻祖。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>Yoda 表示法错在哪里</h2>

    <p>在上一篇<a href="http://www.yinwang.org/blog-cn/2013/04/14/terminology/">博文</a>里，我提到了 Yoda 表示法。</p>

<h3>Yoda Notation（Yoda 表示法）</h3>

<p><img src="http://www.yinwang.org/images/yoda-notation.jpeg" alt=""></p>

<p>它的含义是，在 C/C++ 里面使用这样的表达式顺序：</p>

<pre><code>if ("blue" == theSky) ...
</code></pre>

<p>这是为了避免意外的写成：</p>

<pre><code>if (theSky = "blue") ...
</code></pre>

<p>“Yoda 表示法”的名字来源于《星球大战》的 Yoda 大师。他说话的单词顺序相当奇特，比如：“Backwards it is, yes!”</p>

<h3>一般认为</h3>

<blockquote><p>使用这个表示法是为了“变通”（workaround） C/C++ 的一个设计抉择：使用 <code>=</code> 来表示赋值，而使用 <code>==</code> 来表示比较。这个设计充分的展现了“先辈的罪”（Sins of our Forefathers）这一词汇的精髓。</p></blockquote>

<h3>我认为</h3>

<blockquote><p>使用 <code>=</code> 来表示赋值其实并不是真正的错误所在。真正的错误在于 C/C++ 的赋值语句不应该返回一个值。</p></blockquote>

<p>也就是说，<code>theSky = "blue"</code> 的所有功能应该只是“赋值”这种“副作用”，副作用不应该具有“值”。即使你牵强附会说它有一个值，它的“值”也应该是 <code>void</code>（随之这个 <code>void</code> 会被类型检查所拒绝，因为它不是 <code>if</code> 所期望的 <code>bool</code>）。所以，一个良好的语言不应该允许你把 <code>theSky = "blue"</code> 放进 <code>if (...)</code> 的“条件”里面。如果你真的要赋值又要判断，它会迫使你把这拆开成两行：</p>

<pre><code>theSky = "blue";
if (theSky) ...
</code></pre>

<p>更近一步。<code>if (theSky)</code> 这个写法其实也是一个先辈的罪。<code>theSky</code> 的类型是 <code>string</code>，它不应该可以直接被作为 <code>bool</code> 使用。<code>if (...)</code> 的条件应该必须是一个 <code>bool</code>。 所以这里其实应该写成：</p>

<pre><code>theSky = "blue";
if (theSky != NULL) ...
</code></pre>

<p>因为赋值语句永远不可能出现在条件的位置，所以之前的那种错误，即使我们使用 <code>=</code> 作为赋值操作符，也完全不可能出现。这样我们也就完全没必要用 Yoda 表示法了。</p>

<p>相反，如果我们只是把 <code>=</code> 换成像 Pascal 的 <code>:=</code> 这样的赋值操作符，而保留其它的“特性”（赋值操作会返回值）的话，我们其实还是会遇到同样的问题：</p>

<pre><code>if (theSky := "blue") ...
</code></pre>

<p>这里假设你想打 <code>=</code>，却不小心打成了 <code>:=</code>。机会虽然小，但是仍然有可能。而我推荐的解决方案，会让你故意想犯错误都不可能，编译器会拒绝接受你的程序。</p>

<p>所以你看到了，问题的根源其实不在于赋值操作的名字，而是有更深的原因。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>一种新的操作系统设计</h2>

    <p>我一直在试图利用程序语言的设计原理，设计一种超越“Unix 哲学”的操作系统。这里是我的设想：</p>

<ul>
<li><p>这种系统里面的程序间通信不使用无结构的字符串，而是使用带有类型和结构的数据。在这样的系统里面，Unix 和其它类似操作系统（比如 Windows）里的所谓“应用程序”的概念基本上完全消失。系统由一个个很小的“函数”组成，每个函数都可以调用另外一个函数，通过参数传递数据。每个函数都可以手动或者自动并发执行。用现在的系统术语打个比方，这就像是所有代码都是“库”代码，而不存在独立的“可执行文件”。</p></li>
<li><p>由于参数是数据结构而不是字符串，这避免了程序间通信繁琐的编码和解码过程。使得“进程间通信”变得轻而易举。任何函数都可以调用另一个函数来处理特定类型的数据，这使得像 “OLE 嵌入”这样的机制变得极其简单。</p></li>
<li><p>所有函数由同一种先进的高级程序语言写成，所以函数间的调用完全不需要“翻译”。不存在 SQL injection 之类由于把程序当成字符串而产生的错误。</p></li>
<li><p>由于这种语言不允许应用程序使用“指针运算”，应用程序不可能产生 segfault 一类的错误。为了防止不良用户手动在机器码里面加入指针运算，系统的执行的代码不是完全的机器代码，而必须通过进一步的验证和转换之后才会被硬件执行。这有点像 JVM，但它直接运行在硬件之上，所以必须有一些 JVM 没有的功能，比如把内存里的数据结构自动换出到硬盘上，需要的时候再换进内存。</p></li>
<li><p>由于没有指针运算，系统可以直接使用“实地址”模式进行内存管理，从而不再需要现代处理器提供的内存映射机制以及 TLB。内存的管理粒度是数据结构，而不是页面。这使得内存访问和管理效率大幅提高，而且简化了处理器的设计。据 Kent Dybvig 的经验，这样的系统的内存使用效率要比 Unix 类的系统高一个数量级。</p></li>
<li><p>系统使用与应用程序相同的高级语言写成，至于“系统调用”，不过是调用另外一个函数。由于只有这些“系统驱动函数”才有对设备的“引用”，又因为系统没有指针运算，所以用户函数不可能绕过系统函数而非法访问硬件。</p></li>
<li><p>系统没有 Unix 式的“命令行”，它的“shell”其实就是这种高级语言的 REPL。用户可以在终端用可视化的结构编辑方式输入各种函数调用，从而启动进程的运行。所以你不需要像 Unix 一样另外设计一种毛病语言来“粘接”应用程序。</p></li>
<li><p>所有的数据都作为“结构”，保存在一个分布式的数据共享空间。同样的那个系统语言可以被轻松地发送到远程机器，调用远程机器上的库代码，执行任意复杂的查询索引等动作，取回结果。这种方式可以高效的完成数据库的功能，然而却比数据库简单很多。所谓的“查询语言”（比如 SQL，Datalog，Gremlin，Cypher）其实是多此一举，它们远远不如普通的程序语言强大。说是可以让用户“不需要编程，只提出问题”，然而它们所谓的“优化”是非常局限甚至不可能实现的，带来的麻烦远比直接编程还要多。逻辑式编程语言（比如 Prolog）其实跟 SQL 是一样的问题，一旦遇到复杂点的查询就效率低下。所以系统不使用关系式数据库，不需要 SQL，不需要 NoSQL，不需要 Datalog。</p></li>
<li><p>由于数据全都是结构化的，所以没有普通操作系统的无结构“文件系统”。数据结构可能通过路径来访问，然而路径不是一个字符串或者字符串模式。系统不使用正则表达式，而是一种类似 NFA 的数据结构，对它们的拆分和组合操作不会出现像字符串那样的问题，比如把 /a/b/ 和 /c/d 串接在一起就变成错误的 /a/b//c/d。</p></li>
<li><p>所有的数据在合适的时候被自动同步到磁盘，并且进行容错处理，所以即使在机器掉电的情况，绝大部分的数据和进程能够在电源恢复后继续运行。</p></li>
<li><p>程序员和用户几乎完全不需要知道“数据库”或者“文件系统”的存在。程序假设自己拥有无穷大的空间，可以任意的构造数据。根据硬件的能力，一些手动的存盘操作也可能是有必要的。</p></li>
<li><p>为了减少数据的移动，系统或者用户可以根据数据的位置，选择： 1）迁移数据，或者 2）迁移处理数据的“进程”。程序员不需要使用 MapReduce，Hadoop 等就能进行大规模并行计算，然而表达能力却比它们强大很多，因为它们全都使用同一种程序语言写成。</p></li>
</ul>


<p>我曾经以为我是第一个想到这个做法的人。可是调查之后发现，很多人早就已经做出了类似的系统。Lisp Machine 似乎是其中最接近的一个。<a href="http://www.yinwang.org/blog-cn/2013/03/07/oberon/">Oberon</a> 是另外一个。IBM System/38 是类似系统里面最老的一个。最近一些年出现的还有微软的 <a href="http://research.microsoft.com/en-us/projects/Singularity">Singularity</a>，另外还有人试图把 JVM 和 Erlang VM 直接放到硬件上执行。</p>

<p>所以这篇文章的标题其实是错的，这不是一种“新的操作系统设计”。它看起来是新的，只不过因为我们现在用的操作系统忘记了它们本该是什么样子。我也不该说它“超越了 Unix 哲学”，而应该说，所谓的 Unix 哲学其实是历史的倒退。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>Markdown 的一些问题</h2>

    <p>把我之前的博文基本上转换成了 markdown 格式。我发现 markdown 虽然在编辑器里看起来比 HTML 清晰一些，但也有一些不足。</p>

<p>这些 markup 语言的格式都有点像我本科的时候给我爸做的一种“<a href="http://www.yinwang.org/blog-cn/2013/04/14/standard-exam-language">标准化试卷标记语言</a>”（因为他是中学英语老师）。当时我写了一个1000来行的 Perl 脚本，可以把这种简单的标记语言转换成美观的 LaTeX 格式文档，并且带有友好的 Tk 图形界面。现在回想起来，我那时候的设计就已经相当先进了。跟我的语言相比，这些 blog 用的 markup 语言真是小巫见大巫了，而且问题多多。有点跑题了，还是回头来看看 markdown 的问题吧。</p>

<ul>
<li><p>Markdown 实际上采用的是类似 Python 和 Haskell 的 layout 语法。</p>

<p>我已经在一篇<a href="http://en.yinwang.org/blog-en/2011/05/08/layout">英文博文</a>里提到了 layout 语法的多种问题。因为空格的数量决定了文档的结构，这种文档格式相当的“脆弱”。稍微少打一两个空格，就会出现不可预测的结果。这种现象在“itemize”内部的代码块最容易出现。因为每个 item 带来了缩进，所以内部的代码必须比 item 的缩进多4个空格，才能被排到正确的位置。比如我转换博文的时候多次出现以下的情况：</p>

<p><img src="http://www.yinwang.org/images/markdown-mistake.png" width="90%" style="border: 2px solid green;"></p>

<p>这里的问题是，代码里的第一行 <code>helloworld z = let x = 1</code> 因为缩进不够，被放到了代码块外面。但是为了准确的缩进所耗费的精力，其实比直接打 <code>&lt;pre&gt;</code> 这样的 tag 还要多。</p></li>
<li><p>特殊字符的选择不合理</p>

<p>markdown 对特殊字符的使用不大合理。我多次发现文档段落整段的变成斜体，就是因为原来的文档里出现了 <code>x*y</code> 这样的表达式。在程序员的世界里，“乘法”显然比“强调”更加频繁。把 * 用于标记“强调”，实际上把一个非常有用的字符用在了很不频繁的用途。</p></li>
<li><p>表达力相当有限</p>

<p>在很多细节上，markdown 并不能表达我想要的格式。比如它不能正确的插入断行 <code>&lt;br&gt;</code>。如果你有两块紧接在一起的代码，但你不想把它们连在一起，markdown 非要给你连在一起…… 于是我就发现自己加入了越来越多的 HTML。</p>

<p>这在图片的语法上就更加明显，markdown 引入了 <code>![alt](image url)</code> 这样的格式，其实比起 HTML 还要难看和不一致。比如现在它仍然无法表达图片的大小，这是相当重要的信息。所以我觉得 markdown 的语法已经显示出了它的弱点，如果它要表达更复杂的信息，就会变得比 HTML 还要难记，难看。所以对于图片，我觉得还不如直接用 HTML 的 <code>&lt;img&gt;</code> 。</p></li>
</ul>


<p>所以总的感觉是 markdown 引入了太多的“语法”，以至于稍微复杂一点的信息表达起来还不如 HTML 来的直接。现在就这样先凑合着吧。也许过段时间自己设计一个格式。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>谈程序的“通用性”</h2>

    <p>在现实的软件工程中，我经常发现这样的一种现象。本来用很简单的代码就可以解决的问题，却因为设计者过分的关注了“通用性”，“可维护性”和“可扩展性”，被搞得绕了几道弯，让人琢磨不透。</p>

<p>这些人的思维方式是这样的：“将来这段代码可能会被用到更多的场合，所以我现在就考虑到扩展问题。”于是乎，他们在代码中加入了各种各样的“框架结构”，目的是为了在将来有新的需要的时候，代码能够“不加修改”就被用到新的地方。</p>

<p>我并不否认“通用性”的价值，实际上我的某些程序通用性非常之强。可是很多人所谓的“通用性”，其实达到的是适得其反的效果。这种现象通常被称为“过度工程” (over-engineer)。关于过度工程，有一个有趣的故事：</p>

<p><a href="http://www.snopes.com/business/genius/spacepen.asp">http://www.snopes.com/business/genius/spacepen.asp</a></p>

<blockquote><p>传说 1960 年代美俄“太空竞赛”的时候，NASA 遇到一个严重的技术问题：宇航员需要一支可以在外太空的真空中写字的钢笔。最后 NASA 耗资150万美元研制出了这样的钢笔。可惜这种钢笔在市场上并不行销。</p>

<p>俄国人也遇到同样的问题。他们使用了铅笔。</p></blockquote>

<p>这个故事虽然是假的，但是却具有伊索寓言的威力。现在再来看我们的软件行业，你也许会发现：</p>

<ol>
<li><p>代码需要被“重用”的场合，实际上比你想象的要少</p>

<p>我发现很多人写程序的时候连“眼前特例”都没做好，就在开始“展望将来”。他们总是设想别人会重用这段代码。而实际上，由于他们的设计过于复杂，理解这设计所需的脑力开销已经高于从头开始的代价，所以大部分人其实根本不会去用他们的代码，自己重新写一个就是了。也有人到后来发现，之前写的那段代码，连自己都看不下去了，恨不得删了重来，就不要谈什么重用了。</p></li>
<li><p>修改代码所需要的工作实际上比你想象的要少</p>

<p>还有一种情况是，这些被设计来“共享”的代码，其实根本没有被用在很多的地方，所以即使你完全手动的修改它们也花不了很多时间。现在再加上 IDE 技术的发展和各种先进的 refactor 工具，批量的修改代码已经不是特别麻烦的事情。曾经需要在逻辑层面上进行的可维护性设计，现在有可能只需要在 IDE 里面点几下鼠标就轻松完成。所以在考虑设计一个框架之前，你应该同时考虑到这些因素。</p></li>
<li><p>“考虑”到了通用性，并不等于你就准确地“把握”住了通用性</p>

<p>很多人考虑到了通用性，却没有准确的看到，到底是哪一个部分将来可能需要修改，所以他们的设计经常抓不住关键。当有新的需要出现的时候，才发现原来设想的可能变化的部分，其实根本没有变，而原来以为不会变的地方却变了。</p>

<p>能够准确的预测将来的需要，能够从代码中抽象出真正通用的框架，是一件非常困难的事情。它不止需要有编程的能力，而且需要对真实世界里的事物有强大的观察能力。很多人设计出来的框架，其实只是照搬别人的经验，却不能适应实际的需要。在 Java 世界里的很多 design pattern，就是这些一知半解的人设计出来的。</p></li>
<li><p>初期设计的复杂性</p>

<p>如果在第一次的设计中就过早的考虑到将来，由此带来的多余的复杂性，有可能让初期的设计就出现问题。所以这种对于将来的变化的考虑，实际上帮了倒忙。本来如果专注于解决现在的问题，能够得到非常好的结果。但是由于“通用性”带来的复杂度，设计者的头脑每次都要多转几道弯，所以它无法设计出优雅的程序。</p></li>
<li><p>理解和维护框架性代码的开销</p>

<p>如果你设计了框架性的代码，每个程序员为了在这个框架下编写代码，都需要理解这种框架的构造，这带来了学习的开销。一旦发现这框架有设计问题，依赖于它的代码很有可能需要修改，这又带来了修改的开销。所以加入“通用性”之后，其实带来了更多的工作。这种开销能不能得到回报，依赖于以上的多种因素。</p></li>
</ol>


<p>所以在设计程序的时候，我们最好是先把手上的问题解决好。如果发现这段代码还可以被用在很多别的地方，到时候再把框架从中抽象出来也不迟。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>Scheme 编程环境的设置</h2>

    <p><img src="http://www.yinwang.org/images/paredit1.gif" width="80%"></p>

<p>介绍了这么久的 Scheme，却没有讲过如何配置一个高效的 Scheme 的编程环境。有些人开始学习 Scheme 的时候感觉无从下手，所以今天讲一下它的配置。</p>

<p>Scheme 的配置有很多种方式，我不想介绍太多东西，免得有人看花了眼，所以这里只介绍一下我自己的配置。我不大喜欢像 <a href="http://www.neilvandyke.org/quack">Quack</a> 一类的复杂的环境，因为它们经常有很多多余的功能，却缺少我想要的功能。一旦我想修改它们，又到处出问题。我的配置很简约，我用它写了几千行的超高难度的代码，翻来覆去的改，感觉效率非常高，也没有觉得缺少什么特别重要的东西。</p>

<p>现在我就一步一步的介绍我的配置。</p>

<h3>安装 Scheme</h3>

<p>世界上最好的 Scheme 实现是 Chez Scheme，但是它不免费也不开源。所以如果你不想破费，那就只好下载一个它的“免费版”，叫做 Petite Chez Scheme（petite 是法语里“小”的意思）。它可以在这里下载：</p>

<p><a href="http://scheme.com/download">http://scheme.com/download</a></p>

<p>这个页面挺长，上面都是正式版的 Chez Scheme，一点击就会叫你“联系销售人员”。要滚动到下面才能看见免费的版本。怎么安装我就不讲了，自己看说明应该很容易的。</p>

<p>Petite 是一个完善的，高效的实现，你可以把它当成解释器使用。这个解释器的速度非常之快，甚至比很多别的 Scheme 实现编译后的代码还要快。但是它有一个问题，就是它给出的出错信息太简约了，以至于连出错的函数名字都不告诉你。这样写大一点的程序就会比较痛苦了（虽然我还是用它写了2000多行的编译器代码）。</p>

<p>所以如果你想写稍微大点的东西，可以用 Racket。它可以在这里下载：</p>

<p><a href="http://racket-lang.org">http://racket-lang.org</a></p>

<p>安装应该很容易。Ubuntu 也自带了 Racket，所以可以直接让系统安装它。</p>

<h3>设置 ParEdit mode</h3>

<p>我编辑 Scheme 的时候都用 Emacs。我使用一个叫做 ParEdit mode 的插件。它可以让你“半结构化”式的编辑 Scheme 和其它的 Lisp 文件。开头你可能会有点不习惯，可是一旦习惯了，你就再也离不开它。</p>

<p>ParEdit mode 可以在这里下载：</p>

<p><a href="http://mumble.net/~campbell/emacs/paredit.el">http://mumble.net/~campbell/emacs/paredit.el</a></p>

<p>下载之后，把它放到一个目录里，比如 ~/.emacs.d，然后打开 ~/.emacs 配置文件，加入如下设置：</p>

<pre><code>(autoload 'paredit-mode "paredit"
  "Minor mode for pseudo-structurally editing Lisp code."
  t)
</code></pre>

<p>这样，只要你使用 M-x paredit-mode 就可以自动载入这个模式。具体的操作方式可以看它的说明（按 C-h m 查看“模式帮助”），我下面也会简单说一下。</p>

<h3>设置 scheme mode</h3>

<p>我一般就用系统自带的 Scheme 模式，叫 cmuscheme。但是为了方便，我自己写了几个函数，用于在执行 Scheme 代码的时候自动启动解释器，并且打开解释器窗口。你基本只需要把下面的代码拷贝到你的 .emacs 文件里就行：</p>

<pre><code>;;;;;;;;;;;;
;; Scheme 
;;;;;;;;;;;;

(require 'cmuscheme)
(setq scheme-program-name "racket")         ;; 如果用 Petite 就改成 "petite"


;; bypass the interactive question and start the default interpreter
(defun scheme-proc ()
  "Return the current Scheme process, starting one if necessary."
  (unless (and scheme-buffer
               (get-buffer scheme-buffer)
               (comint-check-proc scheme-buffer))
    (save-window-excursion
      (run-scheme scheme-program-name)))
  (or (scheme-get-process)
      (error "No current process. See variable `scheme-buffer'")))


(defun scheme-split-window ()
  (cond
   ((= 1 (count-windows))
    (delete-other-windows)
    (split-window-vertically (floor (* 0.68 (window-height))))
    (other-window 1)
    (switch-to-buffer "*scheme*")
    (other-window 1))
   ((not (find "*scheme*"
               (mapcar (lambda (w) (buffer-name (window-buffer w)))
                       (window-list))
               :test 'equal))
    (other-window 1)
    (switch-to-buffer "*scheme*")
    (other-window -1))))


(defun scheme-send-last-sexp-split-window ()
  (interactive)
  (scheme-split-window)
  (scheme-send-last-sexp))


(defun scheme-send-definition-split-window ()
  (interactive)
  (scheme-split-window)
  (scheme-send-definition))

(add-hook 'scheme-mode-hook
  (lambda ()
    (paredit-mode 1)
    (define-key scheme-mode-map (kbd "&lt;f5&gt;") 'scheme-send-last-sexp-split-window)
    (define-key scheme-mode-map (kbd "&lt;f6&gt;") 'scheme-send-definition-split-window)))
</code></pre>

<p>我的配置会在加载 Scheme 文件的时候自动载入 ParEdit mode，并且把 F5 键绑定到“执行前面的S表达式”。这样设置的目的是，我只要把光标移动到一个S表达式之后，然后用一根手指头按 F5，就可以执行程序。够懒吧。</p>

<h3>ParEdit mode 的简单使用方法</h3>

<p>ParEdit mode 是一个很特殊的模式。它起作用的时候，你不能直接修改括号。这样所有的括号都保持完整的匹配，不可能出现语法错误。但是这样有一个问题，如果你要把一块代码放进另一块代码，或者从里面拿出来，就不是很方便了。</p>

<p>为此，ParEdit mode 提供了几个非常高效的编辑方式。我平时只使用两个：</p>

<ol>
<li><p><code>C-right</code>: 也就是按住 Ctrl 再按右箭头。它的作用是让光标右边的括号，“吞掉”下一个S表达式。</p>

<p>比如，<code>(a b c) (d e)</code>。你把光标放在 <code>(a b c)</code> 里面，然后按 <code>C-right</code>。结果就是 <code>(a b c (d e))</code>。也就是把 <code>(d e)</code> 被整个“吞进”了 <code>(a b c)</code> 里面。</p></li>
<li><p><code>M-r</code>: 去掉外层代码。</p>

<p>这在你需要去掉外层的 let 等结构的时候非常有用。比如，如果你的代码看起来是这样：</p>

<pre><code>(let ([x 10])
  (* x 2))
</code></pre>

<p>当你把光标放在 <code>(* x 2)</code> 的最左边，然后按  <code>M-r</code>，结果就变成了</p>

<pre><code>(* x 2)
</code></pre>

<p>也就是把外面的 <code>(let ([x 10]) ...)</code> 给“掀掉”了。</p>

<p>其它的一些按键虽然也有用，不过我觉得这两个是最有用的，甚至不可缺少的。有些其他的自动匹配括号的模式，没有提供这种按键，所以用起来很别扭。</p></li>
</ol>


<h3>设置括号颜色</h3>

<p>很多人看见 Lisp 就怕了，就是因为它看起来括号太多。可是这样的语法，却是有很大的好处的（参考这篇博文《谈语法》）。如果你真的觉得括号碍眼，你可以稍微调整一下括号的颜色，比如淡灰色。这样括号看起来就没有那么显眼了。</p>

<p>你只需要下载这个 el，放到你的 .emacs.d:</p>

<p><a href="https://www.dropbox.com/s/v0ejctd1agrt95x/parenface.el">https://www.dropbox.com/s/v0ejctd1agrt95x/parenface.el</a></p>

<p>然后在 .emacs 里面加入两行：</p>

<pre><code>(require 'parenface)
(set-face-foreground 'paren-face "DimGray")
</code></pre>

<p>然后再打开 Scheme 代码的时候，你就会看到是这个样子：</p>

<p><img src="http://www.yinwang.org/images/scheme-paren.jpeg" width="95%"></p>

<p>好了，这就是我写 Scheme 的所有配置了。希望这些有所帮助。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>什么是启发</h2>

    <p>我喜欢用“启发”这个词。比如我经常会对人说：“你启发了我。”然而听到这话的人有时候不明白我的意思，自以为高我一筹，于是顿显傲气。其实我用“启发”这个词，是有深刻含义的。“启发”的意思并不等于“我没有你懂得多”或者“你比我聪明”，而是一个很含糊的词。</p>

<p>如果 A 受到了 B 启发，有几种可能性：</p>

<ol>
<li>B 做了一件很聪明的事情，所以从正面启发了 A</li>
<li>B 做了一件很笨的事情，所以从反面启发了 A</li>
<li>B 做了一件不好也不坏的事情，但是这个事情正好触发了 A 事先想的一个问题的答案</li>
</ol>


<p>这就是为什么“美丽心灵”里的 John Nash 在酒吧看到一个美女之后，解决了一个重要的问题，然后对她说“谢谢”，让人家都莫名其妙。</p>

<p>Richard Feynman 也提到：“在你的头脑里随时准备好12个问题。每当发生一件有趣的事情，就检查一下其中是否有问题可以由此获得线索。久而久之，人们就会称你为天才。”</p>

<p>孔夫子所谓的“三人行必有我师”，也就是这个意思吧。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>谈“测试驱动的开发”</h2>

    <p>现在的很多公司，包括 Google 和我现在的公司 Coverity，都喜欢一种“测试驱动的开发”（test-driven development）。它的原理是，在写程序的时候同时写上自动化的“单元测试”（unit test）。在代码修改之后，这些测试可以批量的被运行，这样就可以避免不应该出现的错误。</p>

<p>这不是一个坏主意。我在 Kent 的编译器课程上也使用了很多测试。它们在编译器的开发中是不可缺少的。编译器是一种极其精密的程序，微小的改动都可能带来重大的错误。所以编译器的项目一般都含有大量的测试。</p>

<p>然而测试的构建，应该是在程序主体已经成形的情况下才能进行。如果程序属于创造性的设计，主体并未成形，过早的加入测试反而会大幅度的降低开发效率。所以当我给 Google 开发 Python 静态分析的时候，我几乎没有使用任何测试。虽然组里的成员催我写测试，但是我却知道那只会降低我的开发效率，因为这个程序在几个星期的过程中，被我推翻重来了好几次。要是我一开头就写上测试，这些测试就会碍手碍脚，阻碍我大幅度的修改代码。</p>

<p>测试的另一个副作用是，它让很多人对测试有一种盲目的依赖心理。改了程序之后，把测试跑一遍没出错，就以为自己的代码是正确的。可是测试其实并不能保证代码的正确，即使完全“覆盖”了也是一样。覆盖只是说你的代码被测试碰到过了，可是它在什么条件下碰到的却没法判断。如果实际的条件跟测试时的条件不同，那么实际运行中仍然会出问题。测试的条件往往是“组合爆炸”的数量级，所以你不可能测试所有的情况。唯一能可靠的方法是使用严密的“逻辑推理”，证明它的正确。</p>

<p>当然我并不是让你用 ACL2 或者 Coq 这样的定理证明软件。虽然它们的逻辑非常严密，但是用它们来证明复杂的软件系统，需要顶尖的程序员和大量的时间。即使如此，由于理论的限制，程序的正确性有可能根本无法证明。所以我这里说的“逻辑推理”，只是局部的，人力的，基本的逻辑推理。</p>

<p>很多人写程序只是凭现象来判断，而不能精密的分析程序的逻辑，所以他们修改程序经常“治标不治本”。如果程序出问题了，他们的办法是看看哪里错了，也不怎么理解，就改一下让它不再出错，最多再把所有测试跑一遍。或者再加上一些新的测试，以保证这个地方下次不再出问题。</p>

<p>这种做法的结果是，程序里出现大量的“特殊情况”和“创可贴”。把一个“虫子”按下去，另一个虫子又冒出来。忙活来忙活去，最后仍然不能让程序满足“所有情况”。其实能够“满足所有情况”的程序，往往比能够“满足特殊情况”的程序简单很多。这是一个很奇怪的事情：能做的事越多，代码量却越少。也许这就叫做程序的“美”，它跟数学的“美”其实是一回事。</p>

<p>美的程序不可能从修修补补中来。它必须完美的把握住事物的本质，否则就会有许许多多无法修补的特例。其实程序员跟画家差不多，画家如果一天到头蹲在家里，肯定什么好东西也画不出来。程序员也一样，蹲在家里面对电脑，其实很难写出什么好的代码。你必须出去观察事物，寻找“灵感”，而不只是写代码。在修改代码的时候，你必须用“心灵之眼”看见代码背后所表达的事物。这也是为什么很多高明的程序员不怎么用调试器（debugger）的原因。他们只是用眼睛看着代码，然后闭上眼，脑海里浮现出其中信息的流动，所以他们经常一动手就能改到正确的地方。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>我为什么离开 Cornell</h2>

    <p>很多人都知道，我曾经在 Cornell 博士就读，两年之后转学到了 Indiana 大学。几乎所有人，包括 Indiana 大学的人都感觉奇怪，为什么会有人从 Cornell 这样的“牛校”转学到 Indiana。我曾经在之前的博文里提到 Cornell 的情况，比如学生一上课就忙着抄笔记，作业压得喘不过气，等等。那些都是实际的情况，所以我没什么必要为我的“母校”说好话。</p>

<p>离开 Cornell 之后，看到有人在 facebook 上成立了一个“Cornell 痛恨者协会”。其中一个人写到：</p>

<blockquote><p>“Cornell 说要教你游泳，就把你推进池塘里，任凭你扑腾挣扎。等你快扑腾到岸边的时候，它忽然拿起一块大石头砸在你头上，然后继续等着你上岸。当你再次接近岸边的时候，它又拿起一个榔头敲在你头上，这样你就可以死了，可是 Cornell 仍然继续等着你游上岸边……”</p></blockquote>

<p>这就是一个非常形象的，对我在 Cornell 的两年的总结。现在看看我在 Indiana 学到了什么，而 Cornell 教会了我什么，感觉简直一个天上一个地下。Dan Friedman 和 R. Kent Dybvig，他们的教育真的像是爱因斯坦所说的，像是珍贵的礼物，而不是沉重的负担。他们教会我的东西，让我不再在乎任何“牛校”的博士学位甚至教授职位，不管是 Cornell, Stanford, Berkeley, MIT 还是 Harvard, ……</p>

<p>所谓的“牛校”，恐怕都是这样吧。学生对于它们只是一种成为“牛校”的工具。你拼着命要进来，好我让你进来。但是我不教你，我让你拼死的做作业。如果你做出来了，我就拿最偏最扯淡的试卷来考你。如果你通过了所有这些，那我就给你一个学位。你得到了这样的“荣誉”，自然就会说“我的学校很牛”。你不敢说它不牛，因为那样就是说你也不牛了。所以这样的学校其实什么也不用干，你能学会东西能毕业，全都是靠你自己，到时候你却要把功劳都归到学校头上。天底下就是有这样好的生意。</p>

<p>曾经有一个 Cornell 的校友跟我是朋友。当我提到 Cornell 的一些事，他总是像个老师一样，上气不接下气地“教育”我，也就是说类似家丑不可外扬的意思吧。“牛校”就是一种传染病，在你还没进去之前就已经埋下病种，当你进去之后它就开始蔓延，等你毕业很多年，它仍然与你同在。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>谈谈 Currying</h2>

    <p>很多基于 lambda calculus 的程序语言，比如 ML 和 Haskell，都习惯用一种叫做 currying 的手法来表示函数。比如，如果你在 Haskell 里面这样写一个函数：</p>

<pre><code>f x y = x + y
</code></pre>

<p>然后你就可以这样把链表里的每个元素加上 2：</p>

<pre><code>map (f 2) [1, 2, 3]
</code></pre>

<p>它会输出 <code>[3, 4, 5]</code>。</p>

<p>注意本来 <code>f</code> 需要两个参数才能算出结果，可是这里的 <code>(f 2)</code> 只给了 <code>f</code> 一个参数。这是因为 Haskell 的函数定义的缺省方式是“currying”。Currying 其实就是用“单参数”的函数，来模拟多参数的函数。比如，上面的 <code>f</code> 的定义在 Scheme 里面相当于：</p>

<pre><code>(define f
  (lambda (x)
    (lambda (y)
      (+ x y))))
</code></pre>

<p>它是说，函数 <code>f</code>，接受一个参数 <code>x</code>，返回另一个函数（没有名字）。这个匿名函数，如果再接受一个参数 <code>y</code>，就会返回 <code>x + y</code>。所以上面的例子里面，<code>(f 2)</code> 返回的是一个匿名函数，它会把 2 加到自己的参数上面返回。所以把它 map 到 <code>[1, 2, 3]</code>，我们就得到了 <code>[3, 4, 5]</code>。</p>

<p>在这个例子里面，currying 貌似一个挺有用的东西，它让程序变得“简短”。如果不用 currying，你就需要制造另一个函数，写成这个样子：</p>

<pre><code>map (\y-&gt;f 2 y) [1, 2, 3]
</code></pre>

<p>这就是为什么 Haskell 和 ML 的程序员那么喜欢 currying。这个做法其实来源于最早的 lambda calculus 的设计。因为 lambda calculus 的函数都只有一个参数，所以为了能够表示多参数的函数，有一个叫 Haskell Curry 的数学家和逻辑学家，发明了这个方法。</p>

<p>当然，Haskell Curry 是我很尊敬的人。不过我今天想指出的是，currying 在程序设计的实践中，其实并不是想象中的那么好。大量使用 currying，其实会带来程序难以理解，复杂性增加，并且还可能因此引起意想不到的错误。</p>

<p>不用 currying 的写法<code>(\y-&gt;f 2 y)</code>虽然比起 currying 的写法<code>(f 2)</code>长了那么一点，但是它有一点好。那就是你作为一个人（而不是机器），可以很清楚的从“\y->f 2 y”这个表达式，看到它的“用意”是什么。你会很清楚的看到：</p>

<blockquote><p>“f 本来是一个需要两个参数的函数。我们只给了它第一个参数 2。我们想要把 [1, 2, 3] 这个链表里的每一个元素，放进 f 的第二个参数 y，然后把 f 返回的结果一个一个的放进返回值的链表里。”</p></blockquote>

<p>仔细看看上面这段话说了什么吧，再来看看 <code>(f 2)</code> 是否表达了同样的意思？注意，我们现在的“重点”在于你，一个人，而不在于计算机。你仔细想，不要让思维的定势来影响你的判断。</p>

<p>你发现了吗？<code>(f 2)</code> 并不完全的含有 <code>\y-&gt;f 2 y</code> 所表达的内容。因为单从 <code>(f 2)</code> 这个表达式（不看它的定义），你看不到“f 总共需要几个参数”这一信息，你也看不到 (f 2) 会返回什么东西。f 有可能需要2个参数，也有可能需要3个，4个，5个…… 比如，如果它需要3个参数的话，<code>map (f 2) [1, 2, 3]</code> 就不会返回一个整数的链表，而会返回一个函数的链表，它看起来是这样：<code>[(\z-&gt;f 2 1 z), (\z-&gt;f 2 2 z), (\z-&gt;f 2 3 z)]</code>。这三个函数分别还需要一个参数，才会输出结果。</p>

<p>这样一来，表达式 <code>(f 2)</code> 含有的对“人”有用的信息，就比较少了。你不能很可靠地知道这个函数接受了一个参数之后会变成什么样子。当然，你可以去看 <code>f</code> 的定义，然后再回来，但是这里有一种“直觉”上的开销。如果你不能同时看见这些信息，你的脑子就需要多转一道弯，你就会缺少一些重要的直觉。这种直觉能帮助你写出更好的程序。</p>

<p>然而，currying 的问题不止在于这种“认知”的方面，有时候使用 curry 会直接带来代码复杂性的增加。比如，如果你的 f 定义不是加法，而是除法：</p>

<pre><code>f x y = x / y
</code></pre>

<p>然后，我们现在需要把链表 <code>[1, 2, 3]</code> 里的每一个数都除以 2。你会怎么做呢？</p>

<p><code>map (f 2) [1, 2, 3]</code> 肯定不行，因为 2 是除数，而不是被除数。熟悉 Haskell 的人都知道，可以这样做：</p>

<pre><code>map (flip f 2) [1, 2, 3]
</code></pre>

<p><code>flip</code> 的作用是“交换”两个参数的位置。它可以被定义为：</p>

<pre><code>flip f x y = f y x
</code></pre>

<p>但是，如果 f 有 3 个参数，而我们需要把它的第 2 个参数 <code>map</code> 到一个链表，怎么办呢？比如，如果 <code>f</code> 被定义为：</p>

<pre><code>f x y z = (x - y) / z
</code></pre>

<p>稍微动一下脑筋，你可能会想出这样的代码：</p>

<pre><code>map (flip (f 1) 2) [1, 2, 3]
</code></pre>

<p>能想出这段代码说明你挺聪明，可是如果你这样写代码，那就是缺乏一些“智慧”。有时候，好的程序其实不在于显示你有多“聪明”，而在于显示你有多“笨”。现在我们就来看看笨一点的代码：</p>

<pre><code>map (\y -&gt; f 1 y 2) [1, 2, 3]
</code></pre>

<p>现在比较一下，你仍然觉得之前那段代码很聪明吗？如果你注意观察，就会发现 <code>(flip (f 1) 2)</code> 这个表达式，是多么的晦涩，多么的复杂。</p>

<p>从 <code>(flip (f 1) 2)</code> 里面，你几乎看不到自己想要干什么。而 <code>\y-&gt; f 1 y 2</code> 却很明确的显示出，你想用 1 和 2 填充掉 <code>f</code> 的第一，三号参数，把第二个参数留下来，然后把得到的函数 map 到链表 <code>[1, 2, 3]</code>。仔细看看，是不是这样的？</p>

<p>所以你花费了挺多的脑力才把那使用 currying 的代码写出来，然后你每次看到它，还需要耗费同样多的脑力，才能明白你当时写它来干嘛。你是不是吃饱了没事干呢？</p>

<p>练习题：如果你还不相信，就请你用 currying 的方法（加上 <code>flip</code>）表达下面这个语句，也就是把 f 的第一个参数 map 到链表 <code>[1, 2, 3]</code>：</p>

<pre><code>map (\y -&gt; f y 1 2) [1, 2, 3]
</code></pre>

<p>得到结果之后再跟上面这个语句对比，看谁更加简单？</p>

<p>到现在你也许注意到了，以上的“笨办法”对于我们想要 <code>map</code> 的每一个参数，都是差不多的形式；而使用 currying 的代码，对于每个参数，形式有很大的差别。所以我们的“笨办法”其实才是以不变应万变的良策。</p>

<p>才三个参数，currying 就显示出了它的弱点，如果超过三个参数，那就更麻烦了。所以很多人为了写 currying 的函数，特意把参数调整到方便 currying 的顺序。可是程序的设计总是有意想不到的变化。有时候你需要增加一个参数，有时候你又想减少一个参数，有时候你又会有别的用法，导致你需要调整参数的顺序…… 事先安排好的那些参数顺序，很有可能不能满足你后来的需要。即使它能满足你后来的需要，你的函数也会因为 currying 而难以看懂。</p>

<p>这就是为什么我从来不在我的 ML 和 Haskell 程序里使用 currying 的原因。古老而美丽的理论，也许能够给我带来思想的启迪，可是未必就能带来工程中理想的效果。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>谈惰性求值</h2>

    <p>从之前的几篇博文里面你也许已经看到了，Haskell 其实是问题相当严重的语言，然而这些问题却没有引起足够的重视。我能看到的 Haskell 的问题在于：</p>

<ul>
<li><p>复杂的基于缩进的语法，使得任何编辑器都不能高效的编辑 Haskell 程序，并且使得语法分析难度加倍。对这个观点，请参考我的博文《谈语法》以及我的英文博文《Layout Syntax Considered Harmful》。</p></li>
<li><p>“纯函数式”的语义以及 monad 其实不是好东西。对此请参考博文《对函数式语言的误解》。</p></li>
<li><p>Haskell 所用的 Hindley-Milner 类型系统，其实含有一个根本性的错误。对此请参考《Hindley-Milner 类型系统的根本性错误》。</p></li>
<li><p>Haskell 所用的 type class，其实跟一般语言（比如 Java）里面的重载（overloading）并没有本质区别。你看到的区别都是因为 Hindley-Milner 系统和重载混合在一起产生的效果。type class 并不能比其它语言里的重载做更多的事。</p></li>
</ul>


<p>这样一来，好像 Haskell 的“特征”，要么是错误的，要么就不是自己的。可是现在我再给它加上一棵稻草：Haskell 的惰性求值（lazy evaluation）方式，其实大大的限制了它的运行效率，并且使得它跟并行计算的目标相矛盾。</p>

<p>这是一个对我已经非常明显的问题，所以我只简要的说明一下。惰性求值的方式，使得我们在“需要”一个变量的值的时候，总是有两种可能性：1）这个变量在这之前已经被求值，所以可以直接取值 2）这个变量还没有被求值，也就是说它还是一个 thunk，我们必须启动对它的求值。</p>

<p>可能你已经发现了，这其实带来了类型系统的混乱。任何类型，不管是 Int, Bool, List, ... 或者自定义数据类型，都多出了这么一个东西：thunk。它表示的是“还没有求值的计算”。Haskell 程序员一般把它叫做“bottom”，写作 <em>|</em>。它的意思是：死循环。因为任何 thunk 都有可能 1）返回一个预定的类型的值，或者 2）导致死循环。</p>

<p>这有点像 C++ 和 Java 里的 null 指针，因为 null 可以被作为任何其他类型使用，却又不具有那种类型的特征，所以会产生意想不到的问题。<em>|</em> 给 Haskell 带来的问题没那么严重，但却一样的不可预料，难以分析和调试。对于 Haskell 来说，有可能出现这样的事情：明明写了一个很小的函数，觉得应该不会花很多时间。结果呢，因为它对某个变量取值，间接的触发了一段很耗时间的代码，所以等了老半天还没返回。想知道是哪里出了问题，却难以发现线索，因为这函数并没有直接或者间接的调用那段耗时间的代码，而是这个变量的 thunk 启动了那段代码。这就导致了程序的效率难以分析：被“惰性”搁在那里的计算，有可能在出乎你意料的地方爆发。这就是所谓“平时不烧香，临时抱佛脚。”</p>

<p>这种不确定性，并没有带来总体计算开销的增加。然而“惰性”却在另外一方面带来了巨大的开销，这就是“问问题”的开销。每当看到一个变量，Haskell 都会问它一个问题：“你被求值了没有？”即使这变量已经被求值，而且已经被取值一百万次，Haskell 仍然会问这个问题：“你被求值了没有？”问一个变量这问题可能不要紧，可是 Haskell 会问几乎所有的变量这个问题，反复的问这个问题。这就累积成了巨大的开销。跟我在另一篇博文里谈到的“解释开销”差不多，这种问题是“运行时”的，所以没法被编译器“优化”掉。</p>

<p>具有讽刺意味的是，Haskell 这种“纯函数式语言”的惰性求值所需要的 thunk，全都需要“副作用”才可以更新，所以它们必须被放在内存里面，而不是寄存器里面。如果你理解了我写的《对函数式语言的误解》，你就会发现连 C 程序里面的“副作用”也没有 Haskell 这么多。这样一来，处理器的寄存器其实得不到有效的利用，从而大大增加了内存的访问。我为什么可以很确信的告诉你这个呢？因为我曾经设计了一个寄存器分配算法，于是开会的时候我问 GHC 的实现者们，你们会不会对一个新的寄存器分配算法感兴趣，我可以帮你们加到 GHC 里面。结果他们说，我们不需要，因为 Haskell 到处都是 thunk，根本就没什么机会用寄存器。</p>

<p>所以，问太多问题，没法充分利用寄存器，这使得 Haskell 在效率上大打折扣。</p>

<p>然后我们来看看，为什么惰性求值会跟并行计算的目标相冲突。这其实很明显，它的原因就在于“惰性求值”的定义。惰性求值说：“到需要我的时候再来计算我。”而并行计算说：“到需要你的时候，你最好已经被某个处理器算出来了。”所以你看到了，并行计算要求你“勤奋”，要求你事先做好准备。而惰性求值本来就是很“懒”，怎么可能没事找事，先把自己算出来呢？由于这个问题来自于“惰性求值”的定义，所以这是不可调和的矛盾。</p>

<p>所以，惰性求值不管是在串行处理还是在并行处理的时候，都会带来效率上的大打折扣。它是一个很鸡肋的语言特征。</p>

<p>虽然惰性求值不能给我们带来直接的益处，但它背后的理论思想却可以启发另外的设计。如果你想真的了解惰性求值的原理，可以先看一下我写的一个惰性求值的解释器。看看如何在不到 40 行代码之内，实现 Haskell 语义的精髓：</p>

<p><a href="https://github.com/yinwang0/gems/blob/master/interp-lazy.rkt">https://github.com/yinwang0/gems/blob/master/interp-lazy.rkt</a></p>

<p>这段代码的工作原理，我以后再专门写文章讲解。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>对函数式语言的误解</h2>

    <p>很早的时候，“函数式语言”对于我来说就是 Lisp，因为 Lisp 可以在程序的几乎任何位置定义函数，并且把它们作为值来传递（这叫做 first-class function）。后来有人告诉我，Lisp 其实不算是“函数式语言”，因为 Lisp 的函数并不“纯”（pure）。所谓“纯函数”的意思，就是像数学的函数一样，如果你给它同样的输入，它就给你同样的输出。然后你就发现在这种定义下，几乎所有程序语言里面常见的随机数函数（<code>random</code>），其实都不是“纯函数”。因为每一次调用 <code>random()</code>，你都会得到不同的随机数。</p>

<p>在这种害怕自己所用的语言“不纯”的恐慌之下，我开始接触 Haskell，一种号称“纯函数式”的语言。Haskell 的社区喜欢在他们的概念里省掉“纯”这个字，把 Haskell 叫做“函数式语言”。他们喜欢“纠正”别人的概念。他们告诉人们，“不纯”的函数式语言，其实都不配叫做“函数式语言”。在他们的这种定义下，Lisp 这么老牌的函数式语言，居然都不能叫“函数式语言”了。但是看完这篇文章你就会发现，其实他们的这种定义是狭隘和错误的。</p>

<p>在 Haskell 里面，你不能使用通常语言里面都有的赋值语句，比如 Pascal 里的 <code>x:=1</code>，C 和 Java 里的 <code>x=1</code>，或者 Scheme 里的 <code>(set! x 1)</code>，Common Lisp 里的 <code>(setq x 1)</code>。这样一来，你就不可能保留“状态”（state）。所谓“状态”，就是指“随机数种子”那样的东西，其实本质上就是“全局变量”。比如，在 C 语言里定义 <code>random()</code> 函数，你可以这么做：</p>

<pre><code>int random()
{
  static int seed = 0;
  seed = next_random(seed);
  return seed;
}    
</code></pre>

<p>这里的 <code>seed</code> 是一个“static 变量”，其本质就是一个全局变量，只不过这个全局变量只能被 <code>random</code> 这一个函数访问。每次调用 <code>random()</code>，它都会使用 <code>next_random(seed)</code> 生成下一个随机数，并且把 <code>seed</code> 的值更新为这个新的随机数。在 <code>random()</code> 的执行结束之后，<code>seed</code> 会一直保存这个值。下一次调用 <code>random()</code>，它就会根据 <code>seed</code> 保存的值，算出下一个随机数，然后再次更新 <code>seed</code>，如此继续。这就是为什么每一次调用 <code>random()</code>，你都会得到不同的随机数。</p>

<p>可是在 Haskell 里面情况就很不一样了。由于 Haskell 不能保留状态，所以同一个“变量”在它作用域的任何位置都具有相同的值。每一个函数只要输入相同，就会输出同样的结果。所以在 Haskell 里面，你不能轻松的表达 <code>random</code> 这样的“不纯函数”。为了让 <code>random</code> 在每次调用得到不同的输出，你必须给它“不同的输入”。那怎么才能给它不同的输入呢？Haskell 采用的办法，就是把“种子”作为输入，然后返回两个值：新的随机数和新的种子，然后想办法把这个新的种子传递给下一次的 <code>random</code> 调用。所以 Haskell 的 <code>random</code> 的“线路”看起来像这个样子：</p>

<pre><code>（旧种子）---&gt; （新随机数，新种子）
</code></pre>

<p>现在问题来了。得到的这个新种子，必须被准确无误的传递到下一个使用 <code>random</code> 的地方，否则你就没法生成下一个随机数。因为没有地方可以让你“暂存”这个种子，所以为了把种子传递到下一个使用它的地方，你经常需要让种子“穿过”一系列的函数，才能到达目的地。种子经过的“路径”上的所有函数，必须增加一个参数（旧种子），并且增加一个返回值（新种子）。这就像是用一根吸管扎穿这个函数，两头通风，这样种子就可以不受干扰的通过。</p>

<p>所以你看到了，为了达到“纯函数”的目标，我们需要做很多“管道工”的工作，这增加了程序的复杂性和工作量。如果我们可以把种子存放在一个全局变量里，到需要的时候才去取，那就根本不需要把它传来传去的。除 <code>random()</code> 之外的代码，都不需要知道种子的存在。</p>

<p>为了减轻视觉负担和维护这些进进出出的“状态”，Haskell 引入了一种叫 monad 的概念。它的本质是使用类型系统的“重载”（overloading），把这些多出来的参数和返回值，掩盖在类型里面。这就像把乱七八糟的电线塞进了接线盒似的，虽然表面上看起来清爽了一些，底下的复杂性却是不可能消除的。有时候我很纳闷，在其它语言里易如反掌的事情，为什么到 Haskell 里面就变成了“研究性问题”，很多时候就是 monad 这东西在捣鬼。特别是当你有多个“状态”的时候，你就需要使用像 monad transformer 这样的东西。而 monad transformer 在本质上其实是一个丑陋的 hack，它并不能从根本上解决问题，却可以让你伤透脑筋也写不出来。有些人以为会用 monad 和 monad transformer 就说明他水平高，其实这根本就是自己跟自己过不去而已。</p>

<p>当谈到 monad 的时候，我喜欢打这样一个比方：</p>

<blockquote><p>使用含有 monad 的“纯函数式语言”，就像生活在一个没有电磁波的世界。</p>

<p>在这个世界里面没有收音机，没有手机，没有卫星电视，没有无线网，甚至没有光！这个世界里的所有东西都是“有线”的。你需要绞尽脑汁，把这些电线准确无误的通过特殊的“接线器”（monad）连接起来，才能让你的各种信息处理设备能够正常工作，才能让你自己能够看见东西。如果你想生活在这样的世界里的话，那就请继续使用 Haskell。</p></blockquote>

<p>其实要达到纯函数式语言的这种“纯”的效果，你根本不需要使用像 Haskell 这样完全排斥“赋值语句”的语言。你甚至不需要使用 Lisp 这样的“非纯”函数式语言。你完全可以用 C 语言，甚至汇编语言，达到同样的效果。</p>

<p>我只举一个非常简单的例子，在 C 语言里面定义如下的函数。虽然函数体里面含有赋值语句，它却是一个真正意义上的“纯函数”：</p>

<pre><code>int f(int x) {
    int y = 0;
    int z = 0;
    y = 2 * x;
    z = y + 1;
    return z / 3;
}    
</code></pre>

<p>这是为什么呢？因为它计算的是数学函数 <code>f(x) = (2x+1)/3</code> 。你给它同样的输入，肯定会得到同样的输出。函数里虽然对 <code>y</code> 和 <code>z</code> 进行了赋值，但这种赋值都是“局部”的，它们不会留下“状态”。所以这个函数虽然使用了被“纯函数程序员”们唾弃的赋值语句，却仍然完全的符合“纯函数”的定义。</p>

<p>如果你研究过编译器，就会理解其中的道理。因为这个函数里的 <code>y</code> 和 <code>z</code>，不过是函数的“数据流”里的一些“中间节点”，它们的用途是用来暂存一些“中间结果”。这些局部的赋值操作，跟函数调用时的“参数传递”没有本质的区别，它们不过都是把信息传送到指定的节点而已。如果你不相信的话，我现在就可以把这些赋值语句全都改写成函数调用：</p>

<pre><code>int f(int x) {
    return g(2 * x);
}

int g(int y) {
    return h(y + 1);
}

int h(int z) {
    return z/3;
}    
</code></pre>

<p>很显然，这两个 f 的定义是完全等价的，然而第二个定义却没有任何赋值语句。第一个函数里对 <code>y</code> 和 <code>z</code> 的“赋值语句”，被转换成了等价的“参数传递”。这两个程序如果经过我写的编译器，会生成一模一样的机器代码。所以如果你说赋值语句是错误的话，那么函数调用也应该是错误的了。那我们还要不要写程序了？</p>

<h2>盲目的排斥赋值语句，来自于对“纯函数”这个概念的片面理解。很多研究像 Haskell，ML 一类语言的专家，其实并不明白我上面讲的道理。他们仿佛觉得如果使用了赋值，函数就肯定不“纯”了似的。CMU 的教授 Robert Harper 就是这样一个极端。他在一篇博文里指出，人们不应该把程序里的“变量”叫做“变量”，因为它跟数学和逻辑学里所谓的“变量”不是一回事，它可以被赋值。然而，其果真如他所说的那样吗？如果你理解了我对上面的例子的分析，你就会发现其实程序里的“变量”，跟数学和逻辑学里面的“变量”相比，其实并没有本质的不同。</h2>

<p>程序里的变量甚至更加严格一些。如果你把数学看作一种程序语言的话，恐怕没有一本数学书可以编译通过。因为它们里面充满了变量名冲突，未定义变量，类型错误等程序设计的低级错误。你只需要注意概率论里表示随机数的大写变量（比如 X），就会发现数学所谓的“变量”其实是多么的不严谨。这变量 X 根本不需要被赋值，它自己身上就带“副作用”！实际上，90%以上的数学家都写不出像样的程序来。所以拿数学的“变量”来衡量程序语言的“变量”，其实是颠倒了。我们应该用程序的“变量”来衡量数学的“变量”，这样数学的语言才会有所改善。</p>

<p>逻辑学家虽然有他们的价值，但他们并不是先知，并不总是对的。由于沉迷于对符号的热爱，他们经常看不到事物的本质。虽然他们理解很多符号公式和推理规则，但他们却经常不明白这些符号和推理规则，到底代表着自然界中的什么物体，所以有时候他们连最基本的问题都会搞错（比如他们有时候会混淆“全称量词”∀的作用域）。逻辑学家们的教条主义和崇古作风，也许就是图灵当年在 Church 手下做学生那么孤立，那么痛苦的原因。也就是这个图灵，在某种程度上超越了 Church，把一部分人从逻辑学的死板思维模式下解放了出来，变成了“计算机科学家”。当然其中某些计算机科学家堕入了另外一种极端，他们对逻辑学已有的精华一无所知，所以搞出一些完全没有原则的设计，然而这不是这篇文章的主题。</p>

<p>所以综上所述，我们完全没有必要追求什么“纯函数式语言”，因为我们可以在不引起混淆的前提下使用赋值语句，而写出真正的“纯函数”来。可以自由的对变量进行赋值的语言，其实超越了通常的数理逻辑的表达能力。如果你不相信这一点，就请想一想，数理逻辑的公式有没有能力推断出明天的天气？为什么天气预报都是用程序算出来的，而不是用逻辑公式推出来的？所以我认为，程序其实在某种程度上已经成为比数理逻辑更加强大的逻辑。完全用数理逻辑的思维方式来对程序语言做出评价，其实是很片面的。</p>

<p>说了这么多，对于“函数式语言”这一概念的误解，应该消除得差不多了。其实“函数式语言”唯一的要求，应该是能够在任意位置定义函数，并且能够把函数作为值传递，不管这函数是“纯”的还是“不纯”的。所以像 Lisp 和 ML 这样的语言，其实完全符合“函数式语言”这一称号。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>爱因斯坦谈教育</h2>

    <p>继续看爱因斯坦的 Ideas and Opinions，发现挺多有趣的东西。现在把他关于教育的话题摘录在下面。自己关于教育的一些想法，等整理好了再写。</p>

<hr>

<blockquote><p>我在我的老师手里遭受了同样的待遇。因为我的独立，他们不喜欢我。当他们需要助教的时候，他们没有选择我。</p>

<p>世界上已经有太多的教育，特别是在美国的学校里面。</p>

<p>教育的唯一理性的方式是自己做一个榜样——如果实在不行，你可以做一个反例。</p>

<p>教一个人专业知识是不够的。通过专业知识，他可以变成一个有用的机器，但却不具有和谐的人格。</p>

<p>过分强调竞争，过早的功利化和专业化，可以杀灭所有文化生活所赖以生存的精神。</p>

<p>独立的，批判性的思维，必须从小培养。过度的，过于多样化的科目（分数制度）会破坏这种思维的发展。</p>

<p>教育应该是这样：被传授的知识应该被当成宝贵的礼物，而不是沉重的任务。</p></blockquote>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>论对东西的崇拜</h2>

    <p>在之前的几篇博文里面，我多次提到了 Lisp，它相对于其它语言的优势，以及 Lisp Machine 相对于 Unix 的优点。于是有人来信请教我如何学习 Lisp，也有人问我为什么 Lisp Machine 没有“流行”起来。我感觉到了他们言语中对 Lisp 的敬畏和好奇心，但也感觉到了一些隐含的怀疑。</p>

<p>这是一种复杂的感觉，仿佛我在原始人的部落兜售一些原子能小玩具，却被人当成了来自天外的传教士。敬畏和奉承，并不能引起我的好感。怀疑和嘲讽，也不能引起我的不平。当我看到有人说“别听他误导群众，学那些语言是找不到工作的”的时候，我心里完全没有愤怒，也没有鄙视，我也没必要说服他。我只是微笑着摇摇头，对自己说：可怜而可笑的人。</p>

<p>不明白为什么，当我提到某个东西相对于另一个东西的优点的时候，我总是被人认为是在“推崇”某个东西，或者被人称为是它的“狂热分子”。现在显然已经有人认为我在推崇 Lisp 了，甚至在某个地方看到有人称我为“国内三大 Lisp 狂人之一”。他们仿佛觉得我推荐一个东西，就是想让他们完全的拥抱这个东西，而丢弃自己已经有的东西。而“支持”这另一个东西的人，也往往会产生敌视情绪。</p>

<p>很多人都不明白，每个东西都有它好的方面，也有它不好的方面。我推荐的只是 Lisp 好的方面，不好的方面我心里清楚，但是还没有机会讲。这些人显然已经在下意识里把“东西”当成了人。有人说“爱一个人就要爱她（他）的全部”，这是一种很无奈的说法，因为你没有能力把一个人分解成你喜欢的和不喜欢的两部分，然后重新组装成你的梦中情人。可是东西却不一样。因为东西是人造出来的，所以你可以把它们大卸八块，然后挑出你喜欢的部分。</p>

<p>所以我可以很清楚的告诉你，我并不推崇 Lisp，我也不是 Lisp 狂人，它只是我的小玩意儿之一。这个非常精巧的小玩意儿，包含了很多其它东西身上没有的优点。人们都说忘记历史就等于毁灭未来。如果 Java 没有从 Lisp 身上学会“垃圾回收”，C# 没有从 Lisp 身上学会 lambda，那么我们今天也许还在为 segfault 而烦恼，也许会继续使用没必要的 design patterns。如果你了解一点历史就会发现，今天非常流行的 JavaScript，其实不过是一个“没能正确实现的 Scheme”。所以 Lisp 的精髓，其实正在越来越多的渗透到常用的语言里面。</p>

<p>很多人没有设计程序语言的能力，所以他们把程序语言，操作系统一类的东西当成是不可改变的，凌驾于自己之上的。相比之下，我受到的训练却给了我设计和实现几乎任何语言的能力。我知道它们的优点和弱点，我有能力把它们大卸八十块，再组装还原。我有能力改变其中我不喜欢的地方，或者增加我觉得有必要的功能。当我谈论某个东西比另一个好的地方，总有人以为我在“抱怨”，说：“既然如此，那为什么你说的这个好东西被打败了？”他不明白，其实我只是在“分析”。我希望从各个东西里面提取出好的部分，然后想办法把它们都注入到一个新的东西里面。我也希望吸取前人教训，免得重犯这些东西里面的设计错误。</p>

<p>如果在见识短浅的人们心目中，Paul Graham 和 Peter Norvig 算是“Lisp 牛人”的话，那么 Dan Friedman 和 R. Kent Dybvig 就应该被称为 “Lisp 天外来客”了。我不敢大言不惭的说我超过了恩师们，但我除了学到他们的真功夫之外，还偷学了一些他们不屑一顾的“旁门左道”。所以我经常能看到他们看不到的东西，我知道他们的弱点。他们对于 Lisp 的热爱，防止了他们看到它的一些缺点，但这些对于我却非常的清晰明了。然而也是因为他们对其它语言的不屑，才让我逐步的理解了，我曾经认为是优点的某些语言特征（比如 Hindley-Milner 类型系统），其实是缺点。</p>

<p>所以，我其实并不是那么热心的希望有更多的人用 Lisp，Haskell 或者其它什么语言。我不会，也没那工夫去分享自己的秘诀。我没有责任，也没有能力去拯救世界。这是一种找到巨大宝藏的感觉，我蹲在一堆堆的财宝上休养生息。我知道世界上即使没有了我，太阳明天照样会升起。我为什么要那么热心的让别人也知道如何进入这个宝藏？我不是一个特别自私的人，但我也不需要推销什么。这就像我介绍了我的“减肥成功经验”，你觉得太辛苦，偏要去买那些吹得神乎其神的减肥药。我有什么动机来说服你呢？又不是我身上的肥肉。</p>

<p>推崇一个东西，为一个东西狂热，这些感情都在我身上存在过。也许它们确实给我带来了一些益处，让我很快的学会了一些东西。但是这些感情的存在，其实也显示了一个人的弱小。当一个人没有办法控制一个东西的时候，他就会对它产生“崇拜”的心理，这就像所有的宗教和迷信一样。当人们处于自然灾害的凌威之下，没有能力掌握自己命运的时候，他们就对神和超自然的力量产生了崇拜。这是一种心灵的慰藉，至少有上帝或者观音菩萨，可以聆听他们的心声，可以给予他们度过灾难的勇气，但它同时也显示出人的无助和自卑。这种无助和自卑，也引发了偏激的宗教心理，因为他们害怕自己的“保护神”被别人的“保护神”所压倒，以至于让自己受制于他人。这是一种愚昧和卑劣的感情。</p>

<p>可是当你拥有了强大的力量，可以不再畏惧的时候，这种崇拜，以及由于崇拜所带来的偏激心理，就渐渐的消亡了。这就像是一个身怀绝世武功的人，他完全没必要让别人都相信他是高手。因为他知道，自己在谈笑之间，就可以让樯橹灰飞烟灭。于是，他自得其乐，对别人表现出的任何感情，都变得淡漠和无动于衷。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>“解决问题”与“消灭问题”</h2>

    <p>一直以来，人们都重视“解决问题”的能力，却忽视了另一种重要的能力：“消灭问题”的能力。各种各样的竞赛，分数和排名，让很多人从小就片面的认为，能“解决问题”的人，就是最厉害的人。拿到一个问题就埋头求解，很少考虑这问题到底有什么意义。这种呆板的思维方式，不仅存在于低级的“应试”和“解题”过程，而且蔓延到了很多艰深的研究领域。</p>

<p>如果你仔细观察就会发现，很多“难题”，其实是“人造”出来的，而不是“必然”的。它们的存在，往往是由于一些早期的“设计错误”。人造的东西里面往往有设计上的错误，如果你把这些东西看成是不可改变的东西，那你就会遇到很多不必要的问题。打个比方，如果当初轮子被设计成方形的，而没有人质疑这样做的“必要性”，那么也许人类早就因为“能源问题”而灭绝了。有点夸张，但它却形象的说明了，为什么错误的设计会导致不必要的难题。</p>

<p>其实如果我们转换一下思路，或者改变一下“设计”，很多问题就可以不解自消。这就是我所谓的“消灭问题”的能力。这种“消灭问题”的能力，表面上容易其实难，有点像脑经急转弯，所以经常受到人们的忽视。看到一个问题轻而易举的消失了，总有人满不在乎的说：“这个容易。我也能做到。” 可问题就在于，你怎么没想到？说这种话的人，完全没有意识到，他们的思维里面其实缺少了非常重要的东西。由于喜欢炫耀自己的“头脑暴力”，他们经常解决（甚至制造）错误的问题。</p>

<p>所以，在解决问题之前，我们应该先问自己三个问题：</p>

<ol>
<li><p>这问题是否真的“存在”？</p>

<p>也许你已经看出来了，很多问题，即使众人都认为它存在，其实也可能是不存在的。在这一点上不能相信任何人或者机构，不管他有多么的“权威”。就像小马过河的道理，只有靠自己的实践。</p></li>
<li><p>如果解决了这个问题，会给我和他人带来什么实际的好处？</p>

<p>世界上不存在“永远”，也不存在“无穷”。如果一个“科学算命家”花100年才能算出我的未来，那我还不如坐等“未来”的到来。所有的人，都不过是来这世界上做短暂的旅行。所以，问题的答案，应该能在合理的时间之内给人带来实际的好处。</p></li>
<li><p>这问题是否可以在简单的改变某些“设计”或者“思路”之后，不复存在？</p>

<p>很多问题的“存在”，其实是因为人们的“思维定势”。他们看不到问题的“根源”和因果关系，而是经常在下意识里假定某种“先决条件”（A）的存在，然后坚定不移的相信由此“导致”的问题（B）的存在，如下图：</p>

<pre><code>     A -----&gt; B
</code></pre></li>
</ol>


<p>然后，他们开始呆头呆脑的解决 B，完全忘记了质疑 A 存在的必要性。他们从来没有想过，如何消除 A，或者切断 A 与 B 之间的关系。他们没有发现，一旦这前提 A 不复存在，问题 B 就可以不解自消。</p>

<p>对这一点，我想起一个有趣的故事。有人在饭桌上给大家出了一道“难题”，要他们把自己盘子里的鸡蛋立起来，最后只有一个人做到了。这个人把蛋壳打破了。所有其他人都没有想到这个做法，却说他“犯规”。可是应该检讨的其实应该是他们自己，因为出题的人根本没有说不能打破蛋壳，他们却对此做出了错误的假设。</p>

<p>我经常发现计算机科学界存在这样的问题。研究了几十年，结果到最后才发现，辛辛苦苦解决的问题，其实包含了错误的假设。如果换一个角度来看，或者稍微改一改设计，这问题就基本不存在了。其中一个例子，就是编译器里面的“语法分析”（parsing）问题。</p>

<p>语法分析成为一个问题的原因，就在于很多人错误的以为程序语言应该有复杂的语法。正是这些复杂的语法，造成了这个问题研究了很多年，仍然没有一个很好的解决方案。可是一旦语法设计被简化（比如像 Lisp 那样），语法分析就变成一个非常容易的问题。实际上计算机系统（比如 Unix）里的很多问题都是由此引发的，想要利用字符串来进行数据交换，却又设计了一些非常不方便的“数据格式”。简单的语法设计，会让这些问题一并消失掉。关于这个问题，我不想重复发文，细节请见另一篇博文《<a href="http://www.yinwang.org/blog-cn/2013/03/08/on-syntax">谈语法</a>)》。</p>

<p>爱因斯坦说“想象力比知识更重要”，也许就是这个道理。没有想象力的人经常钻牛角尖，走死胡同，忘记了自己其实还有另外的路可走。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>程序语言的常见设计错误(1) - 片面追求短小</h2>

    <p>我经常以自己写“非常短小”的代码为豪。有一些人听了之后很赞赏，然后说他也很喜欢写短小的代码，接着就开始说 C 语言其实有很多巧妙的设计，可以让代码变得非常短小。然后我才发现，这些人所谓的“短小”跟我所说的“短小”完全不是一回事。</p>

<p>我的程序的“短小”是建立在语义明确，概念清晰的基础上的。在此基础上，我力求去掉冗余的，绕弯子的，混淆的代码，让程序更加直接，更加高效的表达我心中设想的“模型”。这是一种在概念级别的优化，而程序的短小精悍只是它的一种“表象”。就像是整理一团电线，并不是把它们揉成一团然后塞进一个盒子里就好。这样的做法只会给你以后的工作带来更大的麻烦，而且还有安全隐患。</p>

<p>所以我的这种短小往往是在语义和逻辑 层面的，而不是在语法上死抠几行代码。我绝不会为了程序显得短小而让它变得难以理解或者容易出错。相反，很多其它人所追求的短小，却是盲目的而没有原则的。在很多时候这些小伎俩都只是在语法层面，比如想办法把两行代码“搓”成一行。可以说，这种“片面追求短小”的错误倾向，造就了一批语言设计上的错误，以及一批“擅长于”使用这些错误的程序员。</p>

<p>现在我举几个简单的“片面追求短小”的语言设计。</p>

<h3>自增减操作</h3>

<p>很多语言里都有 <code>i++</code> 和 <code>++i</code> 这两个“自增”操作和 <code>i--</code> 和 <code>--i</code> 这两个“自减”操作（下文合称“自增减操作”。很多人喜欢在代码里使用自增减操作，因为这样可以“节省一行代码”。殊不知，节省掉的那区区几行代码比起由此带来的混淆和错误，其实是九牛之一毛。</p>

<p>从理论上讲，自增减操作本身就是错误的设计。因为它们把对变量的“读”和“写”两种根本不同的操作，毫无原则的合并在一起。这种对读写操作的混淆不清，带来了非常难以发现的错误。相反，一种等价的，“笨”一点的写法，<code>i = i + 1</code>，不但更易理解，而且在逻辑上更加清晰。</p>

<p>有些人很在乎 <code>i++</code> 与 <code>++i</code> 的区别，去追究 <code>(i++) + (++i)</code> 这类表达式的含义，追究 <code>i++</code> 与 <code>++i</code> 谁的效率更高。这些其实都是徒劳的。比如，<code>i++</code> 与 <code>++i</code> 的效率差别，其实来自于早期 C 编译器的愚蠢。因为 <code>i++</code> 需要在增加之后返回 <code>i</code> 原来的值，所以它其实被编译为：</p>

<pre><code>(tmp = i, i = i + 1, tmp)
</code></pre>

<p>但是在</p>

<pre><code>for (int i = 0; i &lt; max; i++)
</code></pre>

<p>这样的语句中，其实你并不需要在 <code>i++</code> 之后得到它自增前的值。所以有人说，在这里应该用 <code>++i</code> 而不是 <code>i++</code>，否则你就会浪费一次对中间变量 <code>tmp</code> 的赋值。而其实呢，一个良好设计的编译器应该在两种情况下都生成相同的代码。这是因为在 <code>i++</code> 的情况，代码其实先被转化为：</p>

<pre><code>for (int i = 0; i &lt; max; (tmp = i, i = i + 1, tmp))
</code></pre>

<p>由于 <code>tmp</code> 这个临时变量从来没被用过，所以它会被编译器的“dead code elimination”消去。所以编译器最后实际上得到了：</p>

<pre><code>for (int i = 0; i &lt; max; i = i + 1)
</code></pre>

<p>所以，“精通”这些细微的问题，并不能让你成为一个好的程序员。很多人所认为的高明的技巧，经常都是因为早期系统设计的缺陷所致。一旦这些系统被改进，这些技巧就没什么用处了。</p>

<p>真正正确的做法其实是：完全不使用自增减操作，因为它们本来就是错误的设计。</p>

<p>好了，一个小小的例子，也许已经让你意识到了片面追求短小程序所带来的认知上，时间上的代价。很可惜的是，程序语言的设计者们仍然在继续为此犯下类似的错误。一些新的语言加入了很多类似的旨在“缩短代码”，“减少打字量”的雕虫小技。也许有一天你会发现，这些雕虫小技所带来的，除了短暂的兴奋，其实都是在浪费你的时间。</p>

<h3>赋值语句返回值</h3>

<p>在几乎所有像 C，C++，Java 的语言里，赋值语句都可以被作为值。之所以设计成这样，是因为你就可以写这样的代码：</p>

<pre><code>if (y = 0) { ... }
</code></pre>

<p>而不是</p>

<pre><code>y = 0;
if (y) { ... }
</code></pre>

<p>程序好像缩短了一行，然而，这种写法经常引起一种常见的错误，那就是为了写 <code>if (y == 0) { ... }</code> 而把 <code>==</code> 比较操作少打了一个 <code>=</code>，变成了 <code>if (y = 0) { ... }</code>。很多人犯这个错误，是因为数学里的 <code>=</code> 就是比较两个值是否相等的意思。</p>

<p>不小心打错一个字，就让程序出现一个 bug。不管 <code>y</code> 原来的值是多少，经过这个“条件”之后，<code>y</code> 的值都会变成 0。所以这个判断语句会一直都为“假”，而且一声不吭的改变了 <code>y</code> 的值。这种 bug 相当难以发现。这就是另一个例子，说明片面追求短小带来的不应有的问题。</p>

<p>正确的做法是什么呢？在一个类型完备的语言里面，像 <code>y=0</code> 这样的赋值语句，其实是不应该可以返回一个值的，所以它不允许你写：</p>

<pre><code>x = y = 0
</code></pre>

<p>或者</p>

<pre><code>if (y = 0) { ... }
</code></pre>

<p>这样的代码。</p>

<p><code>x = y = 0</code> 的工作原理其实是这样：经过 parser 它其实变成了 <code>x = (y = 0)</code>（因为 <code>=</code> 操作符是“右结合”的）。<code>x = (y = 0)</code> 这个表达式也就是说 <code>x</code> 被赋值为 <code>(y = 0)</code> 的值。注意，我说的是 <code>(y = 0)</code> 这整个表达式的值，而不是 <code>y</code> 的值。所以这里的 <code>(y = 0)</code> 既有副作用又是值，它返回 <code>y</code> 的“新值”。</p>

<p>正确的做法其实是：<code>y = 0</code> 不应该具有一个值。它的作用应该是“赋值”这种“动作”，而不应该具有任何“值”。即使牵强一点硬说它有值，它的值也应该是 <code>void</code>。这样一来 <code>x = y = 0</code> 和 <code>if (y = 0)</code> 就会因为“类型不匹配”而被编译器拒绝接受，从而避免了可能出现的错误。</p>

<p>仔细想一想，其实 <code>x = y = 0</code> 和 <code>if (y = 0)</code> 带来了非常少的好处，但它们带来的问题却耗费了不知道多少人多少时间。这就是我为什么把它们叫做“小聪明”。</p>

<h3>思考题：</h3>

<ol>
<li><p>Google 公司的代码规范里面规定，在任何情况下 for 语句和 if 语句之后必须写花括号，即使 C 和 Java 允许你在其只包含一行代码的时候省略它们。比如，你不能这样写</p>

<pre><code>for (int i=0; i &lt; n; i++)
   some_function(i);
</code></pre>

<p>而必须写成</p>

<pre><code> for (int i=0; i &lt; n; i++) {
   some_function(i);
 }
</code></pre>

<p>请分析：这样多写两个花括号，是好还是不好？</p>

<p>（提示，Google 的代码规范在这一点上是正确的。为什么？）</p></li>
<li><p>当我第二次到 Google 实习的时候，发现我一年前给他们写的代码，很多被调整了结构。几乎所有如下结构的代码：</p>

<pre><code> if (condition) {
   return x;
 } else {
   return y;
 }
</code></pre>

<p>都被人改成了：</p>

<pre><code> if (condition) {
   return x;
 }
 return y;
</code></pre>

<p>请问这里省略了一个 <code>else</code> 和两个花括号，会带来什么好处或者坏处？</p>

<p>（提示，改过之后的代码不如原来的好。为什么？）</p></li>
<li><p>根据本文对于自增减操作的看法，再参考传统的图灵机的设计，你是否发现图灵机的设计存在类似的问题？你如何改造图灵机，使得它不再存在这种问题？</p>

<p>（提示，注意图灵机的“读写头”。）</p></li>
<li><p>参考这个《<a href="http://tour.golang.org">Go 语言入门指南</a>》，看看你是否能从中发现由于“片面追求短小”而产生的，别的语言里都没有的设计错误？</p></li>
</ol>



  </body>
<h1>=======================================================<h1>
<body>

    <h2>谈语法</h2>

    <p><img src="http://www.yinwang.org/images/lisp_cycles.png" width="95%"></p>

<p>使用和研究过这么多程序语言之后，我觉得几乎不包含多余功能的语言，只有一个：Scheme。所以我觉得它是学习程序设计最好的入手点和进阶工具。当然 Scheme 也有少数的问题，而且缺少一些我想要的功能，但这些都瑕不掩瑜。在用了很多其它的语言之后，我觉得 Scheme 真的是非常优美的语言。</p>

<p>要想指出 Scheme 所有的优点，并且跟其它语言比较，恐怕要写一本书才讲的清楚。所以在这篇文章里，我只提其中一个最简单，却又几乎被所有人忽视的方面：语法。</p>

<p>其它的 Lisp “方言”也有跟 Scheme 类似的语法（都是基于“S表达式”），所以在这篇（仅限这篇）文章里我所指出的“Scheme 的优点”，其实也可以作用于其它的 Lisp 方言。从现在开始，“Scheme”和“Lisp”这两个词基本上含义相同。</p>

<p>我觉得 Scheme （Lisp） 的基于“S表达式”（S-expression）的语法，是世界上最完美的设计。其实我希望它能更简单一点，但是在现存的语言中，我没有找到第二种能与它比美。也许在读过这篇文章之后，你会发现这种语法设计的合理性，已经接近理论允许的最大值。</p>

<p>为什么我喜欢这样一个“全是括号，前缀表达式”的语言呢？这是出于对语言结构本质的考虑。其实，我觉得语法是完全不应该存在的东西。即使存在，也应该非常的简单。因为语法其实只是对语言的本质结构，“抽象语法树”（abstract syntax tree，AST），的一种编码。一个良好的编码，应该极度简单，不引起歧义，而且应该容易解码。在程序语言里，这个“解码”的过程叫做“语法分析”（parse）。</p>

<p>为什么我们却又需要语法呢？因为受到现有工具（操作系统，文本编辑器）的限制，到目前为止，几乎所有语言的程序都是用字符串的形式存放在文件里的。为了让字符串能够表示“树”这种结构，人们才给程序语言设计了“语法”这种东西。但是人们喜欢耍小聪明，在有了基本的语法之后，他们开始在这上面大做文章，使得简单的问题变得复杂。</p>

<p>Lisp （Scheme 的前身）是世界上第二老的程序语言。最老的是 Fortran。Fortran 的程序，最早的时候都是用打孔机打在卡片上的，所以它其实是几乎没有语法可言的。</p>

<p><img src="http://www.yinwang.org/images/punch-card.gif" alt="Fortran"></p>

<p>显然，这样写程序很痛苦。但是它却比现代的很多语言有一个优点：它没有歧义，没有复杂的 parse 过程。</p>

<p>在 Lisp 诞生的时候，它的设计者们一下子没能想出一种好的语法，所以他们决定干脆先用括号把这语法树的结构全都括起来，一个不漏。等想到更好的语法再换。</p>

<p>自己想一下，如果要表达一颗“树”，最简单的编码方式是什么？就是用括号把每个节点的“数据”和“子节点”都括起来放在一起。Lisp 的设计者们就是这样想的。他们把这种完全用括号括起来的表达式，叫做“S表达式”（S 代表 "symbolic"）。这貌似很“粗糙”的设计，甚至根本谈不上“设计”。奇怪的是，在用过一段时间之后，他们发现自己已经爱上了这个东西，再也不想设计更加复杂的语法。于是S表达式就沿用至今。</p>

<p>在使用过 Scheme，Haskell，ML，和常见的 Java，C，C++，Python，Perl，…… 之后，我也惊讶的发现， Scheme 的语法，不但是最简单，而且是最好看的一个。这不是我情人眼里出西施，而是有一定理论依据的。</p>

<p>首先，把所有的结构都用括号括起来，轻松地避免了别的语言里面可能发生的“歧义”。程序员不再需要记忆任何“运算符优先级”。</p>

<p>其次，把“操作符”全都放在表达式的最前面，使得基本算术操作和函数调用，在语法上发生完美的统一，而且使得程序员可以使用几乎任何符号作为函数名。</p>

<p>在其他的语言里，函数调用看起来像这个样子：<code>f(1)</code>，而算术操作看起来是这样：<code>1+2</code>。在 Lisp 里面，函数调用看起来是这样<code>(f 1)</code>，而算术操作看起来也是这样<code>(+ 1 2)</code>。你发现有什么共同点吗？那就是 <code>f</code> 和 <code>+</code> 在位置上的对应。实际上，加法在本质也是一个函数。这样做的好处，不但是突出了加法的这一本质，而且它让人可以用跟定义函数一模一样的方式，来定义“运算符”！这比起 C++ 的“运算符重载”强大很多，却又极其简单。</p>

<p>关于“前缀表达式”与“中缀表达式”，我有一个很独到的见解：我觉得“中缀表达式”其实是一种过时的，来源于传统数学的历史遗留产物。几百年以来，人们都在用 <code>x+y</code> 这样的符号来表示加法。之所以这样写，而不是 <code>(+ x y)</code>，是因为在没有计算机以前，数学公式都得写在纸上，写 <code>x+y</code> 显然比 <code>(+ x y)</code> 方便简洁。但是，中缀表达式却是容易出现歧义的。如果你有多个操作符，比如 <code>1+2*3</code>。那么它表示的是 <code>(+ 1 (* 2 3))</code> 呢，还是 <code>(* (+ 1 2) 3)</code>？所以才出现了“运算符优先级”这种东西。看见没有，S表达式已经在这里显示出它没有歧义的优点。你不需要知道 <code>+</code> 和 <code>*</code> 的优先级，就能明白 <code>(+ 1 (* 2 3))</code> 和 <code>(* (+ 1 2) 3)</code> 的区别。第一个先乘后加，而第二个先加后乘。</p>

<p>对于四则运算，这些优先级还算简单。可是一旦有了更多的操作，就容易出现混淆。这就是为什么数学（以及逻辑学）的书籍难以看懂。 实际上，那些看似复杂的公式，符号，不过是在表示一些程序里的“数据结构”，“对象”以及“函数”。大部分读数学书的时间，其实是浪费在琢磨这些公式：它们到底要表达的什么样一个“数据结构”或者“操作”！这个“琢磨”的过程，其实就是程序语言里所谓的“语法分析”（parse）。</p>

<p>这种问题在微积分里面就更加明显。微积分难学，很大部分原因，就是因为微积分的那些传统的运算符，其实不是很好的设计。如果你想了解更好的设计，可以参考一下 Mathematica 的公式设计。试试在 Mathematica 里面输入“单行”的微积分运算（而不使用它传统的“2D语法”）。</p>

<p>其实 Lisp 已经可以轻松地表示这种公式，比如对 <code>x^2</code> 进行微分，可以表示成</p>

<pre><code>      (D ‘(^ x 2) ‘x)
</code></pre>

<p>看到了吗？微分不过是一个用于处理符号的函数 <code>D</code>，输入一个表达式和另一个符号，输出一个新的表达式。</p>

<p>同样的公式，传统的数学符号是这个样子：</p>

<p><img src="http://www.yinwang.org/images/deriv-math.png"></p>

<p>这是什么玩意啊？<code>d</code> 除以 <code>dx</code>，然后乘以 <code>x</code> 的平方？</p>

<p>在 Lisp 里，你其实可以比较轻松地实现符号微分的计算。SICP里貌似有一节就是教你写个符号微分程序。做微积分这种无聊的事情，就是应该交给电脑去做。总之，这从一方面显示了，Lisp 的语法其实超越了传统的数学。</p>

<p>其实我一直都在想，如果把数学看成是一种程序语言，它也许就是世界上语法最糟糕的语言。数学里的“变量”，几乎总是没有明确定义的作用域（scope）。也就是说他们只有“全局变量”。上一段话的 x，跟下一段话的 x，经常指的不是同一个东西。所以训练有素的数学家，总是避免使用同一个符号来表示两种不同的东西。很快他们就发现所有的拉丁字母都用光了，于是乎开始用希腊字母。大写的，小写的，粗体的，斜体的，花体的，…… 而其实，他们只不过是想实现 C++ 里的 “namespace”。</p>

<p>可惜的是，很多程序语言的设计者没能摆脱数学的思想束缚，对数学和逻辑有盲目崇拜的倾向。所以他们继续在新的语言里使用中缀表达法。Haskell，ML，Coq，Agda，这些“超高级”的语言设计，其实都中了这个圈套。在 Coq 和 Agda 里面，你不但可以使用中缀表达式，还可以定义所谓的 "mixfix" 表达式。这样其实是把简单的问题复杂化。想让自己看起来像“数学”，很神秘的样子，其实是学会了数学的糟粕，自讨苦吃。</p>

<p>另外，由于 Lisp 的表达能力和灵活性比其他语言要大很多，所以类似 C 或者 Pascal 那样的语法其实不能满足 Lisp 的需要。在 Lisp 里，你可以写 (+ 10 (if test 1 2)) 这样的代码，然而如果你使用 C 那样的无括号语法，就会发现没法很有效的嵌入里面的那个条件语句而不出现歧义。这就是为什么 C 必须使用 test? 1 : 2 这样的语法来表示 Lisp 的 if 能表示的东西。然而即使如此，你仍然会经常被迫加上一对括号，结果让程序非常难看，最后的效果其实还不如用 Lisp 的语法。在 C 这样的语言里，由于结构上有很多限制，所以才觉得那样的语法还可以。可是一旦加入 Lisp 的那些表达能力强的结构，就发现越来越难看。JavaScript（node.js）就是对此最好的一个证据。</p>

<p>最后，从美学的角度上讲，S表达式是很美观的设计。所有的符号都用括号括起来，这形成一种“流线型”的轮廓。而且由于可以自由的换行排版，你可以轻松地对齐相关的部分。在 Haskell 里，你经常会发现一些很蹩脚，很难看的地方。这是因为中缀表达式的“操作符”，经常不能对在一起。比如，如果你有像这样一个 case 表达式：</p>

<pre><code>case x
  Short _ -&gt; 1
  VeryLooooooooooooooooooooooooog _ -&gt; 2
</code></pre>

<p>为了美观，很多 Haskell 程序员喜欢把那两个箭头对齐。结果就成了这样：</p>

<pre><code>case x
  Short _                           -&gt; 1
  VeryLooooooooooooooooooooooooog _ -&gt; 2
</code></pre>

<p>作为一个菜鸟级摄影师，你不觉得第一行中间太“空”了一点吗？</p>

<p>再来看看S表达式如何表达这东西：</p>

<pre><code>(case x
  (-&gt; (Short _) 1)
  (-&gt; (VeryLooooooooooooooooooooooooog _) 2))
</code></pre>

<p>发现“操作符总在最前”的好处了吗？不但容易看清楚，而且容易对齐，而且没有多余的间隙。</p>

<p>其实我们还可以更进一步。因为箭头的两边全都用括号括起来了，所以其实我们并不需要那两个箭头就能区分“左”和“右”。所以我们可以把它简化为：</p>

<pre><code>(case x
  ((Short _) 1)
  ((VeryLooooooooooooooooooooooooog _) 2))
</code></pre>

<p>最后我们发现，这个表达式“进化”成了 Lisp 的 case 表达式。</p>

<p>Lisp 的很多其它的设计，比如“垃圾回收”，后来被很多现代语言（比如 Java）所借鉴。可是人们遗漏了一个很重要的东西：Lisp 的语法，其实才是世界上最好的语法。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>Braid - 一个发人深思的游戏</h2>

    <p><img src="http://www.yinwang.org/images/braid1.png" alt=""></p>

<p>我已经很久很久没有打游戏了（如果不算 Angry Birds 之类用来打发时间的游戏的话）。我的最后一个真正意义上的游戏机，是 PlayStation 1。在那上面，我真正欣赏的最后一个游戏，是 [Metal Gear Solid (1)]。</p>

<p>我曾经是一个游戏迷，可是进入了计算机专业的学习之后，我就开始失去对游戏的兴趣，基本上每玩一个都让我失望一次，不管别人把它吹的多么“经典”。不知道为什么，别人玩得津津有味的游戏，我玩一会儿就把它里面的“公式”都看透了。我清楚地知道这游戏的设计者是怎么在“耍我”，在如何想方设法浪费我的时间。同样的，别人看得津津有味的小说和电影，我经常一看开头就能猜到它要怎么发展，以至于一路猜到结局，索然无味。所以我基本上不去影院看最新的电影。我宁愿在网上看一些几十年前的老电影。我貌似只喜欢那些能让我“猜不透”的东西。</p>

<p>Braid，就是这样一个让我没猜得透的游戏。</p>

<p>这是一个同事推荐的。本来已经对电玩完全失望的我，破例的从 App Store 买了来。玩过之后觉得真的很不错，有一种所谓的“mind blowing”的感觉。以至于我花了两整天时间，废寝忘食，把它给打通关了。</p>

<p>Braid 的主体结构，和最古老的“超级玛丽”没什么两样。一个小人，可以跑，可以跳。一些小怪物，跑来跑去的。你可以跳起来踩它们。</p>

<p>最终的目标，是收集到所有的拼图，然后把它们组合成图片。组合图片是很容易的事情。游戏的难度其实在于如何拿到这些拼图。它们有可能被挂在很高的地方，或者被门挡住。</p>

<p>可是这有什么值得一提的呢？这游戏很不一样的地方是，它给你提供了几种绝无仅有的“超能力”，而且把它们与谜题结合得几乎天衣无缝。</p>

<p>你有三种超能力：</p>

<ol>
<li>逆转时间的能力</li>
</ol>


<p>在任何时候按下 Shift 键，游戏的时间就会逆转，“undo”之前的所有动作。即使你死了，都是可以复活的。死去的小怪物们也会复活。可是就算这样，有些拼图还是很难拿到。</p>

<p>值得一提的是，时间逆转的时候，画面是流畅无缺损的，连爆炸场面都会“收缩”。更令人赞叹的是，游戏的背景音乐也会同步逆转。如果在时间逆转的时候按“上”，“下”键，就可以调整时间“快退”和“快进”的速度。当然，此时的场景就像录像机在快退或者快进。</p>

<ol>
<li>产生“多重现实”的能力</li>
</ol>


<p><img src="http://www.yinwang.org/images/braid-shadow.jpeg" alt=""></p>

<p>在某些章节，你可以实现“多重现实”。做一个动作，然后按 Shift 键让时间逆转，当你停止逆转的时候，你的影子就会开始“redo”刚才的那段“历史”。而这个时候你可以做一些不同于以前的事情。这就好像有两个世界，一新一旧，从“历史的分叉点”开始，同步交汇。</p>

<p>你必须掌握好时间才能跟影子合作，因为影子的行动速度是不受你的“现场控制”的，它只是按部就班的重演你 undo 掉的历史。</p>

<ol>
<li>扭曲时间的指环</li>
</ol>


<p><img src="http://www.yinwang.org/images/braid-ring.jpeg" alt=""></p>

<p>在某些章节，你会有机会使用一个魔法指环。把这个指环放在地上之后，它会在附近的球状空间中形成时间的“扭曲”。这有点像黑洞的原理。越是靠近指环的位置，时间流动越慢。而当你远离指环，时间就逐渐恢复正常。指环的巧妙使用，是解决这些章节谜题的关键。</p>

<p>同样的，音乐与指环的特异功能是完美配合的。当你靠近指环的时候，背景音乐就会出现相应程度的扭曲。有点像录音机卡带的感觉  :)</p>

<p>在解决了所有的谜题之后，我回味了一下，自己为什么欣赏 Braid。这也许是因为它符合一个优秀的，非低级趣味的游戏设计：屈指可数的简单规则，却可以组合起来，制造出许许多多的变化。</p>

<p>你只有3种超能力，但是如何利用和“组合”这些超能力，却形成了解决谜题的关键。有些题目很有点难度，以至于你会希望有第4种超能力出现，或者希望捡到别的什么“法宝”。可是它们是不存在的。你必须使用那仅有的3种能力，加上巧妙的思索，细心的观察，才能达到目的。在解决了一个很难的谜题之后，你往往会一拍脑袋：哇，我怎么一开头没想到！</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>什么是语义学</h2>

    <p><img src="http://www.yinwang.org/images/semantics.jpeg" alt=""></p>

<p>很多人问我如何在掌握基本的程序语言技能之后进入“语义学”的学习。现在我就简单介绍一下什么是“语义”，然后推荐一本入门的书。这里我说的“语义”主要是针对程序语言，不过自然语言里的语义，其实本质上也是一样的。</p>

<p>一个程序的“语义”通常是由另一个程序决定的，这另一个程序叫做“解释器”(interpreter)。程序只是一个数据结构，通常表示为语法树(abstract syntax tree)或者指令序列。这个数据结构本身其实没有意义，是解释器让它产生了意义。对同一个程序可以有不同的解释，就像上面这幅图，对画面元素的不同解释，可以看到不同的内容（少女或者老妇）。</p>

<p>解释器接受一个“程序”(program)，输出一个“值”(value)。用图形的方法表示，解释器看起来就像一个箭头：程序 ===> 值。这个所谓的“值”可以具有非常广泛的含义。它可能是一个整数，一个字符串，也有可能是更加奇妙的东西。</p>

<p>其实解释器不止存在于计算机中，它是一个很广泛的概念。其中好些你可能还没有意识到。写 Python 程序，需要 Python 解释器，它的输入是 Python 代码，输出是一个 Python 里面的数据，比如 42 或者“foo”。CPU 其实也是一个解释器，它的输入是以二进制表示的机器指令，输出是一些电信号。人脑也是一个解释器，它的输入是图像或者声音，输出是神经元之间产生的“概念”。如果你了解类型推导系统 (type inference)，就会发现类型推导的过程也是一个解释器，它的输入是一个程序，输出是一个“类型”。类型也是一种值，不过它是一种抽象的值。比如，42 对应的类型是 int，我们说 42 被抽象为 int。</p>

<p>所以“语义学”，基本上就是研究各种解释器。解释器的原理其实很简单，但是结构非常精巧微妙，如果你从复杂的语言入手，恐怕永远也学不会。最好的起步方式是写一个基本的 lambda calculus 的解释器。lambda calculus 只有三种元素，却可以表达所有程序语言的复杂结构。</p>

<p>专门讲语义的书很少，现在推荐一本我觉得深入浅出的：《<a href="https://dl.dropbox.com/u/392085/PLLC.pdf">Programming Languages and Lambda Calculi</a>》。只需要看完前半部分（Part I 和 II，100来页）就可以了。这书好在什么地方呢？它是从非常简单的布尔表达式（而不是 lambda calculus）开始讲解什么是递归定义，什么是解释，什么是 Church-Rosser，什么是上下文 (evaluation context)。在让你理解了这种简单语言的语义，有了足够的信心之后，才告诉你更多的东西。比如 lambda calculus 和 CEK，SECD 等抽象机 (abstract machine)。理解了这些概念之后，你就会发现所有的程序语言都可以比较容易的理解了。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>我和权威的故事</h2>

    <p>每个人小时候心里都是没有权威的，就像每个人小时候也都不相信广告一样。可是权威就像广告，它埋伏在你的潜意识里。听一遍不信，听两遍不信，……，直到一千遍的时候，它忽然开始起作用了，而且这作用越来越强。</p>

<p>消灭广告所造成的幻觉，最好的办法就是去尝试，去实地的考察它。有些虚幻的东西只要你第一次尝试就会像肥皂泡一样破灭掉。可是如果你不主动去接触它，它就会一直在你脑海里造成一种美好神圣的假象。越是得不到的越是觉得美好。很神奇的一个现象就是，权威对人思想的作用其实也跟广告一样。</p>

<p>上大学以前的人因为没有专业，所以还不怎么崇拜权威，大不了追追歌星，影星，球星啥的。而进了大学之后，就会开始对本领域的权威耳濡目染。一遍，两遍，一千遍的听到同学们仰慕某“牛人”或者“大师”的名字，虽然从来没亲身见过，不知不觉就对这人产生了崇拜心理，然后自愧不如。不知不觉的，自己也开始附和这些说法，不自觉地提到这些大师的名字，引用他们说的话作为自己的行动指南。</p>

<p>Donald Knuth, Dennis Ritchie, Ken Thompson, Rob Pike, ... 就是通过这些途径成为了很多计算机学生的权威。以至于几十年以后，他们的一些历史遗留下来的糟糕设计和错误思想还被很多人奉为神圣。</p>

<h3>Donald Knuth</h3>

<p>很多人（包括我）都曾经对 Knuth 和他的 The Art of Computer Programming (TAOCP) 极度崇拜。在我大学和研究生的时候，有些同学花了不少钱买回精装的 TAOCP 全三卷，说是大概不会看，但要供在书架上，镇场子。当时我本着“书非借不能读也”的原则，再加上搬家的时候书是最费力气的东西，所以坚决不买书。我就从图书馆把 TAOCP 借了来。说实话我哪里看的下去啊？那里面的程序都是用一个叫 MIX 的处理器的汇编语言写的。一个字节只有6位，每位里面可以放一个十进制数（不是二进制）！还没开始写程序呢，就开始讲数学，然后就是几十页的公式推导，证明…… 接着我就睡着了。但我总是听说有人真的看完过 TAOCP，然后就成为了大师。比尔盖茨也宣称：“要是谁看完了 TAOCP，请把简历投给我！” 在这一系列的号召和鼓吹之下，我好几次的把 TAOCP 借回来，下定决心这次一定看完这旷世奇书。每次都是雄心勃勃的开始，可从来就没看完过开头那段 MIX 机器语言和数学公式。</p>

<p>看不懂 TAOCP 总是感觉很失败，因为看不懂 TAOCP 就成不了“大师”，可我仍然认为 Knuth 就是计算机科学的神，总能从他那学点什么吧，所以又开始折腾他的其他作品。这就是为什么我开始用 TeX，并且成为中国 TeX 界的主要“传教士”之一。为了 TeX，我把 Knuth 的 TeXbook 借回来，从头到尾看了两遍，做完所有的习题，包括最难最刁钻的那种“double bend”习题。接着又开始看 MetaFont Book，开始使用 MetaPost 进行绘图。开头还挺有成就感，可是不多久就发现学会的那些 TeX 技巧到了临场的时候就不知道该怎么用，然后就全都忘记了。这就是为什么我把 TeXbook 看了两遍，可是看完第二遍之后不久还是忘记得一干二净。</p>

<p>师兄师姐看到我用 TeX，说怎么折腾这么过时的玩意儿。我很气愤他们以及国内学术界居然都用 Word 排版论文，就开始针锋相对，写出一系列煽动文章鼓吹 TeX 的种种好处，打击“所见即所得”这种低智商玩意儿。这还不够，又开始折腾 Knuth 设计的 MMIX 处理器，并且认为 MMIX 的寄存器环就是世界上最先进的设计。发现一些无关紧要的小错，就给 Knuth 发 email，居然拿到两张传说中的“Knuth 支票”，并且一度引以为豪。当然像所有拿到 Knuth 支票的人一样，你是不会去兑现它的，甚至有人把它们像奖状一样放在相框里。我还没那么疯狂，那两张支票一直在它们原来的信封里。多年以后我到美国想兑现那支票的时候，发现它们已经过期了。</p>

<p><img src="http://www.yinwang.org/images/knuth-checks.jpg" width="80%"></p>

<p>当你心里有了这样的权威，其他人的话你是不可能听得进去的，就算他们其实比你心目中的权威更具智慧也一样。在清华的时候我有时候去姚期智的小组听客串讲座。有一次请来了美国某大学一个教授讲算法，不知道怎么的我就跟他聊起 TAOCP，大概是想请教他如何学习算法。他跟我说 Knuth 的书已经比较过时了，你可以看看 MIT 的那本《算法导论》。可是这位教授的名气怎能和 Knuth 相比，这话我恁是没有听进去，仍然认为 TAOCP 隐藏了算法界最高的机要，永恒的珍宝。</p>

<p>在清华的时候我很喜欢一门叫做“计算几何”的课，就经常跟那门课的老师交流思想。有一次我在 email 里面提到 Donald Knuth 是我的偶像，那位老师很委婉的回复道：“有偶像很好啊，Knuth 也曾经是我的偶像。” 我对“曾经”这两个字感到惊讶：难道这意味着 Knuth 现在不是他的偶像了？在我执意的询问之下他才告诉我，其实世界上还有很多更聪明的人，Knuth 并不是计算机科学的一切。你应该多看看其他人的作品，特别是一些数学家的。然后他给了我几个他觉得不错的人的名字。</p>

<p>现在回想起来，这些话对我是有深远作用的。那位老师虽然在系里的“牛人”们眼里是个研究能力（也就是发 paper 能力）不强的人，但是他却对我的人生转折有着强有力的作用。他引导了我去追寻自己真正的兴趣，而不是去追寻虚无的名气。我发现很多人都在为着名气而进行一些自己其实不感兴趣的事情，去做一些别人觉得“牛气”的事情。我真希望他们遇到跟我一样的好老师。</p>

<p>在现在看来，Knuth 的 TAOCP 就是所谓的“神圣的白象”（white elephant）。大家都把它供起来，其实很少有人真的看过，却要显得好像看过一样，并且看得津津有味。这就让试图看懂它的人更加自卑和着急，甚至觉得自己智商有问题。别人都看过了，我怎么就看不懂呢？其实 TAOCP 里面的大部分算法都不是 Knuth 自己设计的，而且他对别人算法的解释经常把简单的问题搞得很复杂。再加上他执意要用汇编语言，又让程序的理解难度加倍。</p>

<p>有一句话说得好：“跟真正的大师学习，而不是跟他们的徒弟。”如果你真的要学一个算法，就应该直接去读那算法的发明者的论文，而不是转述过来的“二手知识”。二手的知识往往把发明者原来的动机和思路都给去掉了，只留下苍白无味，没有什么启发意义的“最后结果”。确实是这样的，多年以后当我看见 Knuth 计划中的几卷新的 TAOCP 的目录时，发现其中大部分的东西我已经通过更容易的方式学到了，因为我找到了这些知识的源头。</p>

<p>所以之前的那位访问清华的教授说的其实是实话，Knuth 真的落伍了，可是就算在美国也少有人知道或者承认这个情况。有一次看一个对世界上公认最厉害的一些程序员的采访，包括总所周知的一些大牛，以及 ML 的设计者 Robin Milner，Haskell 的设计者之一 Simon Peyton Jones 等人。也不知道采访者是什么心理，在对每个人的采访中他都问，你看过 TAOCP 吗？大部分人都说看过，真是了不起的巨著，很重要啊云云。只有 Robin Milner （如果我没记错的话）比较搞笑，他说我希望我看过，但是可惜实在没时间。我一直把 TAOCP 垫在我的显示器下面，这样我工作时就可以一直看着它们 :)</p>

<p>Knuth 说“premature optimization is the root of all evil”，然而他自己却是非常喜欢用 premature optimization 的人。他的代码里到处是莫名其妙的小聪明，小技巧。把代码弄得难懂，实际上却并没有得到很多性能的提高。有一次看 MMIX 处理器的模拟程序，发现他用来计算一个寄存器里的“1”的个数的代码非常奇怪。本来写个循环，或者用那种从末位减 1 的做法就可以了，结果他的代码用了 Programming Pearls 里面一个古怪的技巧，费了我半天时间才看懂，后来我发现这个技巧其实还不如最简单的方法。就是这些细小却又蹊跷的做法，使得 Knuth 的代码用细节掩盖了全局，所以到最后我其实也没从大体上搞懂一个处理器的模拟器应该如何工作。直到后来到 Indiana 学习了程序语言的理论之后我才发现，其实处理器模拟器（以至于处理器本身）的工作原理很简单，因为它就是一个机器代码的<a href="http://www.yinwang.org/blog-cn/2012/08/01/interpreter">解释器</a>。使用跟高级语言解释器同样的结构，你可以比较容易的写出像 MMIX 模拟器那样的东西。</p>

<p>Knuth 最重要的一个贡献恐怕是程序语言的 parsing （语法分析），比如 <a href="http://en.wikipedia.org/wiki/LR_parser">LR parsing</a>，然而 parsing 其实是一个基本不存在的人造问题。它的存在是因为人们的误解，以为程序语言需要有跟人类语言一样的语法，所以把程序语言搞得无端的复杂和困难。如果你把语法简化一下，其实根本用不着什么 LR，LALR。我最近给我自己设计的语言写了一个 parser ，从头到尾只花了两个小时，500 行 Java 代码，包括了从 lexer 一直到 AST 数据结构的一切。完全手写的代码，根本没用任何复杂的 parsing 技术和 YACC 之类的工具，甚至正则表达式都没有用。之所以可以这样，因为我的语法设计让 parsing 极其容易，比 Lisp 还要容易。Knuth 过度的强调了 parsing。他的误导使得很多人花了几十年时间来研究 parser，到现在还在不时地提出新的技术，用于设计更加复杂的<a href="http://www.yinwang.org/blog-cn/2013/03/08/on-syntax">语法</a>。何必呢？这只会让程序员和编译器都更加痛苦。如果这些人把时间都花在真正的问题上，那今天的计算机科学不知道要美好多少。</p>

<p>几乎每一本编译器教材都花大量篇幅来讲述 DFA, NFA, lexing, LL, LR, LALR…… 几乎每个学校的编译器课程都会花至少 30% 的时间来做 parser，折腾 LEX，YACC 等工具，而对于编译器真正重要的东西却没有得到很多的训练。这就是为什么 <a href="http://www.yinwang.org/blog-cn/2013/03/28/chez-scheme">Kent Dybvig 的编译器课程</a>如此有效，因为 Scheme 的语法非常简单，我们根本没有花时间来做 parser。我们的时间用在了思考真正的问题：做优化，实现尾递归，高阶函数…… 很多语言梦寐以求却又做不好的东西。这样的课程给了我可以发挥自己潜力的余地，我的课程编译器里面具有大量的独创写法，我的 X64 机器代码生成器生成极其短小的代码，让 Kent Dybvig 都在背地里琢磨是怎么回事。这些东西到现在也许仍然是世界上最先进的技术。</p>

<p>一个人的思维方式似乎决定了他设计的所有东西。Knuth 的另一个最重要的发明，文学编程（Literate Programming）其实也是多此一举，制造麻烦。文学编程的错误在于认为程序语言应该像人类语言，应该适应所谓的“人类思维”。然而程序语言却是在很多方面高于人类语言的，它不应该受到人类语言里的糟粕的影响。把程序按照 Knuth 的方式分开在不同的文章段落里，造成了代码之间的关系很难搞清楚，而且极其容易出错。这个错误与“Unix 哲学”的错误类似，把程序作为一行一行的文本，而不是一个像电路图一样的数据结构。我不想在这里细说这个问题，对此我专门写了一篇<a href="http://yinwang0.wordpress.com/2011/05/18/literate-programming">文章</a>，讲述为什么文学编程不是一个好主意。</p>

<p>TeX 其实也是异常糟糕的设计。它过度的复杂，很少有人搞得懂怎么配置。经常为了一个简单的效果折腾很久，然后不久就忘了当时怎么做的，回头来又得重新折腾。原因就是因为 TeX 的设计缺乏一致性，特殊情况太多，而且组合（compose）能力很差。所以你需要学太多东西，而不是跟象棋一样只需要学习几个非常简单的规则，然后把它们组合起来形成无穷的变化。</p>

<p>在程序语言设计者看来，TeX 的语言是世界上最恶劣的设计之一，但如果没有这个语言，它也许会更加糟糕。其实 TeX 之所以有一个“扩展语言”，有一个鲜为人知的小故事。在最早的时候 Knuth 的 TeX 设计里并没有一个语言。它之所以有一个语言是因为 Scheme 的发明者 Guy Steele。Knuth 设计 TeX 的那个时候 Steele 碰巧在斯坦福实习。他听说 Knuth 要设计一个排版系统，就建议他设计一个语言，以应付以后的扩展问题。在 Steele 的强烈建议和游说之下，Knuth 采纳了这个建议。可惜的是 Steele 并没能直接参加语言的设计，在短短的一个夏天之后就离开了斯坦福。</p>

<p>Knuth 的作品里面有他的贡献和价值，TeX 的排版算法（而不是语言）也许仍然是不错的东西。可是如果因为这些好东西爱屋及乌，而把他所推崇的那些乱七八糟的设计当成神圣的话，那你自己的设计就逃脱不出同样的思维模式，让简单的事情变得复杂。仍然对 TeX 顶礼膜拜的人应该看一下 <a href="http://www.texmacs.org">TeXmacs</a>，看看它的作者是如何默默无闻的，彻彻底底的超越了 TeX 和 Knuth。</p>

<p>在我看来，Knuth 是个典型的精英主义者，他觉得自己做的都是最好，最有“格调”的。他利用自己的权威和特立独行来让用户屈服于自己繁复的设计，而不是想法设计出更加易用的工具。TeX 的版本号每次更新都趋近于圆周率π，意思是完美，没有 bug。他奖励大额的支票给发现 TeX 代码里 bug 的人，用于显示自己对这些代码的自信，然而他却“冰封”了 TeX 的代码，不再填加任何新东西进去，也不再简化它的设计。当然了，如果不改进代码，自然就不会出现新的 bug，然而它的设计也就因此固步自封，停留在了几十年以前。更奇怪的是，“TeX”这个词居然不按照正常的英语发音逻辑读成"teks"。每当有人把它“读错”，就有“高手”打心眼里认为你是菜鸟，然后纠正：“那个词不读 teks，而要读‘特喝’，就像希腊语里的 chi，又像是苏格兰语的 loch，德语的 ach，西班牙语的 j 和俄语的 kh。”也许这就叫做附庸风雅吧，我是纯种的欧洲人！;-) 当一个软件连名字的发音都这么别扭，这么难掌握，那这个软件用起来会怎样？每当你提到 TeX 太不直观，就有人跟你说：“TeX 是所想即所得，比你的所见即所得好多了！”可事实是这样吗？看看 TeXmacs 吧，理解一下什么是“所见即所得+所想即所得”二位一体。</p>

<p>我跟 Knuth 的最后一次“联系”是在我就要离开清华的时候。我从 email 告诉他我觉得中国的研究环境太浮躁了，不是做学问的好地方，想求点建议。结果他回纸信说：“可我为什么看到中国学者做出那么多杰出的研究？计算机科学不是每个人都可以做的。如果你试了这么久还不行，那说明你注定不是干这行的料。”还好，我从来没有相信他的这段话，我下定了决心要证明这是错的。多年的努力还真没有白费，今天我可以放心的说，Knuth 你错了，因为我已经在你引以为豪的多个方面超过了你。</p>

<h3>Unix</h3>

<p>Unix 的创造者们是跟 Knuth 非常类似的权威，他们在我的心目中也曾经占据了重要的位置，以至于十年前我写了一篇文章叫《完全用 Linux 工作》，大力鼓吹 Unix 的“哲学”，甚至指出 Linux 不能做的事情就是不需要做的，并且介绍了一堆难用的 Unix 工具，引得很多人去折腾。可如果你知道我现在对 Unix 的态度，肯定会大吃一惊，因为在经过努力之后，我成功的“忘记”了 Unix 的几乎一切，以至于本科刚毕业的学生都会以为我是脑盲，并且以为可以在我面前炫耀自己知道的 Linux 技巧。他们不会明白，在我心里 Unix/Linux 的设计是计算机软件界目前面临的大部分问题的罪魁祸首，而他们显示给我看的，只不过是 Unix 的思想和精英主义给程序员造成的精神枷锁。其实我并不会忘记 Linux 的设计，但我已经下意识的以熟悉 Linux 的奇技淫巧为耻，所以很多时候我即使知道也要装作不知道。因为我是机器的主宰，而不是它的奴隶，所以我总是想办法让机器去帮我做更多的事，帮我记住那些无聊的细节，而不是去顺从它的设计者所谓的“哲学”。</p>

<p>评论 Unix 和它的后裔们总是一件尴尬的事情，因为你提到它们的任何一个缺点，都会被很多人认为是优点。GNU 的含义是“GNU is Not Unix”，但很可惜的是 GNU 和 Linux 的设计从来没有摆脱过 Unix 思想的束缚。Unix 的内存管理，进程，线程，shell，进程间通信，文件系统，数据库…… 几乎都是很蹩脚的设计。所谓的“Unix 哲学”，也就是进程间通信主要依靠无结构字符串，造成了一大批过度复杂，毛病众多的工具和语言的产生：AWK，sed，Perl，…… Unix 的内存管理是按“页”而不是按“结构”分配，相当于把内存分配的任务完全推给应用程序。而且允许任意的指针操作，这就像给每个老百姓一把爱走火的枪。可是又想要“安全”，自相矛盾。没办法，不得不强制进程数据空间完全隔离，使得进程间无法直接传递数据结构。进程和线程上下文切换开销过大，造成了使用大规模并发或者分布式计算的瓶颈，导致了 goroutine 和 node.js 等“变通方法”的产生。把数据无结构的存储在文件里，无法有效的查找数据，造成了关系式数据库等过度复杂的数据解决方案的产生。再加上后来 WEB 的设计，现在的网站基本上就是补丁加补丁，一堆堆的 hack。</p>

<p>“Unix 哲学”貌似也有好的部分，比如“每个程序只做一件事，多个程序互相合作。”然而，这个所谓的哲学其实就是程序语言（比如 Lisp）里面的模块化设计。它当然是好东西，然而这些思想被 Unix 偷来之后，有其名而无其实。很少有 Unix 程序真正只做一件事的，而且由于字符串这种通信机制的不可靠，它们之间其实不能有效地合作。有时候你换了一个版本的 make 或者 sed 之类的工具，你的 build 就莫名其妙的出问题。这就是为什么有的公司请了专门的所谓“build engineer”，因为高级别的程序员不想为这些事情操心。Lisp 程序员早就明白这个道理，所以他们尽一切可能避免使用字符串。他们设计了 S 表达式，用于结构化的传输数据。实际上 S 表达式不是“设计”出来的，它是每个人都应该首先想到的，最简单的可以表示树结构的编码方法。Lisp 的设计原则里面有一条就是：Do not encode。它的意思是，尽量不要把有用的数据编码放进字符串。Unix 的世界折腾来折腾去，XML，CORBA，…… 最后才搞出个 JSON，然而其实 JSON 完全不如 S 表达式简单和强大。Unix 就像一个脑瘤，它让人们放着最好的解决方案几十年不用，不断地设计乌七八糟的东西用来取代乌七八糟的东西。这些垃圾对人有很大的洗脑作用。前段时间我说 S 表达式比 JSON 简单，有人居然跟我说 JSON 好些，因为它结构的 field 是“无顺序”的。这让我相当无语，因为一个编码方式有没有顺序完全取决于你如何解释它。从这个意义来讲，S 表达式可以是有顺序，也可以是没有顺序的。</p>

<p>Unix 喜欢打着“自由”和“开源”的旗号，可是它的历史却充满了政治，宗教，利益冲突和对“历史教科书”的串改。几乎所有操作系统课本的前言都会提到 Unix 的前身 Multics，而提到 Multics 的目的，都是为了衬托 Unix 的“简单”和伟大，接下去基本上就是按部就班的讲 Unix 的设计，仿佛 Unix 就是世界上唯一的操作系统一样。 课本会告诉你，Multics 由于设计太复杂，试图包罗万象，最后败在了 Unix 手下。可是如果你仔细了解一下 <a href="http://www.multicians.org/myths.html">Multics</a> 的历史，就会发现最后一台 Multics 机器直到 2000 年还在运行，拥有 Unix/Linux 到现在还没有的先进而友好的特性，并且被它的用户所爱戴。Multics 的设计并不是没有问题（对比一下 Lisp Machine 和 <a href="http://www.yinwang.org/blog-cn/2013/03/07/oberon">Oberon</a>），但是相比之下，Unix 的设计一点都不简单。Unix 抄了 Multics 最好的一些思想，有些没有抄得像，然后又引入了很多自以为聪明的糟粕。可是 Unix 靠着自己病毒一样的特征，迅速占领了市场。Unix 最开头是开源和免费的，但是后来 AT&amp;T 发现这里面有利可图，所以就收回了使用权，并且开始跟很多人打官司。AT&amp;T 的邪恶比起微软来，真是有过之而无不及。</p>

<p>Unix 的很多设计是如此龌龊，很多人却又由于官僚的原因不得不用它。以至于 Unix 出现的早期怨声载道，有人甚至组织了一个 mailing list 叫“<a href="http://www.mindspring.com/~blackhart">Unix 痛恨者</a>”(Unix Haters)。你很有可能把这些人当成菜鸟，可是这些人其实都用过更好的操作系统，有的甚至设计实现过更好的操作系统甚至程序语言。最后他们的叫骂声被整理为一本书，叫做 <a href="http://web.mit.edu/~simsong/www/ugh.pdf">Unix Hater's Handbook</a>。让人惊讶的是，这本书有一个“<a href="http://www.popsci.com/technology/article/2011-10/thank-you-dennis-ritchie-without-whom-none-would-be-here">反序言</a>” (anti-foreward)，作者正是 Unix 和 C 语言的设计者之一，Dennis Ritchie。这个反序言说，Unix 这座设计缺乏一致性的监狱会继续囚禁你们，聪明的囚犯会从它里面找到破绽，可惜的是自由软件基金会（FSF）会建造跟它完全兼容的监狱，只不过功能多一些。拥有三个 MIT 学位的记者，微软的研究员，Apple 的高级科学家可能还会对这座监狱的“规矩”贡献一些文字。从这些文字里，我看到了一个炫耀武力的暴君，看到了赤裸裸的权威主义和教条主义。</p>

<p>可惜的是在软件的世界里任何糟糕的设计都可以流行，只要你的广告做得好，只要你的传教士够多。一知半解的人（比如十年前的我）最喜欢到处寻找“新奇”的东西，然后开始吹嘘它们的种种好处，进而成为它们的布道者。再加上大学计算机系的“紧跟市场”的传统，不幸的事情发生了：Unix 和它的后裔们几乎垄断了服务器操作系统的市场。由于 Unix 的垄断，现在的软件世界基本上建立在一堆堆的变通之上，并且固化之后成为了“<a href="http://www.yinwang.org/blog-cn/2013/04/14/terminology/">珍珠</a>”。公司里，学校里，充满了因为知道一些 Unix 的“巧妙用法”而引以为豪的人，殊不知他们知道的只是回避一些蹩脚设计的小计俩。程序员有太多的特例和细节需要记忆，不但不抱怨，还引以为豪。很少有人想过如何从根本上解决问题，历史的教训很少有人吸取，以至于几十年前犯过的设计错误还在重现。Unix 的最大贡献，恐怕就是制造了大量的工作岗位—因为问题太多太麻烦，所以需要大量的人力来维护它的运行。</p>

<p>现在看来，Unix 当初就是依靠《皇帝的新装》里织布工的办法封住了大家的嘴。皇帝的织布工们说：“愚蠢或者不称职的人都看不见这件衣服。”Dennis Ritchie 说：“Unix 是简单的，但只有天才才能理解这种简单。”看出来了吗？你不敢说 Unix 的设计太乱太复杂，因为这话一出口，立马会有人引用 Dennis 的话说，是你自己不够天才，所以不理解。当然了，这就意味着他比你聪明，因为只有天才才能理解这种简单嘛。哎，这种喜欢显示自己会用某种难用工具的人实在太多了。你不敢批评这些工具对用户不友好，因为你立即会被鄙视为菜鸟。</p>

<p>Dennis Ritchie 去世了。死者长已矣，可是有些他的崇拜者在那个时候还要煽风点火，拿他的死与 Steve Jobs 的死来做对比，把像这样的<a href="http://uberhumor.com/good-comparison-steve-jobs-vs-dennis-ritchie">照片</a>四处转帖，好像 Steve 死错了时间，抢了 Dennis 的风头似的。然后就有人写一些这样的<a href="http://www.wired.com/wiredenterprise/2011/10/thedennisritchieeffect">文章</a>，把世界上的所有系统，所有语言都归功到 Dennis 和 Unix 身上。看到这些我明白了，所谓的“天才”就是这样被造出来的。在我看来这些是很滑稽的谬论，就像是在说有人拿一把很钝的剪刀做出了一件精美的衣服，所以这剪刀立下了汗马功劳。其实这人一边裁布一边在骂这剪刀，心想妈的这么难用，快点做出这衣服，卖了钱买把好点的！</p>

<p>用了这么久 Apple 的产品，平心而论，虽然它们并不完美，然而它们并不是 Unix 的翻版，它们做出了摆脱 Unix 思想束缚的努力。它们本着机器为人服务的原则，而不是把人作为机器的奴隶。Mac 的很多内部设计跟 Unix 有着本质的不同。然而就是这样的系统，被 Dennis Ritchie 在他的<a href="http://www.popsci.com/technology/article/2011-10/thank-you-dennis-ritchie-without-whom-none-would-be-here">反序言</a>里面蔑称为“以 Sonic the Hedgehog 作为智力主题和交互设计基础的系统”。</p>

<p>有谁知道，在那同样一段时间里，Lisp 的发明者 John McCarthy，ML 的发明者 Robin Milner，都相继去世了呢？那个时候我只是在 mailing list 看到有人发来简短的消息，然后默默地思念他们给我带来的启迪。我们没有觉得 Steve Jobs 的死抢了他们的风头，因为他们不需要风头。死就是要安安静静的，让知己者默哀已经足矣。出现这种事情恐怕不能怪 Dennis Ritchie 自己，然而这些 Unix 的崇拜者们，真的应该反省一下自己的做法了。</p>

<p>Unix 的设计者们曾经在我的心里占据了一席之地，可是现在觉得他们其实代表了反动的力量，他们利用自己的影响力让这些糟糕的设计继续流传，利用人们的虚荣心，封住大部分人的嘴，形成教条主义，让你认为 Unix 的设计是必须学习的东西。很多人成为了 Unix 的传教士和跟屁虫，没有什么真实水平，就会跟着瞎起哄，把 Unix 设计者的话当成教条写进书里。可是他们的权威和名气是如此之大，让我在很多人面前只能无语。</p>

<h3>Go 语言</h3>

<p>现在，同样这帮 Unix “大牛”们设计了 Go 语言，并且依仗自己的权威和 Google 的名气大力推广。同样的这帮跟屁虫开始使用它，吹捧它，那气势就像以为 Go 可以一统天下的样子。真正的程序语言专家们都知道，Go 的设计者其实连语言设计的门都没摸到。这不是专家们高傲，他们绝不会鄙视和嘲笑一个孩子经过自己的努力做出一个丑陋的小板凳。他们鄙视，他们嘲笑，因为做出这丑陋小板凳的不是一个天真的小孩，而是一些目空一切的人，依仗着一个目空一切的公司。他们高举着广告牌，试图让全人类都坐这样丑陋的板凳。</p>

<p>跟当年设计 Unix 时一个德行，不虚心向其它语言和系统学习经验教训，就知道瞎猜瞎撞。自己想个什么就是什么，但其实根本就不知道自己在干什么。把很多语言都有的无关紧要的功能（比如自动格式化代码）都吹嘘成是重大的发明，真正重要的东西却被忽略。Go 语言的设计在很多方面都是历史的倒退，甚至犯下几乎所有其他语言都没有的<a href="http://conscientiousprogrammer.com/blog/2013/10/31/surprised-by-the-go-programming-languages-treatment-of-nil">低级错误</a>。在语法上大做花样，却又搞得异常丑陋，连 C 和 Java 都不如。自己不理解或者实现难度大点的东西就说是不需要的，所以连很多语言支持的 parametric type（类似 Java generics）都没有，以至于没法让程序员自定义通用数据结构，只好搞出一堆特例（比如 map，make，range）来让程序员去记。这些做法都跟 Unix 如出一辙。</p>

<p>Go 语言最鲜明的特征就是 goroutine，然而这个东西其实每个程序语言专家都知道是什么。有些语言比如 Scheme 和 ML 提供了 first-class continuation（call/cc），可以让你很容易实现像 goroutine 这样的东西，甚至实现硬件中断的“超轻量线程”。至于 Go 那种“基于接口”的类型系统设计，我在很多年前就已经试验过，并且寄予了很大的希望。结果最后经过很多的研究和思索后发现有问题，于是放弃了这个想法。很显然，我不是第一个在这个问题上失败的人，很多语言专家在使用 parametric type 以前都试图过做这种基于接口的设计，结果最后发现不是什么好东西，放弃了。然而 Go 的设计者却没有学到这些失败教训，反而把它当成宝贝。一个很显然的问题是，在 Go 里面你经常会需要使用“空接口”（interface{}），用来表示所有类型。这就像使用 C 的 void 指针一样，有着静态类型系统的麻烦，却失去了静态类型系统的好处。</p>

<p>每当你提到 Go 没有 parametric type，Go 的拥护者们就说“我看不到这有什么用处”，就像一些非洲土著跟你说“我看不到鞋子有什么用处”一样。他们利用人们对 Java 的繁复和设计模式的仇恨，让你抛弃了它里面的少数好东西。其实 Java generics 不是 Java 首先有的。它的主要设计者其实包括 Haskell 的设计者之一 Philip Wadler。这种 parametric type 很早就出现在 ML，Haskell 等语言里面，是非常有用的东西。</p>

<p>每当受到批评，Go 的拥护者们就托词说，Go 是“系统语言”（systems language）。这里潜在的前提就是，认为 Unix 就是唯一的“系统”，而 C 就是在 Go 以前唯一的“系统语言”，好像其他语言就写不出所谓的“系统”似的。而事实是，在 C 诞生十年以前，人们就已经在用  Algol 60 这样的高级语言来写操作系统了。由于先天不足却又大力推广，所以 Go 的很多缺陷基本已经没法修补了。这样的语言一旦流行起来就会像 Unix 一样，成为一个无休止的补丁堆。如果像 Java 或者 Haskell 这样的语言还值得批评的话，对 Go 语言的设计者我只能说，去补补课吧。</p>

<h3>Cornell</h3>

<p>可是权威和名气的威力还是很大的。虽然 Knuth 在我心目中的位置不再处于“垄断地位”，世界上可以占据我心里那个位置的人和事物还很多。在离开清华之后我申请了美国的大学。也许是天意也许是巧合，只有两所大学给了我 offer：Cornell 和 Indiana，而我竟然先后到了这两所大学就读。</p>

<p>说实话，Indiana 给了我比 Cornell 更好的 offer。Cornell 给我的是一个 TA 的半工读职位，而 Indiana 给我的是一个不需要工作白拿钱的 fellowship。说实话我从来没有搞明白 Cornell 这样的“牛校”怎么会给我这样的人 offer，GPA 一般，paper 很菜，而 Indiana 却是真正在乎我的。Indiana 的 fellowship 来自 GEB 的作者 Doug Hofstadter。他从 email 了解到我的处境和我渴求真知的愿望之后，毅然决定给我，一个素不相识的人写推荐信。后来我才发现那 fellowship 的资金也是他提供的。</p>

<p>可是 Indiana 和 Hofstadter 的名气哪里能跟 Cornell 的号称 “CS前五” 相比啊？Indiana 的 offer 晚来了几天。当收到 Indiana 的 offer 时，我已经接受了 Cornell。Hofstadter 很惊讶也很失望，因为他以为我一定会做他的学生，可是听说我接受了 Cornell 的 offer，他也不知道该怎么办。我只隐约的记得他告诉我，学校的排名并不是最重要的东西……</p>

<p>名气和权威的力量是如此之大，它让我不去选择真正欣赏我并且能给我真知的人。有时候回想起来，我当时真的是在寻找真知吗？我明白什么叫做真知吗？</p>

<p>Cornell 给了我什么呢？到现在想起来，它给我的东西恐怕只有教训，很多的教训。TA 的工作可不是那么好做的，基本就是苦力，你甚至会怀疑他们录取你就是为了利用你的廉价劳动力。我第一次做 TA 就是一个 200 多人在阶梯教室上的大课，教最基本的 Java 编程。虽然有好几个 TA，但任务还是很繁重。讲课的人不是教授，而是专职的讲师。这种讲师一般得靠本科生的好评来谋生，所以虽然在学术上没什么真本事，对学生真可谓是点头哈腰，服务周到。这就苦了各位 TA 了，作业要你设计，还要设计得巧妙，要准备好标准答案，之后还要批作业，批得你头脑麻木，考试要监考，之后还要批试卷。每周还得抽好几个小时来做 office hour，给学生答疑。然后你还有自己要上的课，自己的作业，自己的考试。每当考试的时候都很紧张，因为你得准备自己的考试，还要为学生的考试多做很多工作。</p>

<p>如果真的学到了东西，这么辛苦也许还值得，可是那些教授真的是想教会你吗？有人打了个比方，说 Cornell 说要教你游泳，就把你推到水池里，任你自己扑腾。当你就要扑腾上岸时，他在你头上用榔头一砸，然后继续等你上岸。当你再次快要扑腾上岸时，他又举起一块大石头扔到你头上，这样你就可以死了，可是 Cornell 仍然等着你游上岸…… 这就是对我在 Cornell 的经历的非常确切的比喻。</p>

<p>我在一篇老的博文里面提到过，Cornell 的学生，包括博士生，一上课就抄笔记，一天到晚都在赶作业。可其实 Cornell 不只是爱抄笔记的学生的天堂，而且是崇拜权威者的天堂。即使你不是那么的崇拜权威，你不可避免的会被一群像朝圣者一样的人围在中间，在你耳边谈论某某人多么多么的牛。不管你向同学打听哪一个教授，得到的回答总是：“哇，他很牛的！” 然后你就去上了他的几节课，觉得不咋的嘛，可是人家就说那是因为你不理解他的价值。这种气氛我好像在另一个地方感觉到过呢？啊对了，那是在 Google。这样的气氛也许并不是偶然，Cornell 的大部分 PhD 同学当时的最大愿望，就是毕业后能去 Google 工作。当然，后来 Facebook 上升成为了他们的首选。值得一提的是，Indiana 其实是更有个性的地方。我在 Indiana 的同学们一般都把去 Google 工作作为最后的选择之一。有一次一个刚来不久的学生问，如何才能进入 Google 工作？有个老教授说，那个容易，Google 招收任何能做出他们题目的人！</p>

<p><a href="http://abstrusegoose.com/212">
<img src="http://www.yinwang.org/images/those_who_know.png" width="80%"></a></p>

<p>Cornell 的研究可以用“与时俱进”来形容，什么热门搞什么。当时 Facebook 和社交网络正在“崛起”，所以系里最热门的一个教授就是研究社交网络的。我去听过他几堂课，他用最容易的图论算法分析一些社交网络数据，然后得出一些“理论”。其中好些结论实在太显然了，我觉得街上的卖菜大妈都能猜到，还不如研究星际争霸来得有意思点。可是 Facebook 名气之大，跟着这位教授必然有出路啦，再加上有人在耳边煽风点火，所以有好多的学生为做他的 PhD 挤破了头皮，被刷下来的就只好另投门路了。每次新来一个教授都会被吹捧上天，说是多么多么的聪明，甚至称为天才。然后就有一群的人去上他的课，试图做他的学生。结果人家每节课都是背对学生面朝黑板，喃喃自语，写下一堆堆的公式和证明，一堂课总共就没回过几次头。下面的人当然是狂抄笔记，有的人甚至带着录音笔，生怕漏掉一句话。上这样的课还不如干脆把板书打印出来让大家自己回家看。人多了竞争也就难免了。上课的同学们就开始勾心斗角，三国演义的战术都拿出来了。作业做不出来就来找你讨论，等你想讨论了就说自己也没做出来。没听懂偏要故作点头状，显得听懂了，让你觉得有压力。自己越是喜欢的教授就越是说他不咋的，扯淡，然后就自己去跟他。自己不喜欢的教授就告诉你他真是厉害啊，只可惜人家不要我。直到两年后我离开 Cornell 之前，还有好些同学因为没找到教授而焦头烂额。因为两年内没有找到导师的 PhD 学生，基本上等于必须退学。</p>

<p>当我离开 Cornell 之后，有一位国内的学生给我发 email 套磁（从系里主页上找到我的地址），问我 Cornell 情况如何。我告诉他我都已经走人了，并且告诉了他我的感觉，一天到晚抄笔记赶作业之类的。然后又问我一个刚毕业的 PhD 的情况，我说他水平不咋的，博士论文我看过了，很扯淡，解决一个根本不存在的问题。他对我说的话有点惊讶，但还是将信将疑。为了确保万无一失，他在 visiting day 的时候专程去 Cornell 考察了一下。回去又给我 email，说见到好多牛人啊，大开眼界，哪里像你说的那么不堪。还说跟那位 PhD 的导师谈过话，真是世界级的牛人那，他的博士论文也是世界一流的。我就无话可说了，仁者见仁，智者见智，随他去吧，哎。</p>

<p>结果两年之后，我又收到这位同学的 email，说他在 Cornell 还没找到导师，走投无路了，问我有没有办法转学。</p>

<h3>图灵奖</h3>

<p>说到这里应该有人会问这个问题，我是不是也属于那种没找到导师走投无路的人。答案是，对的，我确实没有在 Cornell 找到可以做我导师的人。然后我就猜到有人会说，就知道王垠水平不行嘛，没搞定导师，被迫退学，哈哈！可是事情其实没他们想象的那么简单。作为一个 PhD 学生，不仅必须精通学术，而且要懂得政治和行情。哦错了，其实不精通学术也行的，但是一定要懂得政治和行情！可是由于学生之间的窝里斗，他们之间的信息互通程度，是没法和教授之间的信息互通程度相比的。这就造成了“学生阶级”在这场信息战上的劣势，总是被动的被教授挑选，而不能有效地挑选适合自己的教授。</p>

<p>进入 Cornell 之后我上了一门程序语言的课，就开始对这些东西入迷。可是由于“与时俱进”，Cornell 的研究方向并不是那么平衡的发展的，其实是很畸形的发展。程序语言领域的专家们早已因为受到忽视而转移阵地，剩下一群用纸和笔做扯淡理论的。说实话，在历史上程序语言方向曾经是 Cornell 的强项，出现了一些很厉害的成果。可是当我在 Cornell 的时候，只剩下两个名不见经传的教员，一个助理教授，一个副教授。其实 Robert Constable 也在那里，可惜的是他做了 dean 之后已经没空理学生了，以至于我两年之后都不知道这个人的存在。我当时也不知道 Cornell 有过这段历史，看不到它的研究重心的移动趋势。</p>

<p>我不喜欢那个副教授搞的项目，大部分是在 Java 上面加上一些函数式语言早就有的功能。可是人家做的是热门语言，所以拉得到资金，备受系里亲睐，他的学生们也比较趾高气昂。初次见面的时候，我跟他的一个学生说了我的一个想法，他说：“你那也能叫研究吗？待会儿我给你看看什么是真正的研究！” 其实那只是我的一个微不足道的想法，我也没说那是研究啊。只是随便聊一下而已就这么激动 -_- 何况你们那些 Java 的东西能算是研究？我是不可能跟那样的人合作的，所以我就跟那个助理教授做了一点静态分析的项目。当然我们分析的也不是什么好东西，是用 Fortran 写的 MPI 程序。不过说实话，那个助理教授其实挺有点真知灼见，他有几句话现在仍然在指引我，防止我误入歧途。其中一句话是针对我对 π-calculus 的盲目崇拜 说的：“那些理论其实不管用的。最好是针对自己的问题，自己动脑筋想。” 他也是很谦虚很善良的人，可是好人不一定有好报的。后来他没有拿到 tenure 职位，不得不离开 Cornell 加入了工业界，而我就失去了最后一个有可能在程序语言方向做我的导师的人。</p>

<p>没办法，我就开始探索其它相关领域的教授，比如做数据库的，做系统的，看他们对相关的语言设计是否感兴趣。可惜他们都不感兴趣，而且告诉我程序语言领域太狭窄了。我当时还将信将疑，甚至附和他们的说法，可是现在我断定他们都是一知半解胡说八道。如果这些人虚心向程序语言专家请教，现在数据库和操作系统的设计也不会那么垃圾，关系式，SQL，NoSQL，…… 一个比一个扯淡。没有办法，我就开始探索其他的方向，开始了解图形学和数值分析等东西，进展很不错。可是终究我还是发现，我不喜欢图形学和数值分析所用的语言。我想制造出更好的程序语言来解决这些问题。可是跟教授们谈这些想法的时候就感觉是在对牛弹琴，他们完全不能理解。后来我发现，教授们貌似不喜欢有自己想法的学生，他们更希望找到愿意“打下手”的学生，帮助实现他们自己的想法。</p>

<p>这就让我走到了跟那位向我打听 Cornell 情况的同学差不多的局面，真是心里有许多的苦却没有人可以理解。这时候我想到了系里的一些德高望重的教授，比如得过图灵奖的人，也许这些顶级的大牛会给我指出方向。于是我就联系到一位图灵奖得主，说想找他聊聊。我说我感兴趣的东西 Cornell 貌似并不重视和发展。Cornell 的校训是“any person, any study”，而我想 study 的东西却得不到支持。最后我谈了一下我对 Cornell 的总体感受。我说我觉得大家上课死记硬背，不是很 intellectual，我不是很确定学术界是否还保留有它原来的对智慧和真知的向往。</p>

<p>我很诚恳的告诉了他这些，只是希望得到一些建议。结果他不但没有理解任何一点，而且立马开始用质问的语气问我，你成绩怎么样？考试都通过了没有？哎，说白了就是想搞清楚你是不是成绩不好没人要。怎么就跟高中教导主任一样。于是乎那次谈话就这样不了了之。可是没有想到，这次谈话就造成了我最后的离别。在学生们互相之间勾心斗角，不通信息的同时，系里的教授们其实背后都是“通气”的。他们根本不懂得如何教学，就知道拿作业和考试往学生头上砸，幸存下来的就各自挑去做徒弟，挨不住的就打发掉。这算盘打得真是妙啊。我也不知道他们是什么机制，每个学生对哪些教授感兴趣，表现如何，他们貌似都了如指掌，貌似背后有个什么情报网。然后系里的教授们不知道怎么的，仿佛就都知道有这样一个不知趣的学生，居然敢说学术界的坏话！</p>

<p>大地震前夕的天空总是异常的美。我竟然在过道里看到那位图灵奖教授对我点头致意并且微笑，以前做 TA 时把我呼来唤去还横竖不满意的教授也对我笑脸相迎。我仿佛觉得那一席话打动了那位德高望重的教授，再加上在图形学和数值计算的扎实进展，也许我的学术生涯有了转机。可是，我那一次真正的领悟了什么叫做所谓的“笑里藏刀”。</p>

<p>由于那个学期上的图形学还有矩阵计算的课成绩都不错，我心想应该能找这两门课的授课教授的其中一个做导师吧。再加上那些貌似友好的笑容…… 所以没想很多，居然过了一个非常快乐的寒假。没有任何前兆，没有任何直接的通知（email，电话），一封纸信不知道是什么时候默默地进到了我在系里的“信箱”—一个我基本上从来不看的，系里用来塞广告信息的信夹子里，直到下一个学期开始的时候（2月份）我才发现。信是系主任写的，大概就是说，由于你的表现，我们觉得 Cornell 不是适合你的地方……</p>

<p>说得对，我也觉得 Cornell 不适合我。我本来就有想走的意思，可我一般呆在一个地方就懒得动。如果你们早一点告诉我这个，比如12月以前，我还可以申请转学到其它学校。可是都 2 月份了才收到这样的东西，Cornell 啊 Cornell，你让我现在怎么办？我想我可以说你不仁不义吧？</p>

<p>在这个万分窘迫的时候，我想起了曾经关心过我却又很失望的 Hofstadter。我告诉他我在 Cornell 很不开心，我很想研究程序语言，可是 Cornell 不理解也不在乎这个领域。他回信说，没有关系，你能找到自己喜欢的东西就应该去追寻它。Indiana 的 Dan Friedman 正好是做程序语言的，你可以联系他，就说是我介绍你去的。</p>

<p>于是给 Friedman 发了 email，很快得到了回信说：“Yin，两年前我们都看过你的材料，我们觉得你是非常出众的学生，可惜你最后没有选择我们。你要明白，人生最重要的事情不是名利，而是找到你愿意合作的人。你的材料都还在我们这里。现在招生已经快结束了，但是我会把你的材料提交给招生委员会，让他们破例再次考虑你的申请。” 我和 <a href="http://www.yinwang.org/blog-cn/2012/07/04/dan-friedman">Dan Friedman 的故事</a>就从这里开始了。</p>

<p>我在 Cornell 的遭遇貌似不可告人的耻辱和秘密，然而我今天却可以把它公之于世，因为 Cornell 不再有任何资格来评价我。依靠自己的努力和 Indiana 的老师们的培养，我的水平已经超越了 Cornell 计算机系的大部分教授。现在我觉得自己就像那个到 Cornell 学“游泳精髓”人，本来就是会游泳的，可是每到岸边 Cornell 就搬起大石头来砸我，还说我不会游。于是我钻到水底下钻了一个洞，把水放干。</p>

<p>由于曾经与多位图灵奖得主发生不大愉快的遭遇，再加上在自己的研究中多次受到其它图灵奖得主的理论的误导，而且许多位图灵奖得主最主要的贡献仍然在给软件行业带来混乱，图灵奖这个被许多计算机学生膜拜的神物，其实在我心里已经没有任何效力了。很多人可能对此难以想象，可是对图灵奖是这种态度的不只我一个人。我认识的几乎所有程序语言专家几乎都不拿图灵奖当回事，而且其中很多人甚至不拿图灵本人当回事，觉得他设计了一些非常丑陋的东西。虽然我现在觉得图灵的研究成果确实有一定价值，但由于上面的原因，拿图灵奖来开玩笑还是成为了我的家常便饭。我甚至觉得 ACM 应该停发这个奖，因为它是一种非常虚幻和政治的东西。每当人们谈起这些“大奖”煞有介事的时候，就让我看到了他们的愚昧。</p>

<h3>常青藤联盟和“世界一流大学”</h3>

<p>我在 Cornell 的经历应该不是偶然，不是因为我比较特殊。跟我同时进入 Cornell 的博士生有好几个没有拿学位就离开了。其中有一个是非常聪明的少年班，18岁就读 PhD 了，我根本听不懂的理论课他还能拿A。可是四年后他退学去了 Facebook，说真是太难毕业了，神马都是扯淡。有些本科生也告诉我类似的经历，说被一个叫做“笑面虎”的教授“整了”。Cornell 的自杀率居美国大学前列。离开以后的有一天，忽然看到<a href="http://www.nytimes.com/2010/03/17/education/17cornell.html?_r=0">新闻报道</a>说一周之内有三个 Cornell 学生从瀑布旁边的那座桥跳下去，结果派了警察在桥上日夜巡逻。我觉得自己在 Cornell 所感受到的压力确实超乎想象，是有可能把人逼上绝路的。现在回想起来真是可笑，因为下意识里在乎权威和名气，我给予了一群根本没有资格来教育我的人莫大的权力，让他们可以向我施加无端的压力。</p>

<p>应该指出，这种现象应该不是 Cornell 所特有的。我对清华，还有 Princeton，Harvard，MIT，Stanford，Berkeley，CMU 等学校的学生都有了解。这些所谓的“世界一流大学”或者“世界一流大学 wannabee”差不多都是类似的气氛。你冲着它们的名气和“关系网”挤破了头皮进去，然后就每天有人在你耳边对其它人感叹：哇，他好牛啊！发了好多 paper，还得了XX奖。跟参加传销大会似的，让你怀疑这些人还有没有自尊。然后就是填鸭式的教育，无止境的作业和考试，让你感觉他们不是在“教育”你，而是在“筛选”你。这种筛选总是筛掉最差的，但也筛掉最好的。因为最好的学生能意识到你在干什么，他们不给你筛选他们的机会。一旦发现其实没学到东西，中途就辍学出去创业了。所以剩下来的就是最一般的，循规蹈矩听话的。在这样的环境里，你感觉不到真正的智慧和真知的存在。GRE 考试所鼓吹的什么“批判性思维”（critical thinking ）在美国大学里其实是相当缺乏的。学生们只不过是在被培训成为某些其他人的工具，他们具有固定的思维定势，像是一个模子倒出来的。他们不是真正的创造者和开拓者。</p>

<p>人们在这些大学里的时候都是差不多感受的，可是一旦他们出来了，就会对此绝口不提。自己身上挂着这些学校的镀金牌子，怎么能砸了自己的品牌，长别人的威风？所以每当我批判 Cornell 就有些以前的同学一脸的着急相，好像自己没有吃过那苦头一样。</p>

<h3>程序语言专家</h3>

<p>虽然我在 Indiana 得到了思想的自由，但这种自由其实是以孤独为代价的。我并不是一个自高自大不合群的人，但是我不喜欢跟一群像追星族一样的人在一起。应该说在 Indiana 的日子里，权威主义的影子也是经常出现的。Indiana 学生们的权威比较特殊一点，不然就是 Dan Friedman，不然就是 Kent Dybvig。Friedman 的身边总是围绕着一群自认为是天才的本科生，喜欢拍他的马屁，喜欢在人面前炫耀。博士生们开始时貌似还比较酷，可是后来发现其实也有很多类似现象，急于表现自己，越是研究能力弱的人越是爱表现。所以你就发现有人开头为了混进这个圈子拍你的马屁，过了两年就开始自高自大，而且经常想这样来压倒你：“Kent 说过……”我很尊敬 Dan 和 Kent，但我其实在很多方面已经超越了他们。我看到他们的一些思维方式并不是那么的正确，我也从来不引用他们的话作为理论依据。对权威的崇拜其实显示了一个人心理的弱小。如果你对自己有信心，有自己的想法和判断力，又何必抬出个名人来压制别人呢？</p>

<p>在我自己心里毫无疑问的是，我是 Indiana 最厉害的程序语言（PL）学生。由于我不断地动手尝试新的想法，所以几乎没有任何其他人的研究逃脱过我的探索。我从来不记录自己的半成品和失败（因为太多了），而且我对自己的标准异常的高，所以我经常看到有人做演讲或者写论文，里面其实是我很久以前尝试过又抛弃了的想法。有时候我去听别人的演讲，就会立即看出破绽，问一些演讲者答不出来的问题。其实很多时候我只是怀疑自己，我试图给那些想法再一次的机会来证明它们的价值，而且问得相当委婉，但那样的问题仍然是不受欢迎的，所以同学们甚至一些助理教授看到我在场都是心惊胆战的。吃饭的时候我也不喜欢旁边的人讨论问题，因为他们经常显示出对理论提出者的膜拜心理，而且煞有介事，可惜那些经常是我早就知道不管用的理论。他们有时候其实也知道那些是扯淡的，但却又怕我捅破这窗户纸，所以就像鸵鸟一样把头埋在沙子下面。</p>

<p>我也想合群一点，但是屡试不爽，所以后来我就基本是孤立的做自己的研究了。最开头是不得已，但后来就越来越喜欢独自一人。这是不可避免的，因为创造力和孤独几乎是双胞胎。因为免去了跟人讨论的时间，我有了大把的时间来做自己的探索。然后我才发现当年期望的那种 common room 其实没什么用，因为那里根本不会有人理解你在说什么。现在即使有这样的地方我也不会去了。</p>

<p>我从一开始进入 Indiana 就没想过要拿博士学位，我只是在玩弄这个系统以达到我求知的目的。所以除非危及到我的存在，我把学校对学位的各种要求都抛到了九霄云外。给教授做 RA 几乎总是被要求研究各种毫无前途的东西，与我自己的思考相冲突，所以我后来干脆都做 TA 了。虽然累点，但不怎么费脑力。其结果是，在短短的一两年时间之内，我利用自己抠出来的时间，独自摸索出了这个领域大部分的理论。我经常不看书不看论文，在一个星期之内解决别人十多年才完成的研究。让人惊讶的应该不是我有多么聪明，而是这些研究者们十年来到底在干什么。我从来不认为自己比别人聪明，我只是觉得很多人的脑子被禁锢了而已。我有非常简单的头脑，我看不懂复杂的公式，听不懂高深的术语。可正是因为这一点，让我脱离了已有理论的困扰。</p>

<p>可以说，这个领域在过去一个多世纪的研究，很少有逃脱过我的洞察力和直觉的。这些研究最早可以追溯到 1870 年代。我一般很少看论文，因为自己想清楚一个问题其实花不了那么多时间的。看别人的论文一般都枯燥乏味，所以与其花那么多时间读论文还不如自己思考。当我看论文的时候，一般是想搞清楚自己琢磨出来的问题有没有人已经研究过了，所以很多论文只需要扫一下就够了。我看到一个东西一般很快就会知道它到底会不会管用。我经常发现一些被认为很艰深的理论其实是在解决根本不存在的问题，甚至是在制造问题，而真正的问题却没有得到有效的解决。很多问题其实是权威的阴影造成的，它让人们不敢否认这些大牛思想的价值，不敢揭穿它们，抛弃它们，甚至想让自己寄生在它们上面，所以很多的时间花在了解决一些历史遗留问题，而不是真正的问题。这就是为什么我的英文 blog 标题叫做“<a href="http://yinwang0.wordpress.com">Surely I Am Joking</a>”，因为它记录了一些我认为根本不存在，或者是人为造成的问题。</p>

<h3>逻辑学家</h3>

<p>批评 PL 领域的问题并不意味着其它领域就好一些。恰恰相反，我认为做系统和数据库的领域有更大的权威崇拜和扯淡的成分。有时候程序语言专家看起来很明显的问题，做数据库和操作系统的人却看不到，扯来扯去扯不清楚，还自以为是的认为 PL 的东西他们都懂。</p>

<p>程序语言的理论是计算机科学的精髓所在，可是程序语言专家有他们自己的问题：他们膜拜逻辑学家。几乎每一篇 PL 领域的论文，至少有一页纸里面排列着天罡北斗阵一样的稀奇古怪的逻辑符号，而它们表示的其实不过是一些可以用程序语言轻松做出来的解释器和数据结构。有人（比如 Kent Dybivg）早就发现了这个规律，所以写了一些工具，可以把程序语言自动转换成 LaTeX 格式的逻辑公式，用以对付论文的写作。</p>

<p>有人觉得那些公式有“数学的美感”，可是它们其实是挺有毛病的设计。如果你看看现代逻辑学鼻祖 <a href="http://www.olimon.org/uan/frege-writings.pdf">Gottlob Frege</a> 的原著，就会发现其实最早的时候逻辑学不是用公式表示的。Frege 那篇开创性的论文 Begriffsschrift 里面全都是像电路图一样的图片，只有 20 多页，而且非常容易读懂。不知道是哪一个后辈把电路图改成了一些稀奇古怪的符号。其实他的目的是用符号来表示那些电路图，结果到后来徒孙们以为那些符号就是祖传秘籍的精髓，忘记了那些符号背后的电路图，所以导致了今天的混乱局面。看完了 Frege 的论文，我再一次领悟到了之前那句话：跟真正的大师学习，而不是跟他们的徒弟。</p>

<p>ACM SIGPLAN 的主席 Philip Wadler 有一次写了一篇论文介绍 <a href="http://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">Curry-Howard corresponce</a>，里面提到，好的点子逻辑学家总是比我们先想到。可是他却没有发现，其实程序语言的能力已经大大超越了数理逻辑，数理逻辑那些公式里面的 bug 其实不少。因为逻辑学家们不用机器帮助进行推理，有些问题搞了一百多年都搞不清楚是怎么回事，然后就弄出一些特殊情况和补丁来。有了一堆逻辑“定理”，却又不能确信它们是正确的，而且存在悖论一类无厘头的东西，所以又掰出一些 model theory 之类的东西来验证它们的正确性。逻辑学家们折腾了一百多年都是在折腾类似的事情，却没怀疑过老祖宗的设计。我之前提到的 <a href="http://yinwang0.wordpress.com/2012/10/19/type-inference">Hindley-Milner 系统</a>的问题，很大部分原因就在于它所使用的逻辑里面其实有一个根本性的误解。简言之，就是把全称量词 ∀ 随意乱放，导致输入与输出关系混乱。这也就是我为什么不喜欢 Haskell 和 OCaml 的最主要原因。</p>

<p>现在最热门的逻辑学家莫过于 <a href="http://en.wikipedia.org/wiki/Per_Martin-L%C3%B6f">Per Martin-Löf</a>。他的类型理论 Martin-Löf Type Theory 被很多 PL 人奉为神圣。我一直没有搞清楚这个类型理论有什么特别，直到有一天我把 Martin-Löf 1980 年的那篇论文（其实是演讲稿）拿出来看了一遍。然后我发现他通篇本质上就是在讲一个 partial evaluator 要怎么写，而我早就自己写过 partial evaluator。其实并不是特别神奇的东西，只需要在普通解释器里面改一两行代码就行，可是有人（比如 Neil Jones）却为此写出了 <a href="http://www.itu.dk/~sestoft/pebook/pebook.html">400 多页的书</a>和大量的论文。</p>

<p>之前提到的 Curry-Howard corresponce 也被很多人奉为神圣，它来自数学家 Haskell Curry 和逻辑学家 W.A. Howard 的一些早期发现。他们发现有些程序和定理的证明之间有对应的关系。然后就有 PL 专家开始走火入魔，说“程序就是证明，程序的类型就是定理”。可是他们却没有发现这个说法没法解释操作系统这种程序，因为它被设计为永远不停地运行，所以不能满足一个证明所具有的基本特征。而且很多程序被设计出来根本就不是要证明什么定理，它们是被设计来帮人做事情的。所以我觉得“程序就是证明”是很牵强附会的说法，你不能因为有的程序可以用来证明数学定理，就认为所有的程序都是某个定理的证明啊！把那句话反过来，说成“证明就是程序”还差不多。</p>

<p>但从以上的发现，我很高兴的看到了自己作为一个程序员的价值。很多人瞧不起程序员，把他们蔑称为“码农”，可是程序如果写好了，其实比起那些高深的逻辑学家和哲学家还要强，因为程序语言其实比数理逻辑还要强。有一位<a href="http://www.math.rutgers.edu/~zeilberg/Opinion37.html">数学家</a>说得好：为了真正深入的理解一个东西，你应该把它写成程序。还有人说，编程只是一门失传的艺术的别名，这门艺术叫做“思考”。我觉得很在理。</p>

<h3>再见了，权威们</h3>

<p>几经颠簸的求学生涯，让我获得了异常强大的力量。我的力量不仅来自于老师们的教诲，而且在于我自己不懈的追求，因为机会只亲睐有准备的头脑。</p>

<p>曾经 Knuth 是我心中唯一的权威，后来我又屈服于 Cornell 和常青藤联盟的权威和名气。在一而再再而三的上当受骗之后，我终于把所有的权威们从我的脑子里轰了下去。也许有时候轰得太猛烈了一些，但总的说来是有好处的。不再是我心目中的权威并不等于我鄙视他们或者不尊敬他们。我只是获得了不用膜拜他们，不用跟一群人瞎起哄的自由。我不尊敬的人都是一些自视过高的人或者他们的跟屁虫。一般来说，权威们在我的脑子里失去的只是他们在很多其他人脑子里的那种被膜拜的地位，那种你可以用“XX人说过……”来压倒理性分析的地位。现在他们在我心目中是一群普通的，由蛋白质形成的生物，有好心肠或者坏心眼的，高傲，谦虚或者虚伪的人。我不会自讨苦吃，他们的想法如果真的好，我当然要拿来用，但是没有任何人的东西我是不加批判全盘接受的。我深深地知道接受错误想法的危害性，所以我也希望大家都具有批判的思维，不要盲目的接受我说的话。我不喜欢“大神”或者“牛人”这种称呼，我也反感那种自称膜拜我的人，因为正是这种人让权威主义现在横行于世。</p>

<p>美国的权威主义胜于欧洲，但也不是每个人都那么的崇拜权威，而中国才是权威主义的重灾区。像“图灵奖得主XX”这样的称呼，恐怕只有在中国才见得到。所以我希望国内的同学们，不要盲目的崇拜国外的所谓“大师”，“牛校”或者“牛公司”。祝你们早日消灭掉心里的各种权威以及对他们的畏惧心理，认识到自己的价值和力量。</p>

<h3>后记（关于 IU）</h3>

<p>有些人看了我的文章介绍在 IU 的经历，告诉我他们申请了 IU。我觉得有必要免责声明一下：我没想到，也不希望有人因为我的文章而去 IU，<a href="http://en.wiktionary.org/wiki/your_mileage_may_vary">YMMV</a> (your mileage may vary)。由于我有所准备，所以对于 Friedman 的教学如鱼得水。很多同学也说学到很多，可是有一些其他人告诉我他们觉得 Friedman 的课他们听起来很吃力，只能说是勉强过关。而且我只介绍了 IU 好的方面，却把不大好的地方一笔带过了。我在 IU 也有很艰难的时候。现在的情况是 Kent Dybvig 已经离开了 IU，加入了 Cisco。他的公司 Cadence Research Systems 和 Chez Scheme 也并入了 Cisco。Dan Friedman 由于年纪原因说不准还带不带学生。最近引进了一些貌似不错的助理教授，但是我跟他们都不熟。我的经验是助理教授一般都会为了研究资金，为了升为正教授而做一些身不由己的事情。其他的 CS 方向我都说不准 IU 是什么水平，所以还请同学们自己斟酌。我可以毫无疑问的一点是，IU 有非常美丽的校园，大大的超过清华，北大，Cornell，Stanford，MIT。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>我为什么在乎这一个A+</h2>

    <p>我知道有些人至今仍然嘲笑和鄙视我，因为我曾经说过，我在Dan Friedman的两门课程B521（程序语言理论)和B621（高级程序语言理论）都得了A+。只要提到我，他们就会拿出这个把柄来，好像我是一个只在乎分数的肤浅的人。实际上我觉得这些人只是为了鄙视而鄙视，所以他们发现貌似一个把柄，也不搞清楚Dan Friedman是谁，也不搞清楚这个A+的分量，拿着半截就开跑，抓住不放了。所以即使我没提过这分数的事情，他们一样会找到其它话题来损我。我一直都懒得回应这些人的言论，不过今天我有兴致显示一下自己的价值，所以想花点时间告诉你，这个A+到底意味着什么。</p>

<p>从我的<a href="http://www.yinwang.org/blog-cn/2014/01/04/authority">人生历史</a>里面，你应该很明显的看出来，课程，考试，分数，名校，权威，事业，成就，贡献，以至于图灵奖，诺贝尔奖，对于我来说真的什么都不是。你觉得一个在乎这些东西的人，会以优秀的成绩从清华，Cornell，Indiana三所大学退学吗？在漫长的学术生涯中，我上过许多的课程，很多最后结果都是A或者A+，也有几门课的分数低到C。因为我从来不觉得任何人有资格出题来考我，所以自上大学以来，我给自己定的标准就是“及格万岁”。我是一个非常不喜欢上课的人，我觉得普通的课堂讲座本身就是一种极其低效的教学方式，所以一旦觉得老师水平不够或者不懂教学就开始翘课，自己看书自学。所以，最后无论什么分数都不能衡量我的价值，反而有时候觉得高分是对我价值的侮辱——本来有时候老师教的，课本上的东西就不对，得高分意味着我得跟他们错得一样。然而，我为什么唯独在乎在一个非名校，“非名师”手里上的这门课程，并且愿意告诉你我在里面的成绩呢？</p>

<p>其实，这个分数的意义远远不止是一个A+，它涵盖的内容可能超乎你的想象。也许你可以从一个很小的例子看出它到底意味着什么。在课程进行到一半的时候，我花了一个星期的时间，独立解决了曾经困扰程序语言领域十多年的难题——CPS变换。CPS变换有什么用呢？如果你写过Node.js或者其它类似的东西，就知道所谓“call back hell”的代码样式，其本质就是程序语言专家所谓的“CPS”（continuation-passing style）。“CPS变换”就是可以自动把代码变换成那种样式的过程，它在本质上就是一个编译器。实际上有些函数式语言的编译器（比如SML），其中最重要的过程就是CPS变换。CPS变换之后，你可以掌握代码中的“控制流”，实现所谓“超轻量线程”，进而可以实现最近很流行的，所谓“大规模并发”。所以你看到了，这些很流行的概念，在程序语言专家看来，并不是什么稀奇的东西，甚至不是新的想法。</p>

<p>在这十几年里面，有众多的世界级专家参与过这个问题的研究，包括程序语言领域的鼻祖之一，爱丁堡大学教授，英国皇家学会院士<a href="http://en.wikipedia.org/wiki/Gordon_Plotkin">Gordon Plotkin</a>，天才的丹麦Aarhus大学教授Olivier Danvy，CMU的Andrzej Filinski（现在DIKU），Indiana的Dan Friedman以及他的得意门生，天才的Matthias Felleisen，Felleisen的得意门生，天才的Amr Sabry（我的导师），普林斯顿大学教授Andrew Appel（编译器教材“<a href="http://www.amazon.com/Modern-Compiler-Implementation-Andrew-Appel/dp/0521607655">虎书</a>”的作者）。这些人为这个话题发表了不知道多少论文，Andrew Appel还为此专门写了一本书，叫做《<a href="http://www.amazon.com/Compiling-Continuations-Andrew-W-Appel/dp/052103311X">Compiling with Continuations</a>》。我之所以会去解决这个问题，是因为Friedman耍老顽童的花样，别出心裁地把这个问题作为了一道附加题目放进了B521的作业里。我不知道这个问题有如此之难，所以愣头愣脑，真把它当成作业题给解决了。按照作业的“道德规范”，完全从问题出发，不看书不看论文不查网络，全凭自己的头脑，在一个星期之内，把代码反反复复重写了几十次，最后得到了最优的结果。这就是所谓“王垠40行代码”的含义，虽然最后只剩下40行，然而却不知道删掉了多少。为了这40行代码，一个人七天，一群人十年，我想你应该知道这是什么概念。</p>

<p>当我最后把代码交给Dan Friedman的时候，他不相信我的代码是正确的，因为历史上有许多的学生声称做出了这道题目，然而他们几乎全都是错的，或者采用了效率很低的做法。只有深入到精髓，才会明白怎么写出这些代码。那么多大牛花了那么多年工夫才研究清楚，所以Friedman把这问题放在作业里面，其实根本就没指望有人能够解决。所以自然，他很难相信任何人能够做出这道题目。那天Friedman用惊讶又怀疑的眼神看着我，然后给了我一篇30多页的<a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.84">论文</a>。这篇论文是历史上这个问题的一个重大突破，作者是他的好朋友，Danvy和Filinsky。可是这论文写得含混晦涩，所以我花了超过一个月才琢磨清楚这篇论文是怎么回事，我至今被那些公式弄得眼花缭乱。可是最后我发现，我的自己写出来的代码完全的实现了它最后的思想，而且还要更加优雅。所以当最后我在班上讲解这片代码是怎么回事的时候，Friedman对大家说：“你们可要听仔细了，这个值100美元！”</p>

<p>我的名字叫做王垠（父亲起名含义是谐音“亡垠”，无边无垠的意思），所以我将会永不停息的完善自己，永远不会拿某一个东西自居。解决这个难题只是对我这个人内在品质的一种反映而已，而且它只是我在B521做出的好几个“课外练习”的其中一个。在短短一学期的时间里，我还进行了其它几个重量级的练习，包括重新实现miniKanren语言，加入constraint logic programming功能和一种非常强大的逻辑逆（negation）操作符，等等。这些练习，全都是独立依靠自己领悟摸索完成，没有查阅任何书籍和论文资料。从这些练习里面，我获得了让我受益终生的独立思考能力。也就是这种能力，让我可以在Google，Coverity之类的公司，轻松解决其他人咋咋呼呼，认为不可能完成的任务。这就是为什么我会讲这个课程的<a href="http://www.yinwang.org/blog-cn/2012/07/04/dan-friedman">故事</a>，并且告诉你我得了A+。</p>

<p>有趣的是，学期结束的时候，成绩单上出现的分数其实是I（Incomplete）。这种成绩表示有课程任务没有完成，如果在一年之内不弥补，就会变成F（不及格）。我很纳闷，发信去问Friedman。他回答说：“对不起，是秘书搞错了！” 然后急忙发信给秘书说：“这个人的分数应该是A+！实际上如果可能的话，我希望给他A+++++++！”</p>

<p>现在你还觉得我是因为肤浅才告诉你这个A+分数吗？B521教会我的，是一生最重要的东西，它让我真正的理解了什么叫做“简单”，它使得我去追寻它。它赋予我的独立思考能力，继续在帮助我用巧妙简单的方法解决其他人望而却步的问题。这不是一个普通的A+，这是一个把我送上世界巅峰，给予我勇气和自由思想的A+。</p>

<p>就像爱因斯坦说的，任何一个傻瓜都可以把问题搞复杂，你需要一点天才，还有很多勇气，才能达到简单。很多牛人用“简单”来标榜自己设计的东西，然而我发现他们对简单的理解其实很肤浅。大部分时候他们用一种类似“皇帝的新装”的心理技巧——你如果不能理解他的东西，他就说你是傻瓜或者菜鸟，不能理解这种简单。所以没有人敢说他们设计的东西太复杂。</p>

<p>你觉得世界上有几个人能够在B521上得A+呢？谦虚是一种美德，不要随便评判别人，然而当看到这么多大牛都那么不谦虚，耀武扬威的，很多人用他们作为评判其他人的依据，所以我只好冒着评判他们的风险，告诉你一些事实。其实Donald Knuth, Dennis Ritchie, Bjarne Stroustrup, Guido van Rossum, Brendan Eich, Linus Torvalds, Rob Pike, ... 这些很多人仰慕的大牛，如果上B521肯定是连A都拿不到的。有些甚至不能及格，因为有些人根本不知道他们在干什么，设计出一堆复杂的垃圾，然后仗着自己的威望和强权迫使你去“学习”。其实我对计算机的理解跟这些大牛们，早就不在一个数量级上了。我心里有数他们该得什么分数，你们自己猜猜吧。</p>

<p>本来不想这么赤裸裸的跟人比较的，然而我发现我的话语权和我对事物的认识深度比起来，实在相差太多。当我说到一些事情的时候，经常有人抬出这些人的语录来压制，说得好像圣经似的，对我各种评判，所以觉得有必要特此说明一下。这些大牛在我心目中真的一点权威都没有的，我反而清楚他们肚子里到底有多少货，思维方式有哪些误区和局限性。</p>

<p>也许我现在可以毫不担心的告诉你了，我在<a href="http://en.wikipedia.org/wiki/R._Kent_Dybvig">Kent Dybvig</a>的编译器课程上得的也是A+。Kent恐怕是世界上最厉害的编译器作者，他几乎从来不给人A+，而我恐怕是他20多年来最厉害的一个学生。我们做了一个Scheme编译器，它的难度和工作量，是C语言编译器的两倍以上。由于我喜欢别出心裁，不按他的写法，我的课堂编译器的某些方面，其实超越了他的Chez Scheme。比如，我的编译器曾一度生成比他更高效的X64机器指令。然而Kent很会背地里偷学武功，闷声发大财。据课程助教说，Kent有几次偷偷在我的代码上做“侦探工作”挺久…… 再加上他几十年深藏不露的<a href="http://www.cs.indiana.edu/~dyb/pubs/hocs.pdf">经验</a>，所以他现在恐怕仍然比我强 :)</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>在三藩的两年</h2>

    <p>今天对于我和三藩市（San Francisco，旧金山），是一个特殊的日子。两年前的今天，我来到了这座城市，举目无亲，没有一个朋友。两年后的今天，我决定离开这座城市，举目无亲，没有一个朋友。</p>

<p>三藩，你真是一座神奇的城市。两年的时间，竟然可以交不到一个朋友。就连连年雾霾的北京，也有好几个朋友想得起我。看看网络上的评论，我发现自己不是特殊情况。有人说：“在三藩七年了，我终于有了第一个可以叫做朋友的人！”三藩，你就是如此的特别。你被评为全美国“浪漫事件发生概率最低”的城市，可我觉得，你其实也是“普通友情发生概率最低”的城市。有人说你“社交无能”（socially incompetent），我觉得的确如此。</p>

<p>当我以高昂的房租搬进这个坐落于雄伟华丽的 Bay Bridge 旁边的小区，有一个台湾来的女孩正要搬走，把她的全套家具卖给了我。她告诉我，她就要回台湾去了，三藩完全不能和台北相比，完全没有生活气息，非常无聊。两年的时间让我目睹了，她的断言一步步的被证明为事实。</p>

<p>三藩，当我第一次踏上这片美丽的土地，我的心充满了阳光，就像每天照耀在你身上的，加州阳光。可是，当我自信的走进小区的小卖部，用平时的幽默和友好态度对店员说话，我第一次在美国感受到了什么叫做“种族歧视”。第一次感觉到，自己被认为是一个不懂规矩的乡巴佬。我之前已经在美国生活了六年之久，从来没有在其它地方有过这种遭遇：Ithaca, Bloomington, 西雅图，芝加哥，纽约市，迈阿密，奥兰多。第一次还无所谓，可是这种事情发生多次之后，阳光离开了我，我的心里开始填充上阴影和对这座城市的失望。</p>

<p>后来我才发现在三藩，你接受的服务态度，不取决于你是否有礼貌有修养，而取决于你的穿着，你的肤色，甚至你的发型，你无时无刻不在被其他人打量和审视。我觉得我的衣着和发型都已经够典雅了，可是我的黄皮肤黑头发是不会变的。很奇怪的是，最歧视中国人的人，不是美国白人，而是三藩市的“土著广东人”。在中国城（Chinatown），百货商场，机场，你常常可以看到这种广东大妈，营养不良的样子还板着个脸，看到白人就点头哈腰，看到中国人就显示出鄙夷的神色，仿佛在说：“不是美国公民吧？”“买得起吗？” 或者就吆喝：“没看牌上写着这是头等舱入口吗？你，走那边！ ”这种广东土著，也就是三藩市最穷，最吝啬，素质最低的人群，被其他种族的人所鄙视。他们仿佛想把这些年来在美国受到的委屈，都发泄到大陆过来的人身上。</p>

<p>Chinatown 就是这种广东人的集中地。不要以为 Chinatown 会有什么好吃的，我可以告诉你，除了一两家饭店味道还不错，其它饭店的级别，从“难吃”到“完全不能吃”。服务态度嘛，很有可能是这样：满脸横肉的大叔服务员，用下巴夹着手机一边跟人聊天，一边把菜单扔到你面前，看都不看你一眼。你会疑惑他到底是给你服务的，还是你老板。你想去 Chinatown 买菜？那些人直接跟你说广东话，而且态度全都跟在吵架似的。所以几次苦头之后，我就几乎不去 Chinatown 了。可是土著广东人在这里势力是如此之大，听说一次有个导游路过 Chinatown 说了一句它的坏话，结果在舆论压力之下，这位导游被炒了鱿鱼。</p>

<p>有人跟我说，他们去 Chinatown 都不敢说普通话，因为会被人鄙视，所以他们说英语，让那些人以为自己是日本或者韩国人。对于这种侮辱国格的事情，我是绝对不会做的。要么我根本就不去，要么我就要让你们知道，我是中国人，所以我不会说粤语，我的英文发音也不标准！我的口音，我的语法错误，全都是我，作为一个高贵的中国人，身份的象征！我从来不按照法语的发音读英语里的“外来词”，我觉得这是美国人自卑和附庸风雅的心理。为什么法语单词到了英语里面还要按原来的发音，而不是英文的规则？每当有美国人纠正我，我都嘲笑他们。你们美国没有文化，所以喜欢按法语发音，这样显得有点文化。我本来就会一点法语的，我能说完整的法语句子，可我现在说的是英语，我就是不按法语来念这些外来词，你把我怎么着？扯远了。</p>

<p>广东人并不是唯一服务态度差的人群。三藩市不管哪个种族的服务生，服务态度基本是从漠不关心，直到极其恶劣。热情好客的，我还真不记得有几个。去咖啡店，经常遇到打扮入时（有时很gay）的店员，用打量的眼神看着你，仿佛在说：我是城里人，乡巴佬，懂得什么叫做时尚么，知道我的耳环什么牌子的么，还来这里买咖啡！时尚？比起纽约，巴黎，东京，甚至成都，三藩有什么时尚吗？三藩有什么文化吗？没有自我价值的人，才会在乎自己和别人穿什么衣服！告诉你，我是世界顶尖的精英，我的智力和收入，是你的好多倍，我穿什么什么就叫做时尚！对狗有点礼貌，狗还以为它真的比你地位高了。更气人的是某些超市的收款员，一看到是中国人，看都不看你，动作好像是在拿你买的东西来发泄似的，让你有一种想揍人的冲动。来看看一个纽约人给三藩市的评价：三藩人，根本不懂得什么叫做 customer service！我越来越觉得说到了我心里。</p>

<p>三藩市的“社交无能”，并不止于这些市井小民，还在于充斥在这座城市里的创业公司（startup）。有很多人认为创业公司具有创新能力，而其实大部分创业公司都非常肤浅，没有任何自己的核心技术，只是拿大公司已经做好的组件来拼拼凑凑，然后到处拉投资。为创业公司工作，往往意味着超时超量的工作，巨大的压力，不受尊重，没有自己的闲暇时间。三藩市区里的公司，大部分就属于这种公司。所以可想而知，在三藩市你会遇到什么样的人群。创业公司的 founder 们往往有了点钱就妄自菲薄，喜欢鼓吹自己的“文化”，而忽略员工的个人价值和对他们的尊重。这些缺乏自尊的人，进而试图从对别人的鄙视中获取自己心里缺失的尊重，从而导致恶性循环。这种公司可能一开头热烈欢迎你加入，你以为有了自己的组织。可是后来你发现，你并不被作为这个城市的一部分。你只是一个外地来的打工仔，就跟国内人对待一个外地来的农民工差不多。这些“城里人”认为你是来工作的，来为他们服务的，好像你不是来生活的，你没有享受的资格一样。</p>

<p>纽约，北京，上海，成都，…… 是有生命的，是活着的城市。成都东郊这么偏远的地区，一直到晚上11点还有人在遛狗吃夜宵，三藩到晚上8点就几乎没有人迹了。纽约的现代艺术博物馆（MOMA），放着世界上最伟大的传世佳作（莫奈，梵高，雷诺阿……）；三藩市的现代艺术博物馆（SFMOMA），收着比纽约 MOMA 还贵的门票，却连一幅大师的作品都没有，展览着一些不知哪里来，没有美感甚至恶心或者有毒的“后现代作品”。纽约的百老汇（Broadway），演绎着世界最高水平的歌剧；三藩的 Broadway，上面全是不入流的脱衣舞馆。所以有时候你纳闷，这到底是个国际化都市，还是个刚升级的“县级市”。文化这东西，还真不是钱可以买来的。</p>

<p>住三藩市的人，很多都有一种想做“城里人”的虚荣心。仿佛农民刚进城似的，觉得住在城市就多么了不起。打心眼里觉得自己是时尚人，是富人。住着完全不值那个价的设备陈旧的出租房，还口口声声说那有文化气息。他们很多对三藩市的酒吧和夜店相当热衷。可是去酒吧夜店看了看之后我发现，破败不堪，无聊之极。在小区附近遇到几个中国女生，却总是喜欢中文说到一半开始冒英语，好像在显示自己“融入”得了美国社会，吊得到美国男人，所以我都懒得理她们了。三藩市，你有一种病，也许这就叫做“幼稚病”或者“脑残”吧。</p>

<p>想到下个月就要搬离三藩了，我很开心。这座城市没有任何值得我留恋的地方，因为我在这里一个朋友都没有。</p>

<p>（后记：）</p>


  </body>
<h1>=======================================================<h1>
{ [Error: incorrect header check] errno: -3, code: 'Z_DATA_ERROR' }
<body>

    <h2>TeXmacs：一个真正“所见即所得”的排版系统</h2>

    <p><img src="http://www.yinwang.org/images/texmacs.png" width="95%"></p>

<p>好久没有推荐过自己喜欢的软件了，现在推荐一款我在美国做数学作业的私家法宝：TeXmacs。我恐怕不可能跟以前那么有闲心写个长篇的 TeXmacs 说明文档了，不过这东西如此的简单好用，所以基本上不用我写什么文档了。鉴于知道的人很少，不理解它的人很多，这里只是帮它打个广告，吊一下胃口。</p>

<p>TeXmacs 的主要特点是：</p>

<ul>
<li><p>跟 Lyx 等不同，它不是一个 TeX 的“前端”，而是一个完全独立的，超越 TeX 的系统。TeXmacs 拥有跟 TeX 相同，甚至更好的排版美观程度。这是因为它采用跟 TeX 一样的排版算法，并且用 C++ 重新实现。据说分页的算法比 TeX 的还要好些。</p></li>
<li><p>拥有超越 Word （或者任何一款字处理软件）的，真正的“所见即所得” (WYSIWYG)。Word 所谓的“所见即所得”其实是假的。所见即所得的含义应该是，屏幕上显示的内容，跟打印下来的完全一样。可是 Word 能做到吗？打印一个文档出来你就发现跟屏幕上显示的有很大区别，一般来说屏幕上显示的要粗糙一些。一些 TeX 的前端，比如 Lyx, Scientific Workspace 等也是类似的，它们都不能达到真正的所见即所得。</p></li>
<li><p>直接可在屏幕文档里绘图。完全可视化的表格，公式编辑环境。这些都是比 TeX 方便高效很多的方式。需要当心的是，用过 TeXmacs 一段时间之后，你会发现回到 TeX 的公式编辑方式简直就像回到原始社会。</p></li>
<li><p>非常人性化的按键设计。比如，在数学公式环境下，你按任意一个字符，然后就可以用多次 TAB 键相继选择“拓扑相同”的字符。举个例子，如果你按 @，然后再按几下 TAB，就会发现这个字符变成各种各样的圆圈形的字符。如果你按 >，再按 =，就会出现大于等于号，之后再按 TAB，就会相继出现大于等于号的各种变体。</p></li>
<li><p>在直观的同时不失去对底层结构的控制。比如，（见下图）窗口右下角的状态栏，显示出当前光标位置的“上下文”是“proof eqnarry* (1,1) start”，这表示的是这是在一个 proof 环境里的 eqnarry 的坐标 (1,1) 的开始处。当你使用 Ctrl-Backspace，最靠近光标的那层“环境”会被删除。比如，如果你现在的字体是斜体，那么在 Ctrl-Backspace 之后，字体就立即还原成正体。</p>

<p><img src="http://www.yinwang.org/images/texmacs-context.png" width="90%"></p></li>
<li><p>结构化的浏览功能。比如，按 Ctrl-PgUp, Ctrl-PgDn 就可以在“相同类型”的结构里上下跳转。比如，如果你在小节标题里按这个键，就可以迅速的浏览所有的小节标题。如果你在数学公式里按这个键，就可以迅速浏览所有的数学公式。</p></li>
<li><p>与交互式程序接口。支持很多种计算机代数系统，和交互式软件，比如 MAXIMA，Octave，…… 这些系统返回的数学公式会直接被 TeXmacs 显示为“TeX 效果”。使用 Scheme 作为嵌入式语言，并且可以使用它来扩展系统。这比起 TeX 的语言是非常大的进步。</p></li>
</ul>


<p>目前由于 TeX 的垄断地位，以及由于 TeXmacs 是法国人做的，这个系统在美国还不是很流行，很多人都没听说过有这种东西存在。学术圈的很多人由于受到某种错误思想的“洗脑”，都不理解这种图形化编辑软件的价值。希望中国人民和法国人民一样后来居上，超越美国。</p>

<p>想要迅速的掌握 TeXmacs 的基本用法，可以参考我绘制的 <a href="http://www.mindomo.com/view.htm?m=b207992c90c046bdbe4053cbdf88b5d5">TeXmacs 思维导图</a>：</p>

<p><a href="http://www.mindomo.com/view.htm?m=b207992c90c046bdbe4053cbdf88b5d5"><img src="http://www.yinwang.org/images/texmacs-mindmap.png" width="90%"></a></p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>一个对 Dijkstra 的采访视频</h2>

    <p><a href="http://v.youku.com/v_show/id_XNjc1MDMzNDg4.html"><img src="http://www.yinwang.org/images/dijkstra-interview.png" width="70%"></a></p>

<p>（也可以访问 <a href="http://www.youtube.com/watch?v=RCCigccBzIU">YouTube</a> 或者从源地址下载 <a href="http://www.cs.utexas.edu/users/EWD/video-audio/NoorderlichtVideo.html">MPEG1</a>，300M）</p>

<p>之前在微博上推荐了一个对 Dijkstra 的采访视频，看了两遍之后觉得实在很好，所以再正式推荐一下。大部分人可能都知道他对图论算法和操作系统的贡献，而其实 Dijkstra 在程序语言上的造诣也很深厚。我们常用的程序语言里面司通见惯的“递归函数”，其实当年就是 Dijsktra 和另一个人不顾委员会里众人的反对和怀疑，坚持要放进 Algol 60，所以后来才进入了 Pascal，C，Java 这样的语言的。那个时候 John McCarthy 缺席，不然的话就会有三个人支持了。</p>

<p>现在看来，任何一个语言里面没有递归函数都是不可思议的事情，然而在1950-60年代的时候，居然很少有人知道它有什么用！所以你就发现，所谓的“主流”和“大多数人”一直都是比较愚蠢的。现在，同样的故事发生在 lambda 身上。多年以后，没有 lambda 的语言将是不可接受的。</p>

<p>在这里只摘录他提到的几个要点。某些观点也许不是最好的办法，但我确信其中有非常值得学习的地方。</p>

<ol>
<li>软件的版本号 2.6, 2.7, ... 都是胡扯。本来第1版就应该是最终的产品，可是软件公司总是先弄出来一个不完整的版本，骗大家买了，以后再慢慢“升级”。每次升级都要用户再次付钱。</li>
<li>编程有多种流派，我喜欢把它们归类成“莫扎特 vs 贝多芬”。当莫扎特开始写乐谱时，作品就已经完成了。他的手稿一气呵成，书法也很好。贝多芬不一样，他总是在怀疑和挣扎。他的作品一般是还没有想好就开始写，然后就往上面贴纸条修改。有一次贝多芬改了9遍才把手稿完成，后来有人把这手稿一层层的撕开，发现第一版和最后一版是一摸一样的。这种改来改去的做法是 Anglo-Saxon 民族的传统，它贯穿了英国式的教育。</li>
<li>作曲家的工作不是写乐谱，而是构思音乐。最早的时候人们编程都是用汇编语言的，就跟写乐谱差不多。后来他们发明了高级语言，就以为这些语言把编程的问题解决了。但是你仔细一瞧，发现它们只是把编程最微不足道的问题解决了，但是困难的问题仍然困难。这些高级语言与越来越大的野心加在一起，反而让程序员头脑的负担更重了。</li>
<li>称职的程序员都知道自己头颅的尺寸是有限的，所以他们以谦逊的态度来对待工作，像回避瘟疫一样地回避小聪明。</li>
<li>当我1970年在法国巴黎讲学如何编程的时候很成功，听众都非常积极。回家的路上我又在比利时布鲁塞尔的一个大软件公司进行了同样的演讲，结果非常失败。那恐怕是我一生中最失败的演讲。后来我发现了为什么：他们的管理层不喜欢无懈可击的程序，因为这公司是靠“维护软件”的合同来维持生存的。程序员对此也不感兴趣，因为最让他们兴奋的事情在于不知道自己在干什么。他们觉得如果清楚地知道自己在干什么，那就没有挑战性了，就是无聊的工作。</li>
<li>研究物理的人如果遇到不理解的事情，总是可以责怪上帝，世界这么复杂不是你的错。但是如果你的程序有问题，那就找不到替罪羊了。0就是0，1就是1，就是你把它搞砸了。</li>
<li>1969年，在阿波罗号登月之后不久，我在罗马的北约软件工程会议遇到了 Joel Aron，阿波罗计划的软件负责人。我知道每个阿波罗飞船上面的代码都会比前一个多4万行。我不知道“行”对于代码是个什么单位，但4万行肯定是很多了。我很惊讶他们能把这么多代码做对，所以我问 Joel：你们是怎么做到的？他说：做什么？我说：把那么多代码写正确。Joel 说：“正确？！其实在发射前仅仅五天，我从登月器计算轨道的代码里发现一个错误，这代码把月球的重力方向算反了。本来该吸引的，结果写成了排斥。是一个偶然的机会让我发现了这个错误。”我的脸都白了，说：这些家伙运气真好？Joel 说：“是的。”</li>
<li>软件测试可以确定软件里有 bug，但却不可能用来确定它们没有 bug。</li>
<li>程序的优雅性不是可以或缺的奢侈品，而是决定成功还是失败的一个要素。优雅并不是一个美学的问题，也不是一个时尚品味的问题，优雅能够被翻译成可行的技术。牛津字典对 elegant 的解释是：<a href="http://www.oxforddictionaries.com/us/definition/american_english/elegant?q=elegant">pleasingly ingenious and simple</a>。如果你的程序真的优雅，那么它就会容易管理。第一是因为它比其它的方案都要短，第二是因为它的组件都可以被换成另外的方案而不会影响其它的部分。很奇怪的是，最优雅的程序往往也是最高效的。</li>
<li>当没有计算机的时候，编程不是问题。当有了比较弱的计算机时，编程成了中等程度的问题。现在我们有了巨大的计算机，编程就成了巨大的问题。</li>
<li>我最开头编程的日子跟现在很不一样，因为我是给一个还没有造出来的计算机写程序。造那台机器的人还没有完工，我在同样的时间给它做程序，所以没有办法测试我的代码。于是我发现自己做的东西必须要能放进自己的脑子里。</li>
<li>我的母亲是一个优秀的数学家。有一次我问她几何难不难，她说一点也不难，只要你用“心”来理解所有的公式。如果你需要超过5行公式，那么你就走错路了。</li>
<li>为什么这么少的人追求优雅？这就是现实。如果说优雅也有缺点的话，那就是你需要艰巨的工作才能得到它，需要良好的教育才能欣赏它。</li>
</ol>



  </body>
<h1>=======================================================<h1>
{ [Error: incorrect header check] errno: -3, code: 'Z_DATA_ERROR' }
<body>

    <h2>Lisp 已死，Lisp 万岁！</h2>

    <p>有一句古话，叫做“国王已死，国王万岁！”它的意思是，老国王已经死去，国王的儿子现在继位。这句话的幽默，就在于这两个“国王”其实指的不是同一个人，而你咋一看还以为它自相矛盾。今天我的话题仿效了这句话，叫做“Lisp 已死，Lisp 万岁！”希望到最后你会明白这是什么意思。</p>

<p>首先，我想总结一下 Lisp 的优点。你也许已经知道，Lisp 身上最重要的一些优点，其实已经“遗传”到了几乎每种流行的语言身上（Java，C#，JavaScript，Python, Ruby，Haskell，……）。由于我已经在其他博文里详细的叙述过其中一些，所以现在只把这些 Lisp 的优点简单列出来（关键部分加了链接）：</p>

<ul>
<li><p>Lisp 的语法是世界上最精炼，最美观，也是语法分析起来最高效的语法。这是 Lisp 独一无二的，其他语言都没有的优点。有些人喜欢设计看起来很炫的语法，其实都是自找麻烦。为什么这么说呢，请参考这篇《<a href="http://www.yinwang.org/blog-cn/2013/03/08/on-syntax">谈语法</a>》。</p></li>
<li><p>Lisp 是第一个可以在程序的任何位置定义函数，并且可以把函数作为值传递的语言。这样的设计使得它的表达能力非常强大。这种理念被 Python，JavaScript，Ruby 等语言所借鉴。</p></li>
<li><p>Lisp 有世界上最强大的宏系统（macro system）。这种宏系统的表达力几乎达到了理论所允许的极限。如果你只见过 C 语言的“宏”，那我可以告诉你它是完全没法跟 Lisp 的宏系统相提并论的。</p></li>
<li><p>Lisp 是世界上第一个使用垃圾回收（garbage collection）的语言。这种超前的理念，后来被 Java，C# 等语言借鉴。</p></li>
</ul>


<p>想不到吧，现代语言的很多优点，其实都是来自于 Lisp — 世界上第二古老的程序语言。所以有人才会说，每一种现代语言都在朝着 Lisp 的方向“进化”。如果你相信了这话，也许就会疑惑，为什么 Lisp 今天没有成为主流，为什么 Lisp Machine 会被 Unix 打败。其实除了商业原因之外，还有技术上的问题。</p>

<p>早期的 Lisp 其实普遍存在一个非常严重的问题：它使用 dynamic scoping。所谓 dynamic scoping 就是说，如果你的函数定义里面有“自由变量”，那么这个自由变量的值，会随着函数的“调用位置”的不同而发生变化。</p>

<p>比如下面我定义一个函数 f，它接受一个参数 y，然后返回 x 和 y 的积。</p>

<pre><code>(setq f 
      (let ((x 1)) 
        (lambda (y) (* x y))))
</code></pre>

<p>这里 x 对于函数 (lambda (y) (* x y)) 来说是个“自由变量”（free variable），因为它不是它的参数。</p>

<p>看着这段代码，你会很自然的认为，因为 x 的值是 1，那么 f 被调用的时候，结果应该等于 (* 1 y)，也就是说应该等于 y 的值。可是这在 dynamic scoping 的语言里结果如何呢？我们来看看吧。</p>

<p>（你可以在 emacs 里面试验以下的结果，因为 Emacs Lisp 使用的就是 dynamic scoping。）</p>

<p>如果我们在函数调用的外层定义一个 x，值为 2：</p>

<pre><code>(let ((x 2))
  (funcall f 2))
</code></pre>

<p>因为这个 x 跟 f 定义处的 x 的作用域不同，所以它们不应该互相干扰。所以我们应该得到 2。可是，这段代码返回的结果却为 4。</p>

<p>再来。我们另外定义一个 x，值为 3：</p>

<pre><code>(let ((x 3))
  (funcall f 2))
</code></pre>

<p>我们的期望值还是 2，可是结果却是 6。</p>

<p>再来。如果我们直接调用：</p>

<pre><code>(funcall f 2)
</code></pre>

<p>你想这次总该得到 2 了吧？结果，出错了：</p>

<pre><code>Debugger entered--Lisp error: (void-variable x)
  (* x y)
  (lambda (y) (* x y))(2)
  funcall((lambda (y) (* x y)) 2)
  eval_r((funcall f 2) nil)
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp nil nil)
</code></pre>

<p>看到问题了吗？f 的行为，随着调用位置的一个“名叫 x”的变量的值而发生变化。而这个 x，跟 f 定义处的 x 其实根本就不是同一个变量，它们只不过名字相同而已。这会导致非常难以发现的错误，也就是早期的 Lisp 最令人头痛的地方。我的老师 Dan Friedman 当年就为此痛苦了很多年，直到 Scheme 的出现，他才欢呼道：“终于有人把它给做对了！”</p>

<p>（附带说一句，Scheme 不是 Dan Friedman 发明的，而是 Guy Steele 和 Gerald Sussman。然而，Friedman 对程序语言的本质理解，其实超越了 Lisp 的范畴，并且对 Scheme 的后期设计做出了重要的贡献。以至于 Sussman 在 Friedman 的 60 大寿时发表演说，戏称自己比起 Friedman 来，“只是 Scheme 的用户”。）</p>

<p>好在现在的大部分语言其实已经吸取了这个教训，所以你不再会遇到这种让人发疯的痛苦。不管是 Scheme, Common Lisp, Haskell, OCaml, Python, JavaScript…… 都不使用 dynamic scoping。</p>

<p>那现在也许你了解了，什么是让人深恶痛绝的 dynamic scoping。如果我告诉你，Lisp Machine 所使用的语言 Lisp Machine Lisp 使用的也是 dynamic scoping，你也许就明白了为什么 Lisp Machine 会失败。因为它跟现在的 Common Lisp 和 Scheme，真的是天壤之别。我宁愿写 C++，Java 或者 Python，也不愿意写 Lisp Machine Lisp 或者 Emacs Lisp。</p>

<p>话说回来，为什么早期的 Lisp 会使用 dynamic scoping 呢？其实这根本就不是一个有意的“设计”，而是一个无意的“巧合”。你几乎什么都不用做，它就成那个样子了。这不是开玩笑，如果你在 emacs 里面显示 f 的值，它会打印出：</p>

<pre><code>'(lambda (y) (* x y))
</code></pre>

<p>这说明 f 的值其实是一个 S 表达式，而不是像 Scheme 一样的“闭包”（closure）。原来，Emacs Lisp 直接把函数定义处的 S 表达式 ‘(lambda (y) (* x y)) 作为了函数的“值”，这是一种很幼稚的做法。如果你是第一次实现函数式语言的新手，很有可能就会这样做。Lisp 的设计者当年也是这样的情况。</p>

<p>简单倒是简单，麻烦事接着就来了。调用 f 的时候，比如 (funcall f 2)，y 的值当然来自参数 2，可是 x 的值是多少呢？答案是：不知道！不知道怎么办？到“外层环境”去找呗，看到哪个就用哪个，看不到就报错。所以你就看到了之前出现的现象，函数的行为随着一个完全无关的变量而变化。如果你单独调用 (funcall f 2) 就会因为找不到 x 的值而出错。</p>

<p>那么正确的实现函数的做法是什么呢？是制造“闭包”(closure)。这也就是 Scheme，Common Lisp 以及 Python，C# 的做法。在函数定义被解释或者编译的时候，当时的自由变量（比如 x）的值，会跟函数的代码绑在一起，被放进一种叫做“闭包”的结构里。比如上面的函数，就可以表示成这个样子：(Closure '(lambda (y) (* x y)) '((x . 1)))。</p>

<p>在这里我用 (Closure ...) 表示一个“结构”（就像 C 语言的 struct）。它的第一个部分，是这个函数的定义。第二个部分是 '((x . 1))，它是一个“环境”，其实就是一个从变量到值的映射（map）。利用这个映射，我们记住函数定义处的那个 x 的值，而不是在调用的时候才去瞎找。</p>

<p>我不想在这里深入细节。如果你对实现语言感兴趣的话，可以参考我的另一篇博文《怎样写一个解释器》。它教你如何实现一个正确的，没有以上毛病的解释器。</p>

<p>与 dynamic scoping 相对的就是“lexical scoping”。我刚才告诉你的闭包，就是 lexical scoping 的实现方法。第一个实现 lexical scoping 的语言，其实不是 Lisp 家族的，而是 Algol 60。“Algol”之所以叫这名字，是因为它的设计初衷是用来实现算法（algorithm）。其实 Algol 比起 Lisp 有很多不足，但在 lexical scoping 这一点上它却做对了。Scheme 从 Algol 60 身上学到了 lexical scoping，成为了第一个使用 lexical scoping 的“Lisp 方言”。9 年之后，Lisp 家族的“集大成者” Common Lisp 诞生了，它也采用了 lexical scoping。看来英雄所见略同。</p>

<p>你也许发现了，Lisp 其实不是一种语言，而是很多种语言。这些被人叫做“Lisp 家族”的语言，其实共同点只是它们的“语法”：它们都是基于 S 表达式。如果你因此对它们同样赞美的话，那么你赞美的其实只是 S 表达式，而不是这些语言本身。因为一个语言的本质应该是由它的语义决定的，而跟语法没有很大关系。你甚至可以给同一种语言设计多种不同的语法，而不改变这语言的本质。比如，我曾经给 TeX 设计了 Lisp 的语法，我把它叫做 SchTeX（Scheme + TeX）。SchTeX 的文件看起来是这个样子：</p>

<pre><code>(documentclass article (11pt))
(document
  (abstract (...))
  (section (First Section)
      ... )
  (section (Second Section)
      ... )
)
</code></pre>

<p>很明显，虽然这看起来像是 Scheme，本质却仍然是 TeX。</p>

<p>所以，因为 Scheme 的语法使用 S 表达式，就把 Scheme 叫做 Lisp 的“方言”，其实是不大准确的做法。Scheme 和 Emacs Lisp，Common Lisp 其实是三种不同的语言。Racket 曾经叫做 PLT Scheme，但是它跟 Scheme 的区别日益增加，以至于现在 PLT 把它改名叫 Racket。这是有他们的道理的。</p>

<p>所以，你也许明白了为什么这篇文章的标题叫做“Lisp 已死，Lisp 万岁！” 因为这句话里面的两个 “Lisp”其实是完全不同的语言。“Lisp 已死”，其实是说 Lisp Machine Lisp 这样的 Lisp，由于严重的设计问题，已经死去。而“Lisp 万岁”，是说像 Scheme，Common Lisp 这样的 Lisp，还会继续存在。它们先进于其它语言的地方，也会更多的被借鉴，被发扬广大。</p>

<p>（其实老 Lisp 的死去还有另外一个重要的原因，那就是因为早期的 Lisp 编译器生成的代码效率非常低下。这个问题我留到下一篇博文再讲。）</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>怎样尊重一个程序员</h2>

    <p>得知一位久违的同学来到了旧金山湾区，然而我见到他时，这人正处于一生中最痛苦的时期。他告诉我，自己任职的公司在他加入之前和之后，判若两人。录取的时候公司对他说，我们对你在实习期间的表现和学术背景非常满意，你不用面试，甚至不用毕业拿学位，直接就可以加入我们公司成为正式员工。然而短短一年后的今天，这位同学已经完全感觉不到公司对自己技能的尊重。Manager让他做一些乱七八糟没技术含量的事情，还抱怨说他做事太慢，并且在他的evaluation上很是写了一笔。在人格尊严和工作安全感的双重打击之下，这位同学压力非常大，周末经常偷偷地加班，仍然无法让manager满意。</p>

<p>我很了解这位同学的能力，在任何一流公司任职，肯定是绰绰有余了。他的名字我当然保密，然而他所任职的公司因为太过嚣张，我不得不直接指出来——这就是被很多人向往得像天堂一样的地方，Google。这位同学所描述的遭遇，跟我几年前在Google的实习经历如出一辙。我仍然记得，Google的队友在旁边看着我用Emacs，用小学老师似的口气对我说：“按Ctrl-k！” 我仍然记得，在提交队友完全无法写出来的高难度代码时，被指责和嘲笑不会用Perforce。我仍然记得，吃饭时同事们对所谓“Google牛人”眉飞色舞的艳羡。我仍然记得，最后我一个人做出整个团队做梦都做不出来的项目的时候，有人发出沉闷的咆哮：“快——写——测——试！” ……</p>

<p>我的这位同学也算得上本领域顶尖的专家了。如此的践踏一个专家的价值，用肤浅的标准来评判和对待他们，Google并不是唯一一个这样的公司。我之前任职的好几个公司，或多或少都存在类似的问题。很多时候也不一定是公司管理层无端施加压力，而是程序员之间互斗的厉害，互相评判，伤害自尊。从最近<a href="http://arstechnica.com/business/2015/01/linus-torvalds-on-why-he-isnt-nice-i-dont-care-about-you">Linus Torvalds</a>在演讲现场公然对观众无理，你可以看出这种只关心技术，不尊重人的思潮，在程序员的社区里是非常普及的。</p>

<p>后来我发现，并不是程序员故意想要藐视对方或者互相攻击，而是他们真的不明白什么叫做“尊重”，他们不知道如何说话才可以不伤害另一个程序员，所以有时不小心就让人怒火中烧。所以说，尊重他人其实是一个“技术问题”，而不是有心就可以做到的。因为这个原因，我想在下文里从心理和技术角度出发，指出IT业界不尊重人现象的起源，同时提出几点建议，告诉人们如何真正的尊重一个程序员。我希望这些建议对公司的管理层有借鉴意义，也希望它们能给与正在经受同样痛苦的程序员们一些精神上的鼓励。</p>

<p>我觉得为了建设一个程序员之间互相尊重的公司文化，应该注意以下几个要点。</p>

<h3>认识和承认计算机系统里的历史遗留糟粕</h3>

<p>很多不尊重人现象的起源，都是因为某些人偏执的相信某种技术就是世界上最好的，每个人都必须知道，否则他就不是一个合格的程序员。这种现象在Unix（Linux）的世界尤为普遍。Unix系统的鼓吹者们（我曾经是其中之一）喜欢到处布道，告诉你其它系统的设计有多蠢，你应该遵从Unix的“哲学”。他们仿佛认为Unix就是世界终极的操作系统，然而事实却是，Unix是一个设计非常糟糕的系统。它似乎故意被设计为难学难用，容易犯错，却美其名曰“强大”，“灵活”。眼界开阔一点的程序员都知道，Unix的设计者其实基本不懂设计，他们并不是世界上最好的程序员，却有一点做得很成功，那就是他们很会制造宗教，煽动人们的盲从心理。Unix设计者把自己的设计失误推在用户身上，让用户觉得学不会或者搞错了都是自己的错。</p>

<p>如果你对计算机科学理解到一定程度，就会发现我们其实仍然生活在计算机的石器时代。特别是软件系统，建立在一堆历史遗留的糟糕设计之上。各种蹩脚脑残的操作系统（比如Unix，Linux），程序语言（比如C++，JavaScript，PHP，Go)，数据库，编辑器，版本控制工具，…… 时常困扰着我们，这就是为什么你需要那么多的所谓“经验”和“知识”。然而，很多IT公司不喜欢承认这一点，他们一向以来的作风是“一切都是程序员的错！”，“作为程序员，你应该知道这些！” 这就造成了一种“皇帝的新装现象”——大家都不喜欢用一些设计恶劣的工具，却都怕别人嘲笑或者怀疑自己的能力，所以总是喜欢显示自己“会用”，“能学”，而没有人敢说它难用，敢指出设计者的失误。</p>

<p>我这个人呢，就是这种“<a href="http://www.yinwang.org/blog-cn/2014/04/11/hacker-culture">黑客文化</a>”的一个反例。我所受到的多元化教育，让我从这些偏激盲从，教条主义的心理里面跳了出来。每当有人因为不会某种工具或者语言来请教我时，我总是很轻松的调侃这工具的设计者，然后告诉他，你没理由知道这些破玩意儿，但其实它就是这么回事。然后我一针见血的告诉他这东西怎么回事，怎么用，是哪些设计缺陷导致了我们现在的诡异用法…… 我觉得所有的IT从业人员对于这些工具，都应该是这样的调侃态度。只有这样，软件行业才会得到实质性的进步，而不是被一些自虐的设计所困扰，造成思维枷锁。</p>

<p>总之，这是一个非常重要的“态度问题”。虽然在现阶段，我们有必要知道如何绕过一些蹩脚的工具，利用它们来完成自己的任务。然而在此同时，我们必须正视和承认这些工具的恶劣本质，而不能拿它们当教条，把什么事都怪罪于程序员。只有分清工具设计者的失误和程序员自己的失误，不把工具的设计失误怪罪于程序员，我们才能有效地尊重程序员们的智商，鼓励他们做出简单，优雅，完善的产品。</p>

<h3>分清精髓知识和表面知识，不要太拿经验当回事</h3>

<p>在任何领域，都只有少数知识是精髓的，另外大部分都是表面的，肤浅的，是从精髓知识衍生出来的。精髓知识和表面知识都是有用的，然而它们的分量和重要性却是不一样的。所以必须区分精髓知识和表面知识，不能混为一谈，对待它们的态度应该是不一样的。由于表面知识基本是死的，而且很容易从精髓知识推导衍生出来。我们不应该因为自己知道很多表面知识，就自以为比掌握了精髓知识的人还要强。不应该因为别人不知道某些表面知识，就以为自己高人一等。</p>

<p>IT公司经常有这样的人，以为精通一些看似复杂的命令行，或者某些难用的程序语言就很了不起似的。他们如果听说你不知道某个命令的用法，那简直就像法国人不知道拿破仑，美国人不知道华盛顿一样。这些人没有发现，自己身边有些同事其实掌握着精髓的知识，他们完全有能力从自己已有的知识，衍生制造出所有这些工具，而不只是使用它们，甚至设计得更加完善和方便易用。这种能够设计制造出更好工具的人，往往身负更加重要的任务，所以他们往往会在被现有工具的用法迷惑的时候，非常谦虚的请同事帮助解决，大胆的承认自己的糊涂。</p>

<p>如果你是这个精通工具用法的人，切不可以把同事的谦虚请求当成可以显摆自己“资历”的时候。这同事往往真的是在“不耻下问”。他并不是搞不懂，而是根本不屑于，也没有时间去考虑这种低级问题。他的迷惑，往往来源于工具设计者的失误。他很清楚这一点，他也知道自己的技术水平其实是高于这工具的设计者的。然而为了礼貌，他经常不直接批评这工具的设计，而是谦虚的责怪自己。所以同事向你“虚心请教”，完全是为了制造一种友好融洽的气氛，这样可以节省下时间来干真正重要的事情。这种虚心并不等于他在膜拜你，承认自己的技术能力不如你。</p>

<p>所以正确的对待方式应该是诚恳的表示对这种迷惑的理解，并且坦率的承认工具设计上的不合理，蹩脚之处。如果你能够以这种谦和的态度，而不是自以为专家的态度，同事会高兴地从你这里“学到”他需要的，肤浅的死知识，并且记住它，避免下次再为这种无聊事来打扰你。如果你做出一副“天下只有我知道这奇技淫巧”的态度，同事往往会对你，连同这工具一起产生鄙视的情绪。他下次会照样记不住这东西的用法，然而他却再也不会来找你帮忙，而是一拖再拖。</p>

<h3>不要自以为聪明，不要评判别人的智商和能力</h3>

<p>在IT公司里，总是有很多人觉得自己聪明，想显示自己比别人聪明。这种人似乎随时都在评判（judge）别人，你说的任何话，不管认真的还是开玩笑的，都会被他们拿去作为评估你智商和能力的依据。</p>

<p>有时候你写了一些代码，自己知道时间不够，可是当时有更重要的事情要做，所以打算以后再改进。如果你提交代码时被这种人看到了，他们就会坚定地认为你一辈子只能写出那样的代码。这就是所谓“wishful thinking”，人只能看到他希望看到的东西。这种人随时都在希望自己比别人聪明，所以他们随时都在监听别人显得不如他聪明的时候，而对别人比他高明的时候视而不见。他们只能看到别人疏忽的时候，因为那是可以证明他们高人一等的有利证据。</p>

<p>当然，谁会喜欢这样的人呢，可是他们在IT公司里相当的普遍。你不敢跟他们说话，特别是不敢开玩笑，因为他们会把你稀里糊涂的玩笑话全部作为你智商低下或者经验不足的证据。你不敢问他们问题，因为他们会认为你问问题，说明你不懂！我发现具有这种心理的人，一般潜意识里都存在着自卑。他们有某些方面（包括智力在内）不如别人，所以总是找机会显得高人一等。我还没有想出可以纠正这种心理问题的有效方法，但如我上节所说，意识到整个行业，包括你仰慕的鼻祖们，其实都不懂很多东西，都是混饭吃的，是一个有效的放松这种心理的手段。</p>

<p>有时候我喜欢自嘲，对人说：“我们这行业的祖先做了这么多BUG来让我们修补。现在你做了一坨屎，我也做了一坨屎，我的屎貌似比你的屎香一点。”这样一来，不但显示出心理的平等和尊重，而且避免了因为谦虚而让对方产生高人一等的情绪。说真的，做这行根本不需要很高的智力，所以最好是完全放弃对人智力的判断。你不比任何人更聪明，也不比他们笨。</p>

<h3>解释高级意图，不要使用低级命令</h3>

<p>随时都要记住，同事和下属是跟你智力相当的人。他们是通情达理的人，然而却不会简单地服从你的低级命令。像我在Google的队友的做法，就是一个很好的反面教材。其实这位Googler只是想告诉我：“删掉这行文本，然后改成这样……” 就是如此一个简单的事情，然而她却故弄玄虚，不直接告诉我这个“高级意图”，而是使用非常低级的指令：“按Ctrl-k！……” 语气像是在对一个不懂事的小学生说话，好像自己懂很多，别人什么都不知道似的。</p>

<p>有哪个Emacs用户不知道Ctrl-k是删掉一行字呢，况且你现在面对的其实是一个资深Emacs用户。我想大家都看出来这里的问题了吧。这样的低级命令不但逻辑不清楚，而且是对另一个人的智力的严重侮辱。你当我是什么啊？猴子？如果这位Googler表明自己的高级意图，就会很容易在心理上和逻辑上让人接受，比如她可以说：“配置文件的这行应该删掉，改成……”</p>

<p>在项目管理的时候也需要注意。在让人做某一件事之前，应该先解释为什么要做这件事，以及它的重要性。这样才能让人理解，才能尊重程序员的智商。</p>

<h3>不要期望新人向自己学习</h3>

<p>很多IT公司喜欢把新人当初学者，期望他们“从新的起跑线出发”，向自己“学习”。比如，Google把新员工叫做“Noogler”（Newbie Googler的意思），甚至给他们发一种特殊的螺旋桨帽子，其寓意在于告诉他们，小屁孩要谦虚，要向伟大的Google学习，将来才可以飞黄腾达。</p>

<p><img src="http://www.yinwang.org/images/noogler-hat.jpg" width="60%"></p>

<p>这其实是非常错误的作法，因为它完全不尊重新员工早已具备的背景知识，把自己的地位强加于他们头上。并不是你说“新的起跑线”就真的可以把人的过去都抹杀了的。新人不了解你们的代码结构和工程方式，并不等于你们的方式就会先进一些。Google里面真的有很多值得学习的东西吗？学校的教育真的一文不值吗？其实恰恰相反。我可以坦然的说，我从自己的教授身上学会了最精髓的知识，而从Google得到的，只是一些很肤浅的，死记硬背就可以掌握的技能，而且其中有挺多其实是糟粕。我在Google做出的所有创新成果，全都是从学校获得的精髓知识的衍生物。很多PhD学生鄙视Google，就是因为Google不但自己技术平庸，反倒喜欢把自己包装成最先进的，超越其它公司和学校的，并且嚣张的期望别人向他们“学习”。</p>

<p>一个真正尊重人才的公司会去了解，尊重和发挥新人从外界带来的特殊技能，施展他们特有的长处，而不是一味期望他们向自己“学习”。只有这样，我们才能保持这些锐利武器的棱角，在激烈的竞争中让自己立于不败之地。如果你一味的让新人“学习”，而无视他们特有的长处，最后就不免沦为平庸。</p>

<h3>不要以老师自居，分清“学习”和“了解”</h3>

<p>如上文所说，IT行业的很多所谓“知识”，只不过是一些奇技淫巧，用以绕过前人设计上的失误。所以遇到别人不知道一些东西的时候，请不要以为你“教会”了别人什么东西，不要以为自己可以当老师了。以老师自居，使用一些像“跟我学”一类的语言，其实是一种居高临下，不尊重人的行为。</p>

<p>人们很喜欢在获得了信息的时候用“学习”这个词，然而我觉得这个词被滥用了。我们应该分清两种情况：“学习”和“了解”。前者指你通过别人的指点和自己的理解，获得了精髓的，不能轻易制造出来的知识。后者只是指你“了解”了原来不知道的一些事情。举个例子，如果有人把一件物品放在了某个你不知道的地方，你找不到，问他，然后他告诉你了。这种信息的获取，显然不叫“学习”，这种信息也不叫做“知识”。</p>

<p>然而，IT行业很多时候所谓的“学习”，就是类似这种情况。比如，有人写了一些代码，设计了一些框架模块。有人不知道怎么用，然后有人告诉他了。很多人把这种情况称为“学习”，这其实是对人的不尊重。这跟有人告诉你他把东西放在哪里了，是同样性质的。这样的代码和设计，我也可以做，甚至做得更好，凭什么你说我在向你学习呢？我只是了解了一下而已。</p>

<p>所谓学习，必须是更加高级的知识和技能，必须有一种“有收获”，“有提高”的感觉。简单的信息获取不能叫做“学习”，只能叫做“了解”。分清“了解”和“学习”，不以老师自居，是尊重人的一个重要表现。</p>

<h3>明确自己的要求，不要使用指责的语气</h3>

<p>有些人很怪异，他根本没告诉过你他想要什么，有什么特别的要求，可他潜意识里假设已经告诉你了。到了后来，他发现你的作法不符合要求，于是严厉指责你没有按照他“心目中的要求”办事。这种现象不止限于程序员，而且包括日常生活中的普通人。举个例子，我妈就是这种人的典型，所以我以前在家生活经常很辛苦。她心目中有一套“正确”的做事方式，如果你没猜出来就会挨骂。你为了避免挨骂，干脆什么事都不要做，然后她又会说你懒，所以你就左右不是人 :)</p>

<p>IT公司里面也有挺多这样的人，他们假设有些信息他已经告诉你了，而其实根本没告诉你。到了后来，他们开始指责你没有按照要求做事。有些极其奇葩的公司，里面的程序员不但喜欢以老师自居，而且他们“传授”你“知识”的主要方式是指责。他们事先不告诉你任何规则，然后只在你违反的时候来责备你。我曾经在这样一个公司待过，名字就不提了。</p>

<p>现在举一个具体的场景例子：</p>

<p>A: 你push到master了？<br>
B: 是啊？怎么了？<br>
A: 不准push到master！只能用pull request！<br>
B: 可是你们之前没告诉过我啊……<br>
A: 现在你知道了？！</p>

<p>注意到了吗？这不是一个技术问题，而是一个礼节（etiquette）问题。你没有事先告诉别人一些规则，就不该用怪罪的语气来对人说话，况且你的规则还不一定总是对的。所以我现在提醒各位IT公司，在技术上的某些特殊要求必须事先提出来，确保程序员知道并且理解。如果没有事先提出，就不要怪别人没按要求做，因为这是非常伤害人自尊的作法。其实，在任何时候都不应该使用指责的语气，它不但对解决问题没有任何正面作用，而且会恶化人际关系，最终导致更加严重的后果。</p>

<h3>程序员的工作量不可用时间衡量</h3>

<p>很多IT公司管理层不懂得如何估算程序员的工作量，所以用他们坐在自己位置上工作的时间来估算。如果你能力很强，在很短的时间内把最困难的问题解决了，接下来他们不会让你闲着，而会让你做另外一些很低级的活。这是很不合理的作法。打个比方，能力强的员工就像一辆F1赛车，马力和速度是其他人的几十倍。当然，普通人需要很长时间才能解决，甚至根本没法解决的问题，到他手里很快就化解掉了。这就像一辆F1赛车，眨眼工夫就跑完了别人需要很久的路程。如果你用时间来衡量工作量，那么这辆赛车跑完全程只需要很短时间，所以你算出来的工作量就比普通车子小很多。你能因此说赛车工作不够努力，要他快马再加鞭吗？这显然是不对的。</p>

<p>物理定律是这样：能量 = 功率 x 时间。工作量也应该是同样的计算方法。英明的，真正理解程序员的公司，就不会指望高水平的程序员不停地工作。高水平程序员由于经常能够另辟蹊径，一个就可以抵好几个甚至几十个普通程序员。他们处理的问题比常人的困难很多，费脑力多很多，当然他们需要更好的休息，保养，娱乐，…… 如果你让高水平的程序员太忙了，一刻都不停着，有趣有挑战性的事情做完了就让他们做一些低级无聊的事情，他们悟出这个道理之后，就会故意放慢速度，有时候明明很快做完了也会说没做完。与其这样，不如只期望他们工作短一点的时间，把事情做完就可以。</p>

<p>当然这并不是说初级的程序员就应该过量工作。编程是一项艰苦的脑力活动，超时超量的工作再加上压力，只会带来效率的低下，质量的降低。</p>

<h3>不要让其他人修补自己的BUG</h3>

<p>这个我已经在一篇专门的<a href="http://www.yinwang.org/blog-cn/2015/02/20/other-peoples-bug">文章</a>里讨论过。让一个程序员修补另外一个程序员的BUG，不但是效率低下，而且是不尊重程序员个人价值的作法，应该尽量避免。</p>

<p>在软件行业，经常看到有的公司管理让一个人修补另一个人代码里的BUG。有时候有人写了一段代码，扔出来不管了，然后公司管理让其他工程师来修复它。我想告诉你们，这种方法会很失败。</p>

<p>首先，让一个人修复另一个人的BUG，是不尊重工程师个人技术的表现。久而久之会降低工程师的工作积极性，以至于失去有价值的员工。代码是人用心写出来的作品，就像艺术家的作品一样，它的质量牵挂着一个人的人格和尊严。如果一个人A写了代码，自己都不想修复里面的BUG，那说明A自己都认为他自己的代码是垃圾，不可救药。如果让另一个人B来修复A代码里的BUG，就相当于是让B来收拾其他人丢下的垃圾。可想而知，B在公司的眼里是什么样的地位，受到什么样的尊重。</p>

<p>其次，让一个人修复另一个人的BUG，是效率非常低下的作法。每个人都有自己写代码的风格和技巧，代码里面包含了一个人的思维方式。人很难不经解释理解别人的思想，所以不管这两人的编程技术高下，都会比较难理解。不能理解别人的代码，不能说明这人编程技术的任何方面。所以让一个人修补另一个人的BUG，无论这人技术多么高明，都会导致效率低下。有时候技术越是高的人，修补别人的BUG效率越是低，因为这人根本就写不出来如此糟糕的代码，所以他无法理解，觉得还不如推翻重写一遍。</p>

<p>当我在大学里做程序设计课程助教的时候，我发现如果学生的代码出了问题，你基本是没法简单的帮他们修复的。我的水平显然比学生的高出许多，然而我却经常根本看不懂，也不想看他们的代码，更不要说修复里面的BUG。就像上面提到的，有些人自己根本不知道自己在写什么，做出一堆垃圾来。看这样的代码跟吃屎的感觉差不多。对于这样的代码，你只能跟他们说这是不正确的。至于为什么不正确，你只能让他们自己去改，或者建议他们推翻重写。也许你能指出大致的方向和思路，然而深入到具体的细节却是不可能的，而且不应该是你的职责。这就是我的教授告诉我的做法：如果代码不能运行，直接打一个叉，不用解释，不用推敲，等他们自己把程序改好，或者实在没办法，来office hours找你，向你解释他们的思想。</p>

<p>如果你明白我在说什么，从今天起就对自己的代码负起责任来，不要再让其它人修补自己的BUG，不要再修补其他人的BUG。如果有人离开公司，必须要有人修补他遗留下来的BUG，那么说话应该特别特别的小心。你必须指出需要他帮忙的特殊原因，强调这件事本来不是他的错，本来是不应该他来做的，但是有人走了，没有办法，并且诚恳的为此类事情的发生表示歉意。只有这样，程序员才会心甘情愿的在这种特殊关头，修补另外一个人的BUG。</p>

<h3>不要嚷着要别人写测试</h3>

<p>在很多程序员的脑子里，所谓的“流程”和“测试”，比真正解决问题的代码还重要。他们跟你说起这些，那真的叫正儿八经，义正言辞啊！所以有时候你很迷惑，这些人除了遵守这些按部就班的规矩，还知道些什么。大概没有能力的人都喜欢追究各种规矩吧，这样可以显得自己“没有功劳有苦劳”。这些人自己写的代码很平庸，不知道如何简单有效地解决困难的问题，却喜欢在别人提交代码让他review的时候叫喊：“测试很重要！覆盖很重要！你要再加一些测试才能通过我的review！”</p>

<p>本来code review是让他们帮忙发现可能存在的问题，有些人却仿佛把它作为了评判（judge）其他人能力，经验，甚至智商的机会。他们根本不明白别人代码的实质价值，就知道以一些表面现象来判断。我在Google实习，最后提交了质量和难度都非常高的代码，然而一些完全没能力写出这样代码的人，不但没表示出最基本的肯定，反而发出沉闷的咆哮：“快——写——测——试！” 你觉得我会高兴吗？</p>

<p>我并不否认测试的用处，然而很多人提起这些事情时候，语气和态度是非常不尊重，让人反感的。这些人不但没有为解决问题作出任何实质贡献，当有人提交解决方案的时候，他们没有表达对真正做出贡献的人的尊重和肯定，反而指责别人没写测试。好像比他高明的人解决了问题，他反倒才是那个有发言权的，可以评判你的代码质量似的：“我管你代码写得多好，我完全没能力写出来，但你没写测试就是不够专业。你懂不懂测试的重要性啊，还做程序员！”</p>

<p>人际交往的问题经常不在于你说了什么，而在于你是怎么说的。所以我的意思并不是说你不该建议写测试，然而建议就该有建议的语气和态度。因为你没有做实际的工作，所以一些礼貌用语，比如“请”，“可不可以”……是必须的。经常有人说话不注意语气和态度，让人反感，却以自己是工程师，不善于跟人说话为借口。永远要记住，你没有做事，说话就应该委婉，切不可使用光秃秃的祈使句，说得好像这事别人非做不可，不做就是不懂规矩一样。</p>

<p>礼貌的语言，跟人的职业完全没有关系。身为工程师，完全不能作为说话不礼貌的借口。</p>

<h3>关于Git的礼节</h3>

<p>Git是现在最流行的代码版本控制工具。用外行话说，Git就是一个代码的“仓库”或者“保管”，这样很多人修改了代码之后，可以知道是谁改了哪一块。其实不管什么工具，不管是编辑器，程序语言，还是版本控制工具，比起程序员的核心思想来，都是次要的东西，都是起辅助作用的。可是Git这工具似乎特别惹人恼火。</p>

<p>Git并不像很多人吹嘘的那么好用，其中有明显的蹩脚设计。跟Unix的传统一脉相承，Git没有一个良好的包装，设计者把自己的内部实现细节无情地泄露给了用户，让用户需要琢磨者设计者内部到底怎么实现的，否则很多时候不知道该怎么办。用户被迫需要记住挺多稀奇古怪的命令，而且命令行的设计也不怎么合理，有时候你需要加-f之类的参数，各个参数的位置可能不一致，而且加了还不一定能起到你期望的效果。各种奇怪的现象，比如"head detached"，都强迫用户去了解它内部是怎么设计的。随着Git版本的更新，新的功能和命令不断地增加，后来你终于看到命令行里出现了foreach，才发现它的命令行就快变成一个（劣质的）程序语言。如果你了解<a href="https://github.com/yinwang0/ydiff">ydiff</a>的设计思想，就会发现Git之类基于文本的版本控制工具，其实属于古代的东西。然而很多人把Git奉为神圣，就因为它是Linus Torvalds设计的。</p>

<p>Git最让人恼火的地方并不是它用起来麻烦，而是它的“资深用户”们居高临下的态度给你造成的心理阴影。好些人因为自己“精通Git”就以为高人一等，摆出一副专家的态度。随着用户的增加，Git最初的设计越来越被发现不够用，所以一些约定俗成的规则似乎越来越多，可以写成一本书！跟Unix的传统一脉相承，Git给你很多可以把自己套牢的“机制”，到时候出了问题就怪你自己不知道。所以你就经常听有人煞有介事的说：“并不是Git允许你这么做，你就可以这么做的！Unix的哲学是不阻止傻人做傻事……” 如果你提交代码时不知道Git用户一些约定俗成的规则，就会有人嚷嚷：“rebase了再提交！” “不要push到master！” “不要merge！” “squash commits！” 如果你不会用git submodule之类的东西，有人可能还会鄙视你，说：“你应该知道这些！”</p>

<p>打个比方，这样的嚷嚷给人的感觉是，你得了奥运会金牌之后，把练习用的器材还回到器材保管科，结果管理员对你大吼：“这个放这边！那个放那边！懂不懂规矩啊你？” 看出来问题了吗？程序员提交了有高价值的代码（奥运金牌），结果被一些自认为Git用的很熟的人（器材保管员）厉声呵斥。</p>

<p>一个尊重程序员的公司文化，就应该把程序员作为运动健将，把程序员的代码放在尊贵的地位。其它的工具，都应该像器材保管科一样。我们尊重这些器材保管员，然而如果运动员们不懂你制定的器材摆放规矩，也应该表示出尊重和理解，说话应该和气有礼貌，不应该骑到他们头上。所以，对于Git的一些命令和用法，我建议大家向新手介绍时，这样开场：“你本来不该知道这些的，可是现在我们没有更好的工具，所以得这样弄一下……”</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>Oberon 操作系统：被忽略的珍宝</h2>

    <p>推荐一篇很久以前看的文章：<a href="http://www.ics.uci.edu/~franz/Site/pubs-pdf/BC03.pdf">Oberon - The Overlooked Jewel</a></p>

<p>它介绍的是 Niklaus Wirth 设计的一种操作系统，叫做 Oberon。Niklaus Wirth 就是大家熟知的 Pascal 语言的设计者。绝大部分人都没听说过有 Oberon 这个东西存在，更难以把它跟 Niklaus Wirth 的大名挂上钩。所以作者说：“Wirth 因为 Pascal 而闻名于世，可是接下来几年，他成为了 Pascal 的受害者。” 确实是这样。Wirth 一直都不觉得 Pascal 是他的杰作。我想他应该会更喜欢以 Oberon 闻名于世。</p>

<p>Oberon 比起 Unix，有很大的不同，在于它的数据都是结构化的。进程间不通过字符串交换数据，而是直接使用数据结构。很奇特的一点是，Oberon 操作系统是用一种同名的程序语言（Oberon 语言）写成。令人惊讶的是，在那个年代，ETH 计算机系的所有教职员工，学生，包括办公室的大妈，都是用的这种操作系统。</p>

<p>操作系统的设计，真是天外有天。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>编程的宗派</h2>

    <p>总是有人喜欢争论这类问题，到底是“函数式编程”（FP）好，还是“面向对象编程”（OOP）好。既然出了两个帮派，就有人积极地做它们的帮众，互相唾骂和鄙视。然后呢又出了一个“好好先生帮”，这个帮的人喜欢说，管它什么范式呢，能解决问题的工具就是好工具！我个人其实不属于这三帮人中的任何一个。</p>

<h3>面向对象编程（Object-Oriented Programming）</h3>

<p>如果你看透了表面现象就会发现，其实“面向对象编程”本身没有引入很多新东西。所谓“面向对象语言”，其实就是经典的“过程式语言”（比如Pascal），加上一点抽象能力。所谓“类”和“对象”，基本是过程式语言里面的记录（record，或者叫结构，structure），它本质其实是一个从名字到数据的“映射表”（map）。你可以用名字从这个表里面提取相应的数据。比如<code>point.x</code>，就是用名字<code>x</code>从记录<code>point</code>里面提取相应的数据。这比起数组来是一件很方便的事情，因为你不需要记住存放数据的下标。即使你插入了新的数据成员，仍然可以用原来的名字来访问已有的数据，而不用担心下标错位的问题。</p>

<p>所谓“对象思想”（区别于“面向对象”），实际上就是对这种数据访问方式的进一步抽象。一个经典的例子就是平面点的数据结构。如果你把一个点存储为：</p>

<pre><code>struct Point {
  double x;
  double y;
}
</code></pre>

<p>那么你用<code>point.x</code>和<code>point.y</code>可以直接访问它的X和Y坐标。但你也可以把它存储为“极坐标”方式：</p>

<pre><code>struct Point {
  double r;
  double angle;
}
</code></pre>

<p>这样你可以用<code>point.r</code>和<code>point.angle</code>访问它的模和角度。可是现在问题来了，如果你的代码开头把Point定义为第一种XY的方式，使用<code>point.x</code>, <code>point.y</code>访问X和Y坐标，可是后来你决定改变Point的存储方式，用极坐标，你却不想修改已有的含有<code>point.x</code>和<code>point.y</code>的代码，怎么办呢？</p>

<p>这就是“对象思想”的价值，它让你可以通过“间接”（indirection，或者叫做“抽象”）来改变<code>point.x</code>和<code>point.y</code>的语义，从而让使用者的代码完全不用修改。虽然你的实际数据结构里面根本没有<code>x</code>和<code>y</code>这两个成员，但由于<code>.x</code>和<code>.y</code>可以被重新定义，所以你可以通过改变<code>.x</code>和<code>.y</code>的定义来“模拟”它们。在你使用<code>point.x</code>和<code>point.y</code>的时候，系统内部其实在运行两片代码，它们的作用是从<code>r</code>和<code>angle</code>计算出<code>x</code>和<code>y</code>的值。这样你的代码就感觉<code>x</code>和<code>y</code>是实际存在的成员一样，而其实它们是被临时算出来的。在Python之类的语言里面，你可以通过定义“<a href="https://docs.python.org/2/library/functions.html#property">property</a>”来直接改变<code>point.x</code>和<code>point.y</code>的语义。在Java里稍微麻烦一些，你需要使用<code>point.getX()</code>和<code>point.getY()</code>这样的写法。然而它们最后的目的其实都是一样的——它们为数据访问提供了一层“间接”（抽象）。</p>

<p>这种抽象有时候是个好主意，它甚至可以跟量子力学的所谓“不可观测性”扯上关系。你觉得这个原子里面有10个电子？也许它们只是像<code>point.x</code>给你的幻觉一样，也许宇宙里根本就没有电子这种东西，也许你每次看到所谓的电子，它都是临时生成出来逗你玩的呢？然而，对象思想的价值也就到此为止了。你见过的所谓“面向对象思想”，几乎无一例外可以从这个想法推广出来。面向对象语言的绝大部分特性，其实是过程式语言早就提供的。因此我觉得，其实没有语言可以叫做“面向对象语言”。就像一个人为一个公司贡献了一点点代码，并不足以让公司以他的名字命名一样。</p>

<p>“对象思想”作为数据访问的方式，是有一定好处的。然而“面向对象”（多了“面向”两个字），就是把这种本来良好的思想东拉西扯，牵强附会，发挥过了头。很多面向对象语言号称“所有东西都是对象”（Everything is an Object），把所有函数都放进所谓对象里面，叫做“方法”（method），把普通的函数叫做“静态方法”（static method）。实际上呢，就像我之前的例子，只有极少需要抽象的时候，你需要使用内嵌于对象之内，跟数据紧密结合的“方法”。其他的时候，你其实只是想表达数据之间的变换操作，这些完全可以用普通的函数表达，而且这样做更加简单和直接。这种把所有函数放进方法的做法是本末倒置的，因为函数其实并不属于对象。绝大部分函数是独立于对象的，它们不能被叫做“方法”。强制把所有函数放进它们本来不属于的对象里面，把它们全都作为“方法”，导致了面向对象代码逻辑过度复杂。很简单的想法，非得绕好多道弯子才能表达清楚。很多时候这就像把自己的头塞进屁股里面。</p>

<p>这就是为什么我喜欢开玩笑说，面向对象编程就像“<a href="http://zh.wikipedia.org/wiki/%E5%9C%B0%E5%B9%B3%E8%AA%AA">地平说</a>”（Flat Earth Theory）。当然你可以说地球是一个平面。对于局部的，小规模的现象，它没有问题。然而对于通用的，大规模的情况，它却不是自然，简单和直接的。直到<a href="http://www.theflatearthsociety.org/cms">今天</a>，你仍然可以无止境的寻找证据，扭曲各种物理定律，自圆其说地平说的幻觉，然而这会让你的理论非常复杂，经常需要缝缝补补还难以理解。</p>

<p>面向对象语言不仅有自身的根本性错误，而且由于面向对象语言的设计者们常常是半路出家，没有受到过严格的语言理论和设计训练却又自命不凡，所以经常搞出另外一些奇葩的东西。比如在JavaScript里面，每个函数同时又可以作为构造函数（constructor），所以每个函数里面都隐含了一个this变量，你嵌套多层对象和函数的时候就发现没法访问外层的this，非得bind一下。Python的变量定义和赋值不分，所以你需要访问全局变量的时候得用global关键字，后来又发现如果要访问“中间层”的变量，没有办法了，所以又加了个nonlocal关键字。Ruby先后出现过四种类似lambda的东西，每个都有自己的怪癖…… 有些人问我为什么有些语言设计成那个样子，我只能说，很多语言设计者其实根本不知道自己在干什么！</p>

<p>软件领域就是喜欢制造宗派。“面向对象”当年就是乘火打劫，扯着各种幌子，成为了一种宗派，给很多人洗了脑。到底什么样的语言才算是“面向对象语言”？这样基本的问题至今没有确切的答案，足以说明所谓面向对象，基本都是扯淡。每当你指出某个OO语言X的弊端，就会有人跟你说，其实X不是“地道的”OO语言，你应该去看看另外一个OO语言Y。等你发现Y也有问题，有人又会让你去看Z…… 直到最后，他们告诉你，只有Smalltalk才是地道的OO语言。这不是很搞笑吗，说一个根本没人用的语言才是地道的OO语言，这就像在说只有死人的话才是对的。这就像是一群政客在踢皮球，推卸责任。等你真正看看Smalltalk才发现，其实面向对象语言的根本毛病就是由它而来的，Smalltalk并不是很好的语言。很多人至今不知道自己所用的“面向对象语言”里面的很多优点，都是从过程式语言继承来的。每当发生函数式与面向对象式语言的口水战，都会有面向对象的帮众拿出这些过程式语言早就有的优点来进行反驳：“你说面向对象不好，看它能做这个……” 拿别人的优点撑起自己的门面，却看不到事物实质的优点，这样的辩论纯粹是鸡同鸭讲。</p>

<h3>函数式编程（Functional Programming）</h3>

<p>函数式语言一直以来比较低调，直到最近由于并发计算编程瓶颈的出现，以及Haskell，Scala之类语言社区的大力鼓吹，它忽然变成了一种宗派。有人盲目的相信函数式编程能够奇迹般的解决并发计算的难题，而看不到实质存在的，独立于语言的问题。被函数式语言洗脑的帮众，喜欢否定其它语言的一切，看低其它程序员。特别是有些初学编程的人，俨然把函数式编程当成了一天瘦二十斤的减肥神药，以为自己从函数式语言入手，就可以对经验超过他十年以上的老程序员说三道四，仿佛别人不用函数式语言就什么都不懂一样。</p>

<h4>函数式编程的优点</h4>

<p>函数式编程当然提供了它自己的价值。函数式编程相对于面向对象最大的价值，莫过于对于函数的正确理解。在函数式语言里面，函数是“一类公民”（first-class）。它们可以像1, 2, "hello"，true，对象…… 之类的“值”一样，在任意位置诞生，通过变量，参数和数据结构传递到其它地方，可以在任何位置被调用。这些是很多过程式语言和面向对象语言做不到的事情。很多所谓“面向对象设计模式”（design pattern），都是因为面向对象语言没有first-class function，所以导致了每个函数必须被包在一个对象里面才能传递到其它地方。</p>

<p>函数式编程的另一个贡献，是它们的类型系统。函数式语言对于类型的思维，往往非常的严密。函数式语言的类型系统，往往比面向对象语言来得严密和简单很多，它们可以帮助你对程序进行严密的逻辑推理。然而类型系统一是把双刃剑，如果你对它看得太重，它反而会带来不必要的复杂性和过度工程。这个我在下面讲讲。</p>

<h4>各种“白象”（white elephant）</h4>

<p>所谓白象，“white elephant”，是指被人奉为神圣，价格昂贵，却没有实际用处的东西。函数式语言里面有很好的东西，然而它们里面有很多多余的特性，这些特性跟白象的性质类似。</p>

<p>函数式语言的“拥护者”们，往往认为这个世界本来应该是“纯”（pure）的，不应该有任何“副作用”。他们把一切的“赋值操作”看成低级弱智的作法。他们很在乎所谓尾递归，类型推导，fold，currying，maybe type等等。他们以自己能写出使用这些特性的代码为豪。可是殊不知，那些东西其实除了能自我安慰，制造高人一等的幻觉，并不一定能带来真正优秀可靠的代码。</p>

<h5>纯函数</h5>

<p>半壶水都喜欢响叮当。很多喜欢自吹为“函数式程序员”的人，往往并不真的理解函数式语言的本质。他们一旦看到过程式语言的写法就嗤之以鼻。比如以下这个C函数：</p>

<pre><code>int f(int x) {
    int y = 0;
    int z = 0;
    y = 2 * x;
    z = y + 1;
    return z / 3;
}
</code></pre>

<p>很多函数式程序员可能看到那几个赋值操作就皱起眉头，然而他们看不到的是，这是一个真正意义上的“纯函数”，它在本质上跟Haskell之类语言的函数是一样的，也许还更加优雅一些。</p>

<p>盲目鄙视赋值操作的人，也不理解“数据流”的概念。其实不管是对局部变量赋值还是把它们作为参数传递，其实本质上都像是把一个东西放进一个管道，或者把一个电信号放在一根导线上，只不过这个管道或者导线，在不同的语言范式里放置的方向和样式有一点不同而已！</p>

<h5>对数据结构的忽视</h5>

<p>函数式语言的帮众没有看清楚的另一个重要的，致命的东西，是数据结构的根本性和重要性。数据结构的有些问题是“物理”和“本质”地存在的，不是换个语言或者换个风格就可以奇迹般消失掉的。函数式语言的拥护者们喜欢盲目的相信和使用列表（list），而没有看清楚它的本质以及它所带来的时间复杂度。列表带来的问题，不仅仅是编程的复杂性。不管你怎么聪明的使用它，很多性能问题是根本没法解决的，因为列表的拓扑结构根本就不适合用来干有些事情！</p>

<p>从数据结构的角度看，Lisp所谓的list就是一个单向链表。你必须从上一个节点才能访问下一个，而这每一次“间接寻址”，都是需要时间的。在这种数据结构下，很简单的像length或者append之类函数，时间复杂度都是O(n)！为了绕过这数据结构的不足，所谓的“Lisp风格”告诉你，不要反复append，因为那样复杂度是O(n<sup>2</sup>)。如果需要反复把元素加到列表末尾，那么应该先反复cons，然后再reverse一下。很可惜的是，当你同时有递归调用，就会发现cons+reverse的做法颠来倒去的，非常容易出错。有时候列表是正的，有时候是反的，有时候一部分是反的…… 这种方式用一次还可以，多几层递归之后，自己都把自己搞糊涂了。好不容易做对了，下次修改可能又会出错。然而就是有人喜欢显示自己聪明，喜欢自虐，迎着这类人为制造的“困难”勇往直前 :)</p>

<p>富有讽刺意味的是，半壶水的Lisp程序员都喜欢用list，真正深邃的Lisp大师级人物，却知道什么时候应该使用记录（结构）或者数组。在Indiana大学，我曾经上过一门Scheme（一种现代Lisp方言）编译器的课程，授课的老师是R. Kent Dybvig，他是世界上最先进的Scheme编译器Chez Scheme的作者。我们的课程编译器的数据结构（包括AST）都是用list表示的。期末的时候，Kent对我们说：“你们的编译器已经可以生成跟我的Chez Scheme媲美的代码，然而Chez Scheme不止生成高效的目标代码，它的编译速度是你们的700倍以上。它可以在5秒钟之内编译它自己！” 然后他透露了一点Chez Scheme速度之快的原因。其中一个原因，就是因为Chez Scheme的内部数据结构根本不是list。在编译一开头的时候，Chez Scheme就已经把输入的代码转换成了数组一样的，固定长度的结构。后来在工业界的经验教训也告诉了我，数组比起链表，确实在某些时候有大幅度的性能提升。在什么时候该用链表，什么时候该用数组，是一门艺术。</p>

<h5>副作用的根本价值</h5>

<p>对数据结构的忽视，跟纯函数式语言盲目排斥副作用的“教义”有很大关系。过度的使用副作用当然是有害的，然而副作用这种东西，其实是根本的，有用的。对于这一点，我喜欢跟人这样讲：在计算机和电子线路最开头发明的时候，所有的线路都是“纯”的，因为逻辑门和导线没有任何记忆数据的能力。后来有人发明了触发器（flip-flop），才有了所谓“副作用”。是副作用让我们可以存储中间数据，从而不需要把所有数据都通过不同的导线传输到需要的地方。没有副作用的语言，就像一个没有无线电，没有光的世界，所有的数据都必须通过实在的导线传递，这许多纷繁的电缆，必须被正确的连接和组织，才能达到需要的效果。我们为什么喜欢WiFi，4G网，Bluetooth，这也就是为什么一个语言不应该是“纯”的。</p>

<p>副作用也是某些重要的数据结构的重要组成元素。其中一个例子是哈希表。纯函数语言的拥护者喜欢盲目的排斥哈希表的价值，说自己可以用纯的树结构来达到一样的效果。然而事实却是，这些纯的数据结构是不可能达到有副作用的数据结构的性能的。所谓纯函数数据结构，因为在每一次“修改”时都需要保留旧的结构，所以往往需要大量的拷贝数据，然后依赖垃圾回收（GC）去消灭这些旧的数据。要知道，内存的分配和释放都是需要时间和能量的。盲目的依赖GC，导致了纯函数数据结构内存分配和释放过于频繁，无法达到有副作用数据结构的性能。要知道，副作用是电子线路和物理支持的高级功能。盲目的相信和使用纯函数写法，其实是在浪费已有的物理支持的操作。</p>

<h5>fold以及其他</h5>

<p>大量使用fold和<a href="http://www.yinwang.org/blog-cn/2013/04/02/currying">currying</a>的代码，写起来貌似很酷，读起来却不必要的痛苦。很多人根本不明白fold的本质，却老喜欢用它，因为他们觉得那是函数式编程的“精华”，可以显示自己的聪明。然而他们没有看到的是，其实fold包含的，只不过是在列表（list）上做递归的“通用模板”，这个模板需要你填进去三个参数，就可以生成一个新的递归函数调用。所以每一个fold的调用，本质上都包含了一个在列表上的递归函数定义。fold的问题在于，它定义了一个递归函数，却没有给它一个一目了然的名字。使用fold的结果是，每次看到一个fold调用，你都需要重新读懂它的定义，琢磨它到底是干什么的。而且fold调用只显示了递归模板需要的部分，而把递归的主体隐藏在了fold本身的“框架”里。比起直接写出整个递归定义，这种遮遮掩掩的做法，其实是更难理解的。比如，当你看到这句Haskell代码：</p>

<pre>foldr (+) 0 [1,2,3]</pre>


<p>你知道它是做什么的吗？也许你一秒钟之后就凭经验琢磨出，它是在对<code>[1,2,3]</code>里的数字进行求和，本质上相当于<code>sum [1,2,3]</code>。虽然只花了一秒钟，可你仍然需要琢磨。如果fold里面带有更复杂的函数，而不是<code>+</code>，那么你可能一分钟都琢磨不透。写起来倒没有费很大力气，可为什么我每次读这段代码，都需要看到<code>+</code>和<code>0</code>这两个跟自己的意图毫无关系的东西？万一有人不小心写错了，那里其实不是<code>+</code>和<code>0</code>怎么办？为什么我需要搞清楚<code>+</code>, <code>0</code>, <code>[1,2,3]</code>的相对位置以及它们的含义？这样的写法其实还不如老老实实写一个递归函数，给它一个有意义名字（比如<code>sum</code>），这样以后看到这个名字被调用，比如<code>sum [1,2,3]</code>，你想都不用想就知道它要干什么。定义<code>sum</code>这样的名字虽然稍微增加了写代码时的工作，却给读代码的时候带来了方便。为了写的时候简洁或者很酷而用fold，其实增加了读代码时的脑力开销。要知道代码被读的次数，要比被写的次数多很多，所以使用fold往往是得不偿失的。然而，被函数式编程洗脑的人，却看不到这一点。他们太在乎显示给别人看，我也会用fold！</p>

<p>与fold类似的白象，还有<a href="http://www.yinwang.org/blog-cn/2013/04/02/currying">currying</a>，Hindley-Milner类型推导等特性。看似很酷，但等你仔细推敲才发现，它们带来的麻烦，比它们解决的问题其实还要多。有些特性声称解决的问题，其实根本就不存在。现在我把一些函数式语言的特性，以及它们包含的陷阱简要列举一下：</p>

<ol>
<li>fold。fold等“递归模板”，相当于把递归函数定义插入到调用的敌方，而不给它们名字。这样导致每次读代码都需要理解几乎整个递归函数的定义。</li>
<li><p><a href="http://www.yinwang.org/blog-cn/2013/04/02/currying">currying</a>。貌似很酷，可是被部分调用的参数只能从左到右，依次进行。如何安排参数的顺序成了问题。大部分时候还不如直接制造一个新的lambda，在内部调用旧的函数，这样可以任意的安排参数顺序。</p></li>
<li><p>Hindley-Milner类型推导。为了避免写参数和返回值的类型，结果给程序员写代码增加了很多的限制。为了让类型推导引擎开心，导致了很多完全合法合理优雅的代码无法写出来。其实还不如直接要程序员写出参数和返回值的类型，这工作量真的不多，而且可以准确的帮助阅读者理解参数的范围。HM类型推导的根本问题其实在于它使用unification算法。Unification其实只能表示数学里的“等价关系”（equivalence relation），而程序语言最重要的关系，subtyping，并不是一个等价关系，因为它不具有对称性（symmetry）。</p></li>
<li><p>代数数据类型（algebraic data type）。所谓“代数数据类型”，其实并不如普通的类型系统（比如Java的）通用。很多代数数据类型系统具有所谓sum type，这种类型其实带来过多的类型嵌套，不如通用的union type。盲目崇拜代数数据类型的人，往往是因为盲目的相信“数学是优美的语言”。而其实事实是，数学是一种历史遗留的，毛病很多的语言。数学的语言根本没有经过系统的，全球协作的设计。往往是数学家在黑板上随便写个符号，说这个表示XX概念，然后就定下来了。</p></li>
<li><p>Tuple。有代数数据类型的的语言里面经常有一种构造叫做Tuple，比如Haskell里面可以写<code>(1, "hello")</code>，表示一个类型为<code>(Int, String)</code>的结构。这种构造经常被人看得过于高尚，以至于用在超越它能力的地方。其实Tuple就是一个没有名字的结构（类似C的structure），而且结构里面的域也没有名字。临时使用Tuple貌似很方便，因为不需要定义一个结构类型。然而因为Tuple没有名字，而且里面的域没法用名字访问，一旦里面的数据多一点就发现很麻烦了。Tuple往往只能通过模式匹配来获得里面的域，一旦你增加了新的域进去，所有含有这个Tuple的模式匹配代码都需要改。所以Tuple一般只能用在大小不超过3的情况下，而且必须确信以后不会增加新的域进去。</p></li>
<li><p><a href="http://www.yinwang.org/blog-cn/2013/04/01/lazy-evaluation">惰性求值</a>（lazy evaluation）。貌似数学上很优雅，但其实有严重的逻辑漏洞。因为bottom（死循环）成为了任何类型的一个元素，所以取每一个值，都可能导致死循环。同时导致代码性能难以预测，因为求值太懒，所以可能临时抱佛脚做太多工作，而平时浪费CPU的时间。由于到需要的时候才求值，所以在有多个处理器的时候无法有效地利用它们的计算能力。</p></li>
<li><p>尾递归。大部分尾递归都相当于循环语句，然而却不像循环语句一样具有一目了然的意图。你需要仔细看代码的各个分支的返回条件，判断是否有分支是尾递归，然后才能判断这代码是个循环。而循环语句从关键字（for，while）就知道是一个循环。所以等价于循环的尾递归，其实最好还是写成特殊的循环语句。当然，尾递归在另一些情况下是有用的，这些情况不等价于循环。在这种情况下使用循环，经常需要复杂的break或者continue条件，导致循环不易理解。所以循环和尾递归，其实都是有必要的。</p></li>
</ol>


<h3>好好先生</h3>

<p>很多人避免“函数式vs面向对象”的辩论，于是他们成为了“好好先生”。这种人没有原则的认为，任何能够解决当前问题的工具就是好工具。也就是这种人，喜欢使用shell script，喜欢折腾各种Unix工具，因为显然，它们能解决他“手头的问题”。</p>

<p>然而这种思潮是极其有害的，它的害处其实更胜于投靠函数式或者面向对象。没有原则的好好先生们忙着“解决问题”，却不能清晰地看到这些问题为什么存在。他们所谓的问题，往往是由于现有工具的设计失误。由于他们的“随和”，他们从来不去思考，如何从根源上消灭这些问题。他们在一堆历史遗留的垃圾上缝缝补补，妄图使用设计恶劣的工具建造可靠地软件系统。当然，这代价是非常大的。不但劳神费力，而且也许根本不能解决问题。</p>

<p>所以每当有人让我谈谈“函数式vs面向对象”，我都避免说“各有各的好处”，因为那样的话我会很容易被当成这种毫无原则的好好先生。</p>

<h3>符号必须简单的对世界建模</h3>

<p>从上面你已经看出，我既不是一个铁杆“函数式程序员”，也不是一个铁杆“面向对象程序员”，我也不是一个爱说“各有各的好处”的好好先生。我是一个有原则的批判性思维者。我不但看透了各种语言的本质，而且看透了它们之间的统一关系。我编程的时候看到的不是表面的语言和程序，而是一个类似电路的东西。我看到数据的流动和交换，我看到效率的瓶颈，而这些都是跟具体的语言和范式无关的。</p>

<p>在我的心目中其实只有一个概念，它叫做“编程”（programming），它不带有任何附加的限定词（比如“函数式”或者“面向对象”）。我的老师Dan Friedman喜欢把自己的领域称为“Programming Languages”，也是一样的原因。因为我们研究的内容，不局限于某一个语言，也不局限于某一类语言，而是所有的语言。在我们的眼里，所有的语言都不过是各个特性的组合。在我们的眼里，最近出现的所谓“新语言”，其实不大可能再有什么真正意义上的创新。我们不喜欢说“发明一个程序语言”，不喜欢使用“发明”这个词，因为不管你怎么设计一个语言，所有的特性几乎都早已存在于现有的语言里面了。我更喜欢使用“设计”这个词，因为虽然一个语言没有任何新的特性，它却有可能在细节上更加优雅。</p>

<p>编程最重要的事情，其实是让写出来的符号，能够简单地对实际或者想象出来的“世界”进行建模。一个程序员最重要的能力，是直觉地看见符号和现实物体之间的对应关系。不管看起来多么酷的语言或者范式，如果必须绕着弯子才能表达程序员心目中的模型，那么它就不是一个很好的语言或者范式。有些东西本来就是有随时间变化的“状态”的，如果你偏要用“纯函数式”语言去描述它，当然你就进入了那些monad之类的死胡同。最后你不但没能高效的表达这种副作用，而且让代码变得比过程式语言还要难以理解。如果你进入另一个极端，一定要用对象来表达本来很纯的数学函数，那么你一样会把简单的问题搞复杂。Java的所谓design pattern，很多就是制造这种问题的，而没有解决任何问题。</p>

<p>关于建模的另外一个问题是，你心里想的模型，并不一定是最好的，也不一定非得设计成那个样子。有些人心里没有一个清晰简单的模型，觉得某些语言“好用”，就因为它们能够对他那种扭曲纷繁的模型进行建模。所以你就跟这种人说不清楚，为什么这个语言不好，因为显然这个语言对他是有用的！如何简化模型，已经超越了语言的范畴，在这里我就不细讲了。</p>

<p>我设计Yin语言的宗旨，就是让人们可以用最简单，最直接的方式来对世界进行建模，并且帮助他们优化和改进模型本身。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>对 Go 语言的综合评价</h2>

    <p>以前写过一些对 Go 语言的负面评价。现在看来，虽然那些评价大部分属实，然而却由于言辞激烈，没有点明具体问题，难以让某些人信服。在经过几个月实际使用 Go 来构造网站之后，我觉得现在是时候对它作一些更加“客观”的评价了。</p>

<h3>定位和优点</h3>

<p>Go 比起 C 和 C++ 确实有它的优点，这是很显然的事情。它比起 Java 也有少数优点，然而相对而言更多是不足之处。所以我对 Go 的偏好在比 Java 稍低一点的位置。</p>

<p>Go 语言比起 C，C++ 的强项，当然是它的简单性和垃圾回收。由于 C 和 C++ 的设计有很多历史遗留问题，所以 Go 看起来确实更加优雅和简单。比起那些大量使用设计模式的 Java 代码，Go 语言的代码也似乎更简单一些。另外，Go 的垃圾回收机制比起 C 和 C++ 的全手动内存管理来说，大大降低了程序员的头脑负担。</p>

<p>但是请注意，这里的所谓“优点”都是相对于 C 之类的语言而言的。如果比起另外的一些语言，Go 的这种优点也许就很微不足道，甚至是历史的倒退了。</p>

<h3>语法</h3>

<p>Go 的简单性体现在它的语法和语义的某些方面。Go 的语法比 C 要稍好一些，有少数比 Java 更加方便的设计，然而却也有“倒退”的地方。而且这些倒退还不被很多人认为是倒退，反而认为是进步。我现在举出暂时能想得起来的几个方面：</p>

<ul>
<li><p>进步：Go 有语法支持一种类似 struct literal 的构造，比如你可以写这样的代码来构造一个 S struct：</p>

<pre><code>S { x: 1, y: 2, }
</code></pre>

<p>这比起 Java 只能用构造函数来创建对象是一个不错的方便性上的改进。这些东西可能借鉴于 JavaScript 等语言的设计。</p></li>
<li><p>倒退：类型放在变量后面，却没有分隔符。如果变量和它的类型写成像 Pascal 那样的，比如 <code>x : int</code>，那也许还好。然而 Go 的写法却是 <code>x int</code>，没有那个冒号，而且允许使用 <code>x, y int</code> 这样的写法。这种语法跟 var，函数参数组合在一起之后，就产生了扰乱视线的效果。比如你可以写一个函数是这样开头的：</p>

<pre><code>  func foo(s string, x, y, z int, c bool) {
    ...
  }
</code></pre>

<p>注意 x, y, z 那个位置，其实是很混淆的。因为看见 <code>x</code> 的时候我不能立即从后面那个符号（<code>, y</code>）看到它是什么类型。所以在 Go 里面我推荐的写法是把 <code>x</code> 和 <code>y</code> 完全分开，就像 C 和 Java 那样，不过类型写在后面：</p>

<pre><code>  func foo(s string, x int, y int, z int, c bool) {
    ...
  }
</code></pre>

<p>这样一来就比较清晰了，虽然我愿意再多写一些冒号。每一个参数都是“名字 类型”的格式，所以我一眼就看到 x 是 int。虽然多打几个字，然而节省的是“眼球 parse 代码”的开销。</p></li>
<li><p>倒退：类型语法。Go 使用像 <code>[]string</code> 这样的语法来表示类型。很多人说这种语法非常“一致”，但经过一段时间我却没有发现他们所谓的一致性在哪里。其实这样的语法很难读，因为类型的各部分之间没有明确的分隔标识符，如果和其他一些符号，比如 * 搭配在一起，你就需要知道一些优先级规则，然后费比较大的功夫去做“眼球 parse”。比如，在 Go 代码里你经常看到 <code>[]*Struct</code> 这样的类型，注意 <code>*Struct</code> 要先结合在一起，再作为 <code>[]</code> 的“类型参数”。这种语法缺乏足够的分隔符作为阅读的“边界信号”，一旦后面的类型变得复杂，就很难阅读了。比如，你可以有 <code>*[]*Struct</code> 或者 <code>*[]*pkg.Struct</code> 这样的类型。所以这其实还不如像 C++ 的 <code>vector&lt;struct*&gt;</code> 这样的写法，也就更不如 Java 或者 Typed Racket 的类型写法来得清晰和简单。</p></li>
<li><p>倒退：过度地“语法重载”，比如 switch, for 等关键字。Go 的 switch 关键字其实包含了两种不同的东西。它可以是 C 里面的普通的 switch（Scheme 的 case），也可以是像 Scheme 的 cond 那样的嵌套分支语句。这两种语句其实是语义完全不同的，然而 Go 的设计者为了显得简单，把它们合二为一，而其实引起了更大的混淆。这是因为，就算你把它们合二为一，它们仍然是两种不同的语义结构。把它们合并的结果是，每次看到 switch 你都需要从它们“头部”的不同点把这两种不同的结构区分开来，增加了人脑的开销。正确的作法是把它们分开，就像 Scheme 那样。其实我设计语言的时候有时候也犯同样的错误，以为两个东西“本质”上是一样的，所以合二为一，结果经过一段时间，发现其实是不一样的。所以不要小看了 Scheme，很多你认为是“新想法”的东西，其实早就被它那非常严谨的委员会给抛弃在了历史的长河中。</p></li>
</ul>


<p>Go 语言里面还有其他一些语法设计问题，比如强制把 <code>{</code> 放在一行之后而且不能换行，if 语句的判断开头可以嵌套赋值操作等等。这些试图让程序显得短小的作法，其实反而降低了程序理解的流畅度。</p>

<p>所以总而言之，Go 的语法很难被叫做“简单”或者“优雅”，它的简单性其实在 Java 之下。</p>

<h3>工具链</h3>

<p>Go 提供了一些比较方便的工具。比如 gofmt，godef 等，使得 Go 代码的编程比起单用 Emacs 或者 VIM 来编辑 C 和 C++ 来说是一个进步。使用 Emacs 编辑 Go 就已经能实现某些 IDE 才有的功能，比如精确的定义跳转等等。</p>

<p>这些工具虽然好用，但比起像 Eclipse, IntelliJ 和 Visual Studio 这样的 IDE，差距还是相当大的。比起 IDE，Go 的工具链缺乏各种最基本的功能，比如列出引用了某个变量的所有位置，重命名等 refactor 功能，好用的 debugger （GDB 不算好用）等等。</p>

<p>Go 的各种工具感觉都不大成熟，有时候你发现有好几个不同的 package 用于解决同一个问题，搞不清楚哪一个好些。而且这些东西配置起来不是那么的可靠和简单，都需要折腾。每一个小功能你都得从各处去寻找 package 来配置。有些时候一个工具配置了之后其实没有起作用，要等你摸索好半天才发现问题出现在哪里。这种没有组织，没有计划的工具设计，是很难超过专业 IDE 厂商的连贯性的。</p>

<p>Go 提供了方便的 package 机制，可以直接 import 某个 GitHub repository 里的 Go 代码。不过我发现很多时候这种 package 机制带来的更多是麻烦事和依赖关系。所以 Go 的推崇者们又设计了一些像 godep 的工具，用来绕过这些问题，结果 godep 自己也引起一些稀奇古怪的问题，导致有时候新的代码其实没有被编译，产生莫名其妙的错误信息（可能是由于 godep 的 bug）。</p>

<p>我发现很多人看到这些工具之后总是很狂热的认为它们就能让 Go 语言一统天下，其实还差得非常之远。而且如此年轻的语言就已经出现这么多的问题，我觉得所有这些麻烦事累积下来，多年以后恐怕够呛。</p>

<h3>内存管理</h3>

<p>比起 C 和 C++ 完全手动的内存管理方式，Go 有垃圾回收（GC）机制。这种机制大大减轻了程序员的头脑负担和程序出错的机会，所以 Go 对于 C/C++ 是一个进步。</p>

<p>然而进步也是相对的。Go 的垃圾回收器是一个非常原始的 mark-and-sweep，这比起像 Java，OCaml 和 Chez Scheme 之类的语言实现，其实还处于起步阶段。</p>

<p>当然如果真的遇到 GC 性能问题，通过大量的 tuning，你可以部分的改善内存回收的效率。我也看到有人写过一些文章介绍他们如何做这些事情，然而这种文章的存在说明了 Go 的垃圾回收还非常不成熟。GC 这种事情我觉得大部分时候不应该是让程序员来操心的，否则就失去了 GC 比起手动管理的很多优势。所以 Go 代码想要在实时性比较高的场合，还是有很长的路要走的。</p>

<p>由于缺乏先进的 GC，却又带有高级的抽象，所以 Go 其实没法取代 C 和 C++ 来构造底层系统。Go 语言的定位对我来说越来越模糊。</p>

<h3>没有“generics”</h3>

<p>比起 C++ 和 Java 来说，Go 缺乏 generics。虽然有人讨厌 Java 的 generics，然而它本身却不是个坏东西。Generics 其实就是 Haskell 等函数式语言里面所谓的 parametric polymorphism，是一种非常有用的东西，不过被 Java 抄去之后有时候没有做得全对。因为 generics 可以让你用同一块代码来处理多种不同的数据类型，它为避免重复，方便替换复杂数据结构等提供了方便。</p>

<p>由于 Go 没有 generics，所以你不得不重复写很多函数，每一个只有类型不同。或者你可以用空 interface {}，然而这个东西其实就相当于 C 的 void* 指针。使用它之后，代码的类型无法被静态的检查，所以其实它并没有 generics 来的严谨。</p>

<p>比起 Java，Go 的很多数据结构都是“hard code”进了语言里面，甚至创造了特殊的关键字和语法来构造它们（比如哈希表）。一旦遇到用户需要自己定义类似的数据结构，就需要把大量代码重写一遍。而且由于没有类似 Java collections 的东西，无法方便的换掉复杂的数据结构。这对于构造像 PySonar 那样需要大量实验才能选择正确的数据结构，需要实现特殊的哈希表等数据结构的程序来说，Go 语言的这些缺失会是一个非常大的障碍。</p>

<p>缺少 generics 是一个问题，然而更严重的问题是 Go 的设计者及其社区对于这类语言特性的盲目排斥。当你提到这些，Go 支持者就会以一种蔑视的态度告诉你：“我看不到 generics 有什么用！”这种态度比起语言本身的缺点来说更加有害。在经过了很长一段时间之后 Go 语言的设计者们开始<a href="http://golang.org/doc/faq#generics">考虑加入 generics</a>，然后由于 Go 的语法设计偷工减料，再加上由于缺乏 generics 而产生的特例（比如 Go 的 map 的语法设计）已经被大量使用，我觉得要加入 generics 的难度已经非常大。</p>

<p>Go 和 Unix 系统一样，在出现的早期就已经因为不吸取前人的教训，背上了沉重的历史包袱。</p>

<h3>多返回值</h3>

<p>很多人都觉得 Go 的多返回值设计是一个进步，然而这里面却有很多蹊跷的东西。且不说这根本不是什么新东西（Scheme 很早就有了多返回值 let-values），Go 的多返回值却被大量的用在了错误的地方—Go 利用多返回值来表示出错信息。比如 Go 代码里最常见的结构就是：</p>

<pre><code>ret, err := foo(x, y, z)
if err != nil {
    return err
}
</code></pre>

<p>如果 <code>foo</code> 的调用产生了错误，那么 <code>err</code> 就不是 nil。Go 要求你在定义了变量之后必须使用它，否则报错。这样它“碰巧”避免了出现错误 <code>err</code> 而不检查的情况。否则如果你想忽略错误，就必须写成</p>

<pre><code>ret, _ := foo(x, y, z)
</code></pre>

<p>这样当 foo 出错的时候，程序就会自动在那个位置当掉。</p>

<p>不得不说，这种“歪打正着”的做法虽然貌似可行，从类型系统角度看，却是非常不严谨的。因为它根本不是为了这个目的而设计的，所以你可以比较容易的想出各种办法让它失效。而且由于编译器只检查 <code>err</code> 是否被“使用”，却不检查你是否检查了“所有”可能出现的错误类型。比如，如果 foo 可能返回两种错误 Error1 和 Error2，你没法保证调用者完全排除了这两种错误的可能性之后才使用数据。所以这种错误检查机制其实还不如 Java 的 exception 来的严谨。</p>

<p>另外，<code>ret</code> 和 <code>err</code> 同时被定义，而每次只有其中一个不是 nil，这种“或”的关系并不是靠编译器来保障，而是靠程序员的“约定俗成”。这样当 <code>err</code> 不是 nil 的时候，<code>ret</code> 其实也可以不是 nil。这些组合带来了挺多的混淆，让你每次看到 return 的地方都不确信它到底想返回一个错误还是一个有效值。如果你意识到这种“或”关系其实意味着你只应该用一个返回值来表示它们，你就知道其实 Go 误用了多返回值来表示可能的错误。</p>

<p>其实如果一个语言有了像 <a href="http://docs.racket-lang.org/ts-guide">Typed Racket</a> 和 <a href="http://yinwang0.wordpress.com/2010/09/12/pysonar">PySonar</a> 所支持的 “union type”类型系统，这种多返回值就没有意义了。因为如果有了 union type，你就可以只用一个返回值来表示有效数据或者错误。比如你可以写一个类型叫做 {String, FileNotFound}，用于表示一个值要么是 String，要么是 FileNotFound 错误。如果一个函数有可能返回错误，编译器就强制程序员检查所有可能出现的错误之后才能使用数据，从而可以完全避免以上的各种混淆情况。对 union type 有兴趣的人可以看看 Typed Racket，它拥有我迄今为止见过最强大的类型系统（超越了 Haskell）。</p>

<p>所以可以说，Go 的这种多返回值，其实是“歪打”打着了一半，然后换着法子继续歪打，而不是瞄准靶心。</p>

<h3>接口</h3>

<p>Go 采用了基于接口（interface）的面向对象设计，你可以使用接口来表达一些想要进行抽象的概念。</p>

<p>然而这种接口设计却不是没有问题的。首先跟 Java 不同，实现一个 Go 的接口不需要显式的声明（implements），所以你有可能“碰巧”实现了某个接口。这种不确定性对于理解程序来说是有反作用的。有时候你修改了一个函数之后就发现编译不通过，抱怨某个位置传递的不是某个需要的接口，然而出错信息却不能告诉你准确的原因。要经过一番摸索你才发现你的 struct  为什么不再实现之前定义的一个接口。</p>

<p>另外，有些人使用接口，很多时候不过是为了传递一些函数作为参数。我有时候不明白，这种对于函数式语言再简单不过的事情，在 Go 语言里面为什么要另外定义一个接口来实现。这使得程序不如函数式语言那么清晰明了，而且修改起来也很不方便。有很多冗余的名字要定义，冗余的工作要做。</p>

<p>举一个相关的例子就是 Go 的 <a href="http://golang.org/pkg/sort">Sort</a> 函数。每一次需要对某种类型 <code>T</code> 的数组排序，比如 <code>[]string</code>，你都需要</p>

<ol>
<li>定义另外一个类型，通常叫做 <code>TSorter</code>，比如 <code>StringSorter</code></li>
<li>为这个 <code>StringSorter</code> 类型定义三个方法，分别叫做 <code>Len</code>, <code>Swap</code>, <code>Less</code></li>
<li>把你的类型比如 <code>[]string</code> cast 成 <code>StringSorter</code></li>
<li>调用 <code>sort.Sort</code> 对这个数组排序</li>
</ol>


<p>想想 sort 在函数式语言里有多简单吧？比如，Scheme 和 OCaml 都可以直接这样写：</p>

<pre><code>(sort '(3 4 1 2) &lt;)
</code></pre>

<p>这里 Scheme 把函数 <code>&lt;</code> 直接作为参数传给 sort 函数，而没有包装在什么接口里面。你发现了吗，Go 的那个 interface 里面的三个方法，其实本来应该作为三个参数直接传递给 Sort，但由于受到 design pattern 等思想的局限，Go 的设计者把它们“打包”作为接口来传递。而且由于 Go 没有 generics，你无法像函数式语言一样写这三个函数，接受比较的“元素”作为参数，而必须使用它们的“下标”。由于这些方法只接受下标作为参数，所以 Sort 只能对数组进行排序。另外由于 Go 的设计比较“底层”，所以你需要另外两个参数: len 和 swap。</p>

<p>其实这种基于接口的设计其实比起函数式语言，差距是很大的。比起 Java 的接口设计，也可以说是一个倒退。</p>

<h3>goroutine</h3>

<p>Goroutine 可以说是 Go 的最重要的特色。很多人使用 Go 就是听说 goroutine 能支持所谓的“大并发”。</p>

<p>首先这种大并发并不是什么新鲜东西。每个理解程序语言理论的人都知道 goroutine 其实就是一些用户级的 "continuation"。系统级的 continuation 通常被叫做“进程”或者“线程”。Continuation 是函数式语言专家们再了解不过的东西了，比如我的前导师 Amr Sabry 就是关于 continuation 的顶级专家之一。</p>

<p>Node.js 那种 "callback hell"，其实就是函数式语言里面常用的一种手法，叫做 continuation passing style (CPS)。而我在 Friedman 课上写的那“40行代码”就是用来实现从普通程序到 CPS 程序的转化的。由于 Scheme 有 call/cc，所以从理论上讲，它可以不通过 CPS 样式的代码而实现大并发。</p>

<p>所以函数式语言只要支持 continuation，就会很容易的实现大并发，也许还会更高效，更好用一些。比如 Scheme 的一个实现 Gambit-C 就可以被用来实现大并发的东西。Chez Scheme 也许也可以，不过还有待确认。</p>

<p>当然具体实现上的效率也许有区别，然而我只是说，goroutine 其实并不是像很多人想象的那样全新的，革命性的，独一无二的东西。只要有足够的动力，其它语言都能添加这个东西。</p>

<h3>defer</h3>

<p>Go 实现了 defer 函数，用于避免在函数出错后忘了收拾残局（cleanup）。然而我发现这种 defer 函数有被滥用的趋势。比如，有些人把那种不是 cleanup 的动作也做成 defer，到后来累积几个 defer 之后，你就不再能一眼看得清楚到底哪块代码先运行哪块后运行了。位置处于前面的代码居然可以在后来运行，违反了代码的自然位置顺序关系。</p>

<p>当然这可以怪程序员不明白 defer 的真正用途，然而一旦你有了这种东西就会有人想滥用它。那种急于试图利用一个语言的每种 feature 的人，特别喜欢干这种事情。这种问题恐怕需要很多年的经验之后，才会有人写成书来教育大家。在形成统一的“代码规范”以前，我预测 defer 仍然会被大量的滥用。</p>

<p>所以我们应该想一下，为了避免可能出现的资源泄漏，defer 带来的到底是利多还是弊多。</p>

<h3>库代码</h3>

<p>Go 的标准库的设计里面带有浓郁的 Unix 气息。比起 Java 之类的语言，它的库代码有很多不方便的地方。有时候引入了一些函数式语言的方式，但却由于 Unix 思维的限制，不但没能发挥函数式语言的优点，而且导致了很多理解的复杂性。</p>

<p>一个例子就是 Go 处理字符串的方式。在 Java 里每个字符串里包含的字符，缺省都是 Unicode 的“code point”。然而在 Go 里面 string 类型里面每个元素都是一个 byte，所以每次你都得把它 cast 成“rune”类型才能正确的遍历每个字符，然后 cast 回去。这种把任何东西都看成 byte 的方式，就是 Unix 的思维方式，它引起过度底层和复杂的代码。</p>

<h3>HTML template 库</h3>

<p>我使用过 Go 的 template library 来生成一些网页。这是一种“基本可用”的模板方式，然而比起很多其他成熟的技术，却是相当的不足的。让我比较惊讶的是，Go 的 template 里面夹带的代码，居然不是 Go 语言自己，而是一种表达能力相当弱的语言，有点像一种退化的 Lisp，只不过把括号换成了  <code>{ {...} }</code> 这样的东西。</p>

<p>比如你可以写这样的网页模板：</p>

<pre><code>{ {define "Contents"} }
{ {if .Paragraph.Length} }
&lt;p&gt;{ {.Paragraph.Content} }&lt;/p&gt;
{ {end} }
{ {end} }
</code></pre>

<p>由于每个模板接受一个 struct 作为填充的数据，你可以使用 <code>.Paragraph.Content</code> 这样的代码，然而这不但很丑陋，而且让模板不灵活，不好理解。你需要把需要的数据全都放进同一个结构才能从模板里面访问它们。</p>

<p>任何超过一行的代码，虽然也许这语言可以表达，一般人为了避免这语言的弱点，还是在 .go 文件里面写一些“帮助函数”。用它们产生数据放进结构，然后传给模板，才能够表达模板需要的一些信息。而这每个帮助函数又需要一定的“注册”信息才能被模板库找到。所以这些复杂性加起来，使得 Go 的 HTML 模板代码相当的麻烦和混乱。</p>

<p>听说有人在做一个新的 HTML 模板系统，可以支持直接的 Go 代码嵌入。这些工作刚刚起步，而且难说最后会做成什么样子。所以要做网站，恐怕还是最好使用其他语言比较成熟的框架。</p>

<h3>总结</h3>

<p>优雅和简单性都是相对而言的。虽然 Go 语言在很多方面超过了 C 和 C++，也在某些方面好于 Java，然而它其实是没法和 Python 的优雅性相比的，而 Python 在很多方面却又不如 Scheme 和 Haskell。所以总而言之，Go 的简单性和优雅程度属于中等偏下。</p>

<p>由于没有明显的优势，却又有各种其它语言里没有的问题，所以在实际工程中，我目前更倾向于使用 Java 这样的语言。我不觉得 Go 语言和它的工具链能够帮助我迅速的写出 PySonar 那样精密的代码。另外我还听说有人使用 Java 来实现大并发，并没发现比起 Go 有什么明显的不足。</p>

<p>Alan Perlis 说，语言设计不应该是把功能堆积起来，而应该努力地减少弱点。从这种角度来看，Go 语言引入了一两个新的功能，同时又引入了相当多的弱点。</p>

<p>Go 也许暂时在某些个别的情况有特殊的强项，可以单独用于优化系统的某些部分，但我不推荐使用 Go 来实现复杂的算法和整个的系统。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>原因与证明</h2>

    <h3>证明</h3>

<p>我在 Cornell 的时候经常遇到这样的问题，那就是教授们一上课就在黑板上写长篇的“定理证明”，全体同学认认真真在下面抄笔记，就连只有十来个人的小课也是那样。有些写字速度慢的人就不得不带上小型录音机，把教授的课全都录下来，要不就是之后去借别人的笔记来抄。</p>

<p>有一次某知名教授照着讲义，背对着学生，在黑板上写了大半节课，写下好几板的证明，证明的是 simply typed lambda calculus （STLC）的 strong normalization 特性（SN）。刚写完就到下课时间了，他回过头来喘了一口气，说：“Any questions？”没有人啃声，于是他说：“很好！下课！”</p>

<p>几天后我问他，你证明了 STLC 有这个特性，然而你却没有告诉我它“为什么”有这个特性。他神气的看了我一眼：“你不懂吗？”我说：“你的证明我看懂了大部分，可是一个东西具有如此的性质，并不是因为你证明了它。这性质是它天生就有的，不管你是否能证明它。我想知道的是什么让 STLC 具有这个性质，而不只是证明它。”他说：“你问这样的问题有什么意义吗？你需要非常聪明，并且需要经过大量的努力才能想出这样的证明。”</p>

<h3>原因</h3>

<p>两年之后，我在 Indiana 上了另外一堂程序语言理论课。教授是我之前的导师 Amr Sabry。他上课从来不带讲义，貌似也没有准备，漫不经心的，却每次都能讲清楚问题的关键。于是有一天他也开始讲 STLC 的 SN 特性。他说，我不想写下这个证明让你们抄，我只告诉你们大概怎么去想。SN 的意思就是程序肯定会“终止”。所有会终止的程序，都会有一个“特征值”会随着程序的运行而减小。你需要做的就是找到 STLC 的“特征值”是什么。接着他就开始在黑板上画一个图……</p>

<p>过了一段时间，我不仅学会了这个“证明”，而且知道了 STLC 具有如此特性的“原因”。</p>

<h3>证明与原因的区别</h3>

<p>从以上的故事，以及你的亲身经历中，你也许注意到了大部分的教育过分的重视了“证明”，却忽略了比证明更重要的东西——“原因”。</p>

<p>原因往往比证明来得更加简单，更加深刻，但却更难发现。对于一个事实往往有多种多样的证明，然而导致这个事实的原因却往往只有一个。如果你只知道证明却不知道原因，那你往往就被囚禁于别人制造的理论里面，无法自拔。你能证明一个事物具有某种特性，然而你却没有能力改变它。你无法对它加入新的，好的特性，也无法去掉一个不好的特性。你也无法发明新的理论。有能力发明新的事物和理论的人，他们往往不仅知道“证明”，而且知道“原因”。</p>

<p>打个比方。证明与原因的区别，就像是犯罪的证据与它的原因的区别。证据并不是导致犯罪的原因。有了证据可以帮助你把罪犯绳之以法，可是如果你找不到他犯罪的原因，你就没法防止同样的犯罪现象再次发生。</p>

<p>古人说的“知其然”与“知其所以然”的区别，也就是同样的道理吧。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>几个超炫的专业词汇</h2>

    <p>从同事的<a href="http://thomas.tuerke.net/on/design/?thread=-701829031">博客</a>上学会了几个超炫的专业词汇，激动不已。觉得这些词汇可以言简意赅的概括我的好几篇博文，自己的文章水准真是自愧不如。现在来见识一下真正大师级的英语词汇：</p>

<ul>
<li><p>Yoda Notation（Yoda 表示法）</p>

<p><img src="http://www.yinwang.org/images/yoda-notation.jpeg" alt=""></p>

<p>在 C/C++ 里面使用这样的表达式顺序：</p>

<pre><code>if ("blue" == theSky) ...
</code></pre>

<p>这是为了避免意外的写成：</p>

<pre><code>if (theSky = "blue") ...
</code></pre>

<p>“Yoda 表示法”的名字来源于《星球大战》的 Yoda 大师。他说话的单词顺序相当奇特，比如：“Backwards it is, yes!”</p>

<p>同事认为：使用这个表示法是为了“变通”（wordaround） C/C++ 的一个设计抉择：使用 <code>=</code> 来表示赋值，而使用 <code>==</code> 来表示比较。这个设计充分的展现了“先辈的罪”（Sins of our Forefathers）这一词汇的精髓。</p>

<p>关于 Yoda 表示法我有不同的见解，请参考《<a href="http://www.yinwang.org/blog-cn/2013/04/14/yoda-notation">Yoda 表示法错在哪里</a>》。</p></li>
<li><p>Mental Speedbump（头脑减速杠）</p>

<p><img src="http://www.yinwang.org/images/speedbump.jpeg" alt=""></p>

<p>由于设计的不协调性造成的用户的注意力分散。比如，很多软件喜欢弹出一个窗口问你“是否继续？”</p></li>
<li><p>Pearl Effect （珍珠效应）</p>

<p><img src="https://encrypted-tbn2.gstatic.com/images?q=tbn:ANd9GcQbEqd7J07hkpTtp4Kz1njGM0GAo0_v7CFn04vLtfUtjUK7X5eSxQ" alt=""></p>

<p>珍珠是怎么形成的？是由于异物掉进了蛤蚌的外套膜和贝壳之间的夹层里面，没法排出来。异物不断的刺激该处的外套膜，又痒又痛，于是外套膜分泌珍珠质把异物包围起来，包了一层又一层。久而久之，就形成了珍珠。</p>

<p>在软件里面也有很多这样的“珍珠”。由于早期的挠人的设计错误，用户不得不采用一些“变通方案”（workaround）或者“附加过程”，这些就像珍珠质一样。久而久之，这些变通方案凝结起来，变成了“软件珍珠”，不了解它们来源的人都视之为宝贝。虽然产生于同样的原理，“软件珍珠”远远没有真正的珍珠那么好看。</p>

<p>（请比较：Sins of our Forefathers）</p></li>
<li><p>Sins of our Forefathers（先辈的罪）</p>

<p><img src="http://www.yinwang.org/images/sins-fathers.jpeg" alt=""></p>

<p>当时看起来合乎逻辑并且合情合理最后回顾起来却很傻b的历史遗留设计。</p>

<p>与“珍珠”相比，这些是有意识的加进去的，而不是不小心造成的，虽然这两者都会造成“变通”（workaround）。</p></li>
<li><p>Katrina Effect（卡特里娜飓风效应）</p>

<p><img src="https://encrypted-tbn1.gstatic.com/images?q=tbn:ANd9GcTU8qb9teH69EX14q2t2Y9hrW836MXxTWE7bN9Q2AQ-e9vpSLMB" alt=""></p>

<p>这个词描述的是一种飓风过后完全重头来过的悲惨景象。这种现象现在经常出现在重装或者升级软件之后，或者 Windows 安装完软件之后要你重启机器（关掉所有窗口）。</p></li>
<li><p>Workaround（变通）</p>

<p>  <img src="http://www.yinwang.org/images/workaround.png" alt=""></p>

<p>因为开发过程的失败而让用户必须进行的一些操作。这些通常是设计失误。</p></li>
<li><p>Jenga Code</p>

<p><img src="http://www.yinwang.org/images/jenga-code.jpg" alt=""></p>

<p>当你加上一小块代码之后，就整个垮掉的那种代码。</p>

<p>Jenga 是一种非常流行的 party 玩具，如图。它的工作原理是，先把那些小木条堆成一个规则的塔。然后，参加游戏的人轮流从下面抽出一块（只能用一只手）来放在最上面。谁放上之后木塔垮掉了，谁就“胜利”了。之后这个人就要做其他人想出来的一些“惩罚”，跟真心话大冒险那些事情差不多。</p></li>
<li><p><a href="http://en.wikipedia.org/wiki/Higgs_boson">Higgs-Bugson</a></p>

<p><img src="http://www.yinwang.org/images/higgs-boson.jpg"></p>

<p>一种假想中的 bug。它一般是跟据运行日志的少数记录和零星含糊的用户报告推测出来，但是在开发员的机器上很难重现。</p></li>
<li><p><a href="http://en.wikipedia.org/wiki/Heisenberg_uncertainty_principle">Heisenbug</a></p>

<p><img src="http://www.yinwang.org/images/heisenbug.png"></p>

<p>当你试图观察它的时候就突然消失或者改变行为特征的 bug。</p></li>
</ul>



  </body>
<h1>=======================================================<h1>
<body>

    <h2>RSS与三不主义</h2>

    <p>总有人来信要求我给博客增加 RSS，我都没有回答他们。其实这个博客最开头是有 RSS 的，但是后来去掉了。现在我稍微有点空，就来解释一下为什么我的博客没有 RSS 以及类似的“推送”机制。</p>

<p>其实不用 RSS 和不用微博的原因类似。本来博客是用来记录我的思想的，读者应该是因为感兴趣而不请自来的。他们想得起就来看看，想不起来就算了。根据“三不主义”的原则（不主动，不拒绝，不负责），来看文章的人如果不高兴了，那是不关我的事的。谁叫他们自己要来看呢？</p>

<p>可是有了 RSS 就不一样了，因为它转换了被动与主动的关系。本来读者是“主动”来看我的博客，我是“被动”的，是不需要负责的。然而一旦有了 RSS，每一次发布却感觉好像是我“主动”在推给他们看，是我很想让他们看一样，是要负责的。某些人取消关注别人的微博时，口气总是好像觉得自己关注一个人，是给了他很大的面子一样，所以他们用取消关注来表示他们的“惩罚”。这些人显然把自己看得太高贵了。</p>

<p>所以为了避免这种人，以及对其他人的心理产生类似的效果，我后来决定停止使用 RSS。虽然很多人使用 RSS 是一种良性的愿望，但是一旦有了 RSS，心理的变化是不由人的初衷决定的。所以要看我的博客，就必须自己想起来，然后主动到这个网址来查看，没有任何自动的更新功能。这样才能实现真正的三不主义 :P</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>创造者的思维方式</h2>

    <p>我不知道人们是怎么回事，缺乏想象力还是怎么的，所以我跟其他人对话常常遇到类似的问题。</p>

<p>我：A其实不怎么好。<br>
其他人：你说A不好，难道你要我用B？</p>

<p>（对于政治爱好者，如果A是资本主义，B就是社会主义；如果A是美国，B就是中国，等等。对于IT人员，如果A是Unix，B就是Windows；如果A是Vim，B就是Emacs；如果A是关系式数据库，B就是NoSQL数据库，等等……）</p>

<p>然后呢，这人就会深信我是B的拥鳖，进而产生敌意。这种对话越说越糊涂，越说越尴尬，越说我越觉得降低我的身份。</p>

<p>仔细分析之后，我发现了这问题的起因，其实是因为我跟其他人的思维方式是完全不同的。我总是从一个“创造者”的角度说话，而对方却站在“使用者”的角度。站的高度不同，当然就没法沟通，鸡同鸭讲。</p>

<p>创造者说“A其实不怎么好”，他的意思往往不是说你应该去“用”别的什么东西。他的意思其实是，A不怎么好，我可以把它的缺点去掉，“创造”一个更好的东西。这里的区别就在于“用”和“创造”的不同。使用者说“A不好”，是无可奈何的抱怨；创造者说“A不好”，却是对改进机遇的欣喜。可惜的是，使用者永远无法理解创造者的心，创造者的喜悦在使用者的头脑里，直接被“翻译”成了抱怨。</p>

<p>创造者拥有使用者没有的能力，他能够随心所欲的制造出新的事物，而不带有现存事物设计的思维枷锁。创造者因此具有比使用者更高的安全感，更深的远见，更豁达的胸襟。他不容易陷入非此即彼的“宗教冲突”，他不需要选择任何一个“阵营”，因为他对这种冲突的解决方案很简单：创造一个全新的宗教，消灭掉冲突的双方 :)</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>休息，休息一会儿</h2>

    <p><img src="http://www.yinwang.org/images/yixiu.jpg"></p>

<p>本人进入了比较长的，理所应得的休息和娱乐时间。无聊时也看看闲书和电影。这里推荐几个最近看的东西。</p>

<h3>《The Design of Everyday Things》</h3>

<p>最近给我最大影响的是这本1988年出版的《<a href="http://www.amazon.com/Design-Everyday-Things-Revised-Expanded-ebook/dp/B00E257T6C">The Design of Everyday Things</a>》（简称DOET）。有趣的是，它的作者 Don Norman 曾经是 Apple Fellow，也是《<a href="http://web.mit.edu/~simsong/www/ugh.pdf">The Unix-Haters Handbook</a>》一书序言的作者。</p>

<p>DOET 不但包含并且支持了我的博文《<a href="http://www.yinwang.org/blog-cn/2014/04/11/hacker-culture">黑客文化的精髓</a>》以及《<a href="http://www.yinwang.org/blog-cn/2014/01/25/pl-and">程序语言与……</a>》里的基本观点，而且提出了比《<a href="http://www.yinwang.org/blog-cn/2012/05/18/user-friendliness">什么是“对用户友好”</a>》更精辟可行的解决方案。</p>

<p>我觉得这应该是每个程序员必读的书籍。为什么每个程序员必读呢？因为虽然这本书是设计类专业的必读书籍，而计算机及其编程语言和工具，其实才是作者指出的缺乏设计思想的“重灾区”。看了它，你会发现很多所谓的“人为错误”，其实是工具的设计不合理造成的。一个设计良好的工具，应该只需要很少量的文档甚至不需要文档。这本书将提供给你改进一切事物的原则和灵感。你会恢复你的人性。</p>

<p>值得一提的是，虽然 Don Norman 曾经是 Apple Fellow，但我觉得 Apple 产品设计的人性化程度与 Norman 大叔的思维高度还是有一定的差距的。</p>

<p>如果你跟我一样不想用眼睛看书，可以到 Audible 买本<a href="http://www.audible.com/pd/Science-Technology/The-Design-of-Everyday-Things-Audiobook/B005I5MDGQ">有声书</a>来听。</p>

<h3>《The Conquest of Happiness》</h3>

<p>每个人都想得到快乐，但是他们往往误解了快乐的来源，追求了错误的东西，所以大多数人因此得到的是痛苦，并且给其他人带来痛苦。英国哲学家和数学家罗素写于1930年的《<a href="http://www.amazon.com/The-Conquest-Happiness-Bertrand-Russell/dp/0871401622">The Conquest of Happiness</a>》就是彻底的分析这些2014现代人的常见问题的。</p>

<p>在第一部分，罗素透彻的分析了几个常见的不快乐的原因：看破红尘，竞争，过度追求刺激，疲劳，嫉妒，罪恶感，被害妄想症，…… 第二部分，他提出了得到快乐的有效方法。</p>

<p>如果你认为自己没有这些问题，或者认为自己懂得这些是怎么回事，请再次反思一下，因为每个人都或多或少有这些问题。特别是我发现，竞争和攀比所带来的不快乐，在中国人里面是很普遍的现象。</p>

<h3>大独裁者</h3>

<p>谈到人性，我推荐卓别林在电影《<a href="https://www.youtube.com/watch?v=6FMNFvKEy4c">大独裁者</a>》里面的最后演讲。他引起了我对技术的价值的思考。有人说，世界不是毁在疯子手里就是毁在工作狂手里，是有一定的道理的。</p>

<h3>摩登时代</h3>

<p>其实比《大独裁者》更幽默，更有趣，对现代社会更有意义的，是卓别林的《<a href="http://www.amazon.com/Modern-Times-Charlie-Chaplin/dp/B004DARF6A">摩登时代</a>》。这样一部1930年代的黑白无声电影，道出了直到2014年的今天，世界上最大的问题：过度工作。</p>

<p>现代社会很多人为了所谓的“生存”，把自己变成了一台盲目不停工作的机器。加班加点的干活，并且还试图让别人也变成跟他一样。一切都是为了工作，为了效率，为了“优秀”，为了出人头地。太多的野心，太多的目标，却对身边最简单的乐趣视而不见。试试放慢匆忙的脚步，思考一下自己在干什么吧！</p>

<p>因为这些原因，我继续睡觉，这是拯救世界的最好办法 zZZZ</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>数学和编程</h2>

    <p>好些人来信问我，要成为一个好的程序员，数学基础要达到什么样的程度？十八年前，当我成为大学计算机系新生的时候，也为同样的问题所困扰。面对学数学，物理等学科的同学，我感到自卑。经常有人说那些专业的知识更加精华一些，难度更高一些，那些专业的人毕业之后如果做编程工作，水平其实比计算机系毕业的还要高。直到几年前深入研究程序语言之后，对这个问题我才得到了答案和解脱。由于好多编程新手遇到同样的困扰，所以我想在这里把这个问题详细的阐述一下。</p>

<h3>数学并不是计算机科学的基础</h3>

<p>很多人都错误的认为，计算机科学是数学的一个分支，数学是计算机科学的基础，数学是更加博大精深的科学。这些人以为只要学会了数学，编程的事情全都不在话下，然而事实却并非如此。</p>

<p>事实其实是这样的：</p>

<ul>
<li>计算机科学其实根本不是数学，它只不过借用了非常少，非常基础的数学，比高中数学还要容易一点。所谓“高等数学”，在计算机科学里面基本用不上。</li>
<li>计算机是比数学更加基础的工具，就像纸和笔一样。计算机可以用来解决数学的问题，也可以用来解决不是数学的问题，比如工程的问题，艺术的问题，经济的问题，社会的问题等等。</li>
<li>计算机科学是完全独立的学科。学习了数学和物理，并不能代替对计算机科学的学习。你必须针对计算机科学进行学习，才有可能成为好的程序员。</li>
<li>数学家所用的语言，比起常见的程序语言（比如C++，Java）来说，其实是非常落后而糟糕的设计。所谓“数学的美感”，其实大部分是夜郎自大。</li>
<li>99%的数学家都写不出像样的代码。</li>
</ul>


<h3>数学是异常糟糕的语言</h3>

<p>这并不是危言耸听。如果你深入研究过程序语言的理论，就会发现其实数学家们使用的那些符号，只不过是一种非常糟糕的程序语言。数学的理论有些是有用的，然而数学家门用于描述这些理论所用的语言，却是纷繁复杂，缺乏一致性，可组合性（composability），简单性，可用性。这也就是为什么大部分人看到数学就头痛。这不是他们不够聪明，而是数学语言的“<a href="http://www.yinwang.org/blog-cn/2015/03/17/design">设计</a>”有问题。人们学习数学的时候，其实只有少部分时间在思考它的精髓，而大部分时间是在折腾它的语法。</p>

<p>举一个非常简单的例子。如果你说cos<sup>2</sup>θ表示(cos θ)<sup>2</sup>，那么理所当然，cos<sup>-1</sup>θ就应该表示1/(cos θ)了？可它偏偏不是！别被数学老师们的教条和借口欺骗啦，他们总是告诉你：“你应该记住这些！” 可是你想过吗：“凭什么？” cos<sup>2</sup>θ表示(cos θ)<sup>2</sup>，而cos<sup>-1</sup>θ，明明是一模一样的形式，表示的却是arccos θ。一个是求幂，一个是调用反函数，风马不及，却写成一个样子。这样的语言设计混淆不堪，却喜欢以“约定俗成”作为借口。</p>

<p>如果你再多看一些数学书，就会发现这只是数学语言几百年累积下来的糟粕的冰山一角。数学书里尽是各种上标下标，带括号的上标下标，x，y，z，a，b，c，f，g，h，各种扭来扭去的希腊字母，希伯来字母…… 斜体，黑体，花体，双影体，……用不同的字体来表示不同的“类型”。很多符号的含义，在不同的子领域里面都不一样。有些人上一门数学课，到最后还没明白那些符号是什么意思。</p>

<p>很多人学习微积分都觉得困难，其实问题不在他们，而在于莱布尼兹（Leibniz）。莱布尼兹设计来描述微积分的语言（∫，dx, dy, ...），从现代语言设计的角度来看，其实非常之糟糕，可以说是一塌糊涂。我不能怪莱布尼兹，他毕竟是几百年前的人了，他不知道我们现在知道的很多东西。然而古人的设计，现在还不考虑改进，反而当成教条灌输给学生，那就是不思进取了。</p>

<p>数学的语言不像程序语言，它的历史太久，没有经过系统的，考虑周全的，统一的设计。各种数学符号的出现，往往是历史上某个数学家有天在黑板上随手画出一些古怪的符号，说这代表什么，那代表什么，…… 然后就定下来了。很多数学家只关心自己那块狭窄的子领域，为自己的理论随便设计出一套符号，完全不管这些是否跟其它子领域的符号相冲突。这就是为什么不同的数学子领域里写出同样的符号，却可以表示完全不同的涵义。在这种意义上，数学的语言跟Perl（一种非常糟糕的程序语言）有些类似。Perl把各种人需要的各种功能，不加选择地加进了语言里面，造成语言繁复不堪，甚至连Perl的创造者自己都不能理解它所有的功能。</p>

<p>数学的证明，使用的其实也是极其不严格的语言——古怪的符号，加上含糊不清，容易误解的人类语言。如果你知道什么是<a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">Curry-Howard Correspondence</a>就会明白，其实每一个数学证明都不过是一段代码。同样的定理，可以有许多不同版本的证明（代码）。这些证明有的简短优雅，有的却冗长繁复，像面条一样绕来绕去，没法看懂。你经常在数学证明里面看到“未定义的变量”，证明的逻辑也包含着各种隐含知识，思维跳跃，非常难以理解。很多数学证明，从程序的观点来看，连编译都不会通过，就别提运行了。</p>

<p>数学家们往往不在乎证明的优雅性。他们认为只要能证明出定理，你管我的证明简不简单，容不容易看懂呢。你越是看不懂，就越是觉得我高深莫测！这种思潮到了编程的时候就显出弊端了。数学家写代码，往往忽视代码的优雅性，简单性，模块化，可读性，性能，数据结构等重要因素，认为代码只要能算出结果就行。他们把代码当成跟证明一样，一次性的东西，所以他们的代码往往不能满足实际工程的严格要求。</p>

<h3>编程是一门艺术</h3>

<p>从上面你也许已经明白了，普通程序员使用的编程语言，就算是C++这样毛病众多的语言，其实也已经比数学家使用的语言高明很多。计算机科学并不是数学的一个分支，它在很大程度上是优于数学，高于数学的。有些数学的基本理论可以被计算机科学所用，然而计算机科学并不是数学的一部分。数学在语言方面带有太多的历史遗留糟粕，它其实是泥菩萨过河，自身难保，它根本解决不了编程中遇到的实际问题。</p>

<p>编程真的是一门艺术，因为它符合艺术的各种特征。艺术可以利用科学提供的工具，然而它却不是科学的一部分，它的地位也并不低于科学。和所有的艺术一样，编程能解决科学没法解决的问题，满足人们新的需求，开拓新的世界。所以亲爱的程序员们，别再为自己不懂很多数学而烦恼了。数学并不能帮助你写出好的程序，然而能写出好程序的人，却能更好的理解数学。我建议你们先学编程，再去看数学。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>关于语言的思考</h2>

    <p>之前写了那么多 Haskell 的不好的地方，却没有提到它好的地方，其实我必须承认我从 Haskell 身上学到了非常重要的东西，那就是对于“类型”的思考。虽然 Haskell 的类型系统有过于强烈的约束性，从一种“哲学”的角度（不是数学的角度）来看非常“不自然”，但如果一个程序员从来没学过 Haskell，那么他的脑子里就会缺少一种重要的东西。这种东西很难从除 Haskell，ML，Clean，Coq，Agda 以外的其它语言身上学到。</p>

<h3>Haskell 给我的<a href="http://www.yinwang.org/blog-cn/2013/04/12/inspiration">启发</a></h3>

<p>一个没有学过 Haskell 的 Scheme 程序员最容易犯的一个错误就是，把除 <code>#f</code>（Scheme 的逻辑“假”） 以外的任何值都作为 <code>#t</code>（Scheme 的逻辑“真”）。很多人认为这是 Scheme 的一个“特性”，可是殊不知这其实是 Scheme 的极少数缺点之一。如果你了解 Lisp 的历史，就会发现在最早的时候，Lisp 把 <code>nil</code>（空链表）这个值作为“假”来使用，而把 <code>nil</code> 以外的其它值都当成“真”。这带来了逻辑思维的混乱。</p>

<p>Scheme 对 Lisp 的这种混乱做法采取了一定的改进，所以在 Scheme 里面，空链表 <code>'()</code> 和逻辑“假”值 <code>#f</code> 被划分开来。这是很显然的事情，一个是链表，一个是 <code>bool</code>，怎么能混为一谈。Lisp 的这个错误影响到了很多其它的语言，比如 C 语言。C 语言把 0 作为“假”，而把不是 0 的值全都作为“真”。所以你就看到有些自作聪明的 C 程序员写出这样的代码：</p>

<pre><code>int i = 0;
...
...
if (i++) { ...}
</code></pre>

<p>Scheme 停止把 <code>nil</code> 作为“假”，却仍然把不是 <code>#f</code> 的值全都作为“真”。Scheme 的崇拜者一般都告诉你，这样做的好处是，你可以使用</p>

<pre><code>(or x y z)
</code></pre>

<p>这样的表达式，如果其中有一个不是 <code>#f</code>，那么这个表达式会直接返回它实际的值，而不只是 <code>#t</code>。然后你就可以写这样的代码：</p>

<pre><code>(cond
 [(or x y z)
  =&gt; (lambda (found)
       (do-something-with found))])
</code></pre>

<p>而不是：</p>

<pre><code>(let ([found (first-non-false x y z)])
  (cond
   [(not (eq? found #f))
    (do-something-with found)]))
</code></pre>

<p>第一段代码使用了 Scheme 的一个特殊“语法”，<code>=&gt;</code> 后面的 <code>(lambda (found) ...)</code> 会把 <code>(or x y z)</code> 返回的值作为它的参数 <code>found</code>，然后返回函数计算出的结果。第二段代码没有假设任何不是 <code>#f</code> 的值都是“真”，所以它不把 <code>(or x y z)</code> 放进 <code>cond</code> 的条件里，而是首先把它返回的值绑定到 <code>found</code>，然后再把这个值放进 <code>cond</code> 的条件。</p>

<p>这第二段代码比第一段代码多了一个 let，增加了一层缩进，貌似更加复杂了，所以很多人觉得把不是 <code>#f</code> 的值全都作为“真”这一做法是合理的。其实 Scheme 为了达到这个目的，恰好犯了“片面追求短小”的语言设计的小聪明（参考这篇<a href="http://www.yinwang.org/blog-cn/2013/03/15/language-design-mistake1">博文</a>）。为了让这种情况变得短小而损失类型的准确，这种代价是非常不值得的。</p>

<p>Haskell 的类型系统就是帮助你严密的思考类似关于类型的问题的。如果你从来没学过 Haskell，你就不会发现这里面其实有个类型错误。可是 Haskell 做得过分了一点，由于对类型推导，一阶逻辑和 category theory 等理论的盲目崇拜，Haskell 里面引入了很多不必要的复杂性。</p>

<p>各种各样的类型推导我设计过不下十个，其中有一些比 Haskell 强大很多。category theory 其实也不是什么特别有用的东西。很多数学家把它叫做“abstract nonsense”，就是说它太“通用”了，以至于相当于什么都没说。我曾经在一个晚上看完了整本的 category theory 教材，发现里面的内容我其实通过自己的动手操作（实现编译器，设计类型系统和静态分析等等），早就明白了。这里面的理论并不能带来对程序语言的简化。恰恰相反，它让程序语言变得复杂。</p>

<p>我对 Haskell 程序员的“天才态度”也感到厌倦，所以我不想再使用 Haskell，然而我的脑子里却留下了它“启发”我的东西。对 Haskell 的理解，让我成为了一个更好的 Scheme 程序员，更好的 Java 程序员，更好的 C++ 程序员，甚至更好的 shell 脚本程序员。我能够在任何语言里再现 Haskell 的编程方式的精髓。然而让我继续用 Haskell ，却就像是让我坐牢一样。本来很简单的事情，到 Haskell 里面就变成一些莫名其妙的新术语。Haskell 的设计者们的论文我大部分都看过，几分钟之内我就知道他们那一套东西怎么变出来的，其实里面很少有新的东西。大部分是因为 Haskell 引入的那些“新概念”（比如 monad）而产生的无须有的问题。世界上有比他们更聪明的人，更简单却更强大的理论。所以不要以为 Haskell 就是世界之巅。</p>

<p>怎么说呢，我觉得每个程序员的生命中都至少应该有几个月在静心学习 Haskell。学会 Haskell 就像吃几天素食一样。每天吃素食显然会缺乏全面的营养，但是每天都吃荤的话，你恐怕就永远意识不到身体里的毒素有多严重。</p>

<h3>专攻一门语言的害处</h3>

<p>我曾经对人说 C++ 里面其实有一些好东西，但是我没有说的是，C++ 里面的坏东西实在太多了。C++是一门“毒素”很多的语言，就像猪肉一样。</p>

<p>有些人从小写 C++，一辈子都在写 C++，就像每天每顿吃猪肉一样。结果是他们对 C++ 里面的“<a href="http://www.yinwang.org/blog-cn/2013/04/14/terminology">珍珠</a>”掌握的非常牢靠，以至于出现了一种“脑残”的现象——他们没法再写出逻辑清晰的程序。（这里“珍珠”是一个特殊的术语，它并不含有赞美的意思。请参考这篇<a href="http://www.yinwang.org/blog-cn/2013/04/14/terminology">博文</a>。）</p>

<p>比如，很多 C++ 程序员很精通 functor 的写法，可是其实 functor 只是由于 C++ 没有 first-class function 而造成的“变通”。C++ 的 functor 永远也不可能像 Scheme 的 lambda 函数一样好用。因为每次需要一个 functor 你都得定义一个新的 class，然后制造这个 class 的对象。如果函数里面有自由变量，那么这些自由变量必须通过构造函数放进 functor 的 field 里面，这样当 functor 内部的“主方法”被调用的时候，它才能知道自由变量的值。所以为此，你又得定义一些 field。麻烦了这么久，你得到的其实不过是 Scheme 程序员用起来就像呼吸空气一样的 lambda。</p>

<p>很多精通 functor 的 C++ 程序员认为会用 functor 就说明自己水平高。殊不知 functor 这东西不但是一个“变通”，而且是从函数式语言里面“学”过来的。在最早的时候，C++ 程序员其实是不知道 functor 这东西的。如果你考一下古就会发现，C++ 诞生于 1983 年，而 Scheme 诞生于 1975 年，Lisp 诞生于 1958 年。C++ 的诞生比 Scheme 整整晚了8年，然而 Scheme 一开始就有 lexical scoping 的 lambda。functor 只不过是对 lambda 的一种绕着弯的模仿。实际上 C++ 后来加进去的一些东西（包括 boost 库），基本上都是东施效颦。</p>

<p>记得2011年11月11日的良辰吉日，C++ 的创造者 Bjarne Stroustrup 在 Indiana 大学做了一个演讲，主题是关于 C++11 的新特性。当时我也在场，主持人 Andrew 是 boost 库的首席设计师之一（他后来有段时间当过我的导师）。他连夸 Stroustrup 会选日子，只遗憾演讲时间没有定在11点。</p>

<p>虽然我对 Stroustrup 的幽默感和谦虚的态度感到敬佩，但我也看出来 C++11 相对于像 Scheme 这样的语言，其实没有什么真正的“新东西”。大部分时候它是在改掉自己的一些坏毛病，然后向其它语言学习一些东西，然后把这些学习的痕迹掩盖起来。可是到最后，它仍然不可能达到其他语言那么原汁原味的效果。然而，由于 C++ 的普及程度高，现成的代码又多，它的地位和重要性还是一时难以动摇的。所以这些“<a href="http://www.yinwang.org/blog-cn/2013/04/14/terminology">先辈的罪</a>”，我们恐怕要用好几代人的工作才能弥补。</p>

<p>那么 C++ 有什么其他语言没有的好东西呢？其实非常少。我还是有空再讲吧。</p>

<h3>多学几种语言</h3>

<p>我今天想说其实就是，没有任何一种语言值得你用毕生的精力去“精通”它。“精通”其实代表着“脑残”——你成为了一个高效的机器，而不是一个有自己头脑的人。你必须对每种语言都带有一定的怀疑态度，而不是完全的拥抱它。每个人都应该学习多种语言，这样才不至于让自己的思想受到单一语言的约束，而没法接受新的，更加先进的思想。这就像每个人都应该学会至少一门外语一样，否则你就深陷于自己民族的思维方式。有时候这种民族传统的思想会让你深陷无须有的痛苦却无法自拔。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>编辑器与IDE</h2>

    <h3>无谓的编辑器战争</h3>

<p>很多人都喜欢争论哪个编辑器是最好的。其中最大的争论莫过于 Emacs 与 vi 之争。vi 的支持者喜欢说：“看 vi 打起字来多快，手指完全不离键盘，连方向键都可以不用。”Emacs 的支持者往往对此不屑一顾，说：“打字再快又有什么用。我在 Emacs 里面按一个键，等于你在 vi 里面按几十个键。”</p>

<p>其实还有另外一帮人，这些人喜欢说：“对于 Emacs 与 vi 之争，我的答案是 {jEdit， Geany, TextMate, Sublime...}”这些人厌倦了 Emacs 的无休止的配置和 bug，也厌倦了 vi 的盲目求快和麻烦的模式切换，所以他们选择了另外的更加简单的解决方案。</p>

<h3>临时解决方案 - IDE</h3>

<p>那么我对此的答案是什么呢？在目前的情况下，我对程序编辑的临时答案是：IDE。</p>

<p>写程序的时候，我通常根据语言来选择最能“理解”那种语言的“IDE”（比如 Visual Studio, Eclipse, IntelliJ IDEA 等），而不是一种通用的“文本编辑器”（比如 Emacs, vi, jEdit, ...）。这是因为“文本编辑器”这种东西一般都不真正的理解程序语言。很多 Emacs 和 vi 的用户以为用 etags 和 ctags 这样的工具就能让他们“跳转到定义”，然而这些 tags 工具其实只是对程序的“文本”做一些愚蠢的正则表达式匹配。它们根本没有对程序进行 parse，所以其实只是在进行一些“瞎猜”。简单的函数定义它们也许能猜对位置，但是对于有重名的定义，或者局部变量的时候，它们就力不从心了。</p>

<p>很多人对 IDE 有偏见，因为他们认为这些工具让编程变得“傻瓜化”了，他们觉得写程序就是应该“困难”，所以他们眼看着免费的 IDE 也不试一下。有些人写 Java 都用 Emacs 或者 vi，而不是 Eclipse 或者 IntelliJ。可是这些人错了。他们没有意识到 IDE 里面其实蕴含了比普通文本编辑器高级很多的技术。这些 IDE 会对程序文本进行真正的 parse，之后才开始分析里面的结构。它们的“跳转到定义”一般都是很精确的跳转，而不是像文本编辑器那样瞎猜。</p>

<p>这种针对程序语言的操作可以大大提高人们的思维效率，它让程序员的头脑从琐碎的细节里面解脱出来，所以他们能够更加专注于程序本身的语义和算法，这样他们能写出更加优美和可靠的程序。这就是我用 Eclipse 写 Java 程序的时候相对于 Emacs 的感觉。我感觉到自己的“心灵之眼”能够“看见”程序背后所表现的“模型”，而不只是看到程序的文本和细节。所以，我经常发现自己的头脑里面能够同时看到整个程序，而不只是它的一部分。我的代码比很多人的都要短很多也很有很大部分是这个原因，因为我使用的工具可以让我在相同的时间之内，对代码进行比别人多很多次的结构转换，所以我往往能够把程序变成其他人想象不到的样子。</p>

<p>对于 Lisp 和 Scheme，Emacs 可以算是一个 IDE。Emacs 对于 elisp 当然是最友好的了，它的 Slime 模式用来编辑 Common Lisp 也相当不错。然而对于任何其它语言，Emacs 基本上都是门外汉。我大部分时间在 Emacs 里面是在写一些超级短小的 Scheme 代码，我有自己的一个简单的<a href="http://www.yinwang.org/blog-cn/2013/04/11/scheme-setup">配置方案</a>。虽然谈不上是 IDE，Emacs 编辑 Scheme 确实比其它编辑器方便。R. Kent Dybvig 写 Chez Scheme 居然用的是 vi，但是我并不觉得他的编程效率比我高。我的代码很多时候比他的还要干净利落，一部分原因就是因为我使用的 ParEdit mode 能让我非常高效的转换代码的“形状”。</p>

<p>当要写 Java 的时候，我一般都用 Eclipse。最近写 C++ 比较多，C++ 的最好的 IDE 当然是 Visual Studio。可惜的是 VS 没有 Linux 的版本，所以就拿 Eclipse 凑合用着，感觉还比较顺手。个别情况 Eclipse “跳转定义”到一些完全不相关的地方，对于 C++ 的 refactor 实现也很差，除了最简单的一些情况（比如局部变量重命名），其它时候几乎完全不可用。当然 Eclipse 遇到的这些困难，其实都来自于 C++ 语言本身的糟糕设计。</p>

<h3>终极解决方案 - 结构化编辑器</h3>

<p>想要设计一个 IDE，可以支持所有的程序语言，这貌似一个不大可能的事情，但是其实没有那么难。有一种叫做“结构化编辑器”的东西，我觉得它可能就是未来编程的终极解决方案。</p>

<p>跟普通的 IDE 不同，这种编辑器可以让你直接编辑程序的 AST 结构，而不是停留于文本。每一个界面上的“操作”，对应的是一个对 AST 结构的转换，而不是对文本字符的“编辑”。这种 AST 的变化，随之引起屏幕上显示的变化，就像是变化后的 AST 被“pretty print”出来一样。这些编辑器能够直接把程序语言保存为结构化的数据（比如 S表达式，XML 或者 JSON），到时候直接通过对 S表达式，XML 或者 JSON 的简单的“解码”，而不需要针对不同的程序语言进行不同的 parse。这样的编辑器，可以很容易的扩展到任何语言，并且提供很多人都想象不到的强大功能。这对于编程工具来说将是一个革命性的变化。</p>

<ul>
<li><p>已经有人设计了这样一种编辑器的模型，并且设计的相当不错。你可以参考一下这个<a href="http://blogs.msdn.com/b/kirillosenkov/archive/2009/09/08/first-videos-of-the-structured-editor-prototype.aspx">结构化编辑器</a>，它包含一些 Visual Studio 和 Eclipse 都没有的强大功能，却比它们两者都要更加容易实现。你可以在这个网页上下载这个编辑器模型来试用一下。</p></li>
<li><p>我之前推荐过的 <a href="http://www.yinwang.org/blog-cn/2012/09/18/texmacs">TeXmacs</a> 其实在本质上就是一个“超豪华”的结构化编辑器。你可能不知道，TeXmacs 不但能排版出 TeX 的效果，而且能够运行 Scheme 代码。</p></li>
<li><p>IntelliJ IDEA 的制造者 JetBrains 做了一个结构化编辑系统，叫做 <a href="http://www.jetbrains.com/mps">MPS</a>。它是开源软件，并且可以免费下载。</p></li>
<li><p>另外，Microsoft Word 的创造者 Charles Simonyi 开了一家叫做 <a href="http://www.intentsoft.com/intentional-technology/meta">Intentional Software</a> 的公司，也做类似的软件。</p></li>
</ul>



  </body>
<h1>=======================================================<h1>
<body>

    <h2>解密“设计模式”</h2>

    <p>有些人问我，你说学习操作系统的最好办法是学习程序设计。那我们是不是应该学习一些“设计模式”（design patterns）。这是一个我很早就有定论，而且经过实践检验的问题，所以想在这里做一个总结。</p>

<p>总的来说，如果光从字面上讲，程序里确实是有一些“模式”可以发掘的。因为你总是可以借鉴以前的经验，用来构造新的程序。你可以把这种经验叫做“模式”。可是自从《设计模式》（通常叫做 GoF，“Gang of Four”，“四人帮”）这本书在 1994 年发表以来，“设计模式”这个词有了新的，扭曲的含义。它变成了一种教条，带来了公司里程序的严重复杂化以及效率低下。</p>

<p><img src="http://www.yinwang.org/images/design-patterns.jpeg" alt="Design Patterns"></p>

<p>GoF 借鉴的是一个叫 Christopher Alexander 的建筑师的做法。Alexander 给一些建筑学里的“设计模式”起了名字，试图让建筑师们有一些“共同语言”。可惜的是，Alexander 后来自己都承认，他的实验失败了。因为这些固定的模式，并没能有效地传递精髓的知识，没能让新手成长为出色的建筑师。</p>

<p>照搬模式东拼西凑，而不能抓住事物的本质，没有“灵感”，其实是设计不出好东西的。这就像照搬“模版”把作文写得再好，也成不了作家一样。</p>

<p>我孤陋寡闻，当听说这本书的时候，我已经学会了函数式编程，正在 Cornell 读 PhD，专攻程序语言设计。有一天由于好奇这书为什么名气这么大，我从图书馆借了一本回来看。我很快的发现，其实这本书的作者只是给早已经存在的编程方法起了一些新的名字而已。当时我就拿起一张纸，把所有的20来个设计模式跟我常用的编程概念做了一个映射。这个映射居然是“多对一”（many-to-one）的。也就是说，多个 GoF 设计模式，居然只对应同一个我每天都用的概念。有些概念是如此的不值一提，以至于我根本不需要一个名字来描述它，更不要说多个名字！</p>

<p>其中极少数值得一提的“模式”，也许是 visitor 和 interpreter。很可惜的是，只有很少的人明白如何使用它们。所谓的 visitor，本质上就是函数式语言里的含有“模式匹配”（pattern matching）的递归函数。在函数式语言里，这是多么轻松的事情。可是因为 Java 没有模式匹配，所以很多需要类似功能的人就得使用 visitor pattern。为了所谓的“通用性”，他们往往把 visitor pattern 搞出多层继承关系，让你转几道弯也搞不清楚到底哪个 visitor 才是干实事的。</p>

<p>其实，函数式语言的研究者们早就知道 visitor pattern 是怎么得来的。如果你想知道如何从无到有，一步一步“发明”出 Java 的 visitor pattern，可以参考 Dan Friedman 跟他的学生 Matthias Felleisen 合写的的另一本“小人书”《A Little Java, A Few Patterns》（发表于 1997 年）。</p>

<p><img src="http://www.yinwang.org/images/the-little-java.jpeg" alt="little java"></p>

<p>而 interpreter （解释器）模式呢？看了作者们写的例子程序之后，我发现他们其实并不会写解释器，或者说他们不知道如何写出优雅的，正确的解释器。如果你想知道如何写出好的解释器，可以参考我的博文《怎样写一个解释器》。</p>

<p>你说我在贬低这本书的真正价值，因为 GoF 说了：“我们的贡献，就是给这些编程方式起名字。这样让广大程序员有共同的语言。” 如果这也叫贡献的话，我就可以写本书，给“空气”，“水”，“猪肉”这些东西全都起个新名字，让大家有“共同的语言”。这不是搞笑吗。</p>

<p>这不是我的一家之言，Peter Norvig 在 1998 年就做了一个演讲，指出在“动态语言”里面，GoF 的20几个模式，其中绝大部分都“透明”了。也就是说，你根本感觉不到它们的存在。这就像我刚才告诉你的。</p>

<p><img src="http://www.yinwang.org/images/norvig-patterns.png" alt="Norvig talk"></p>

<p>在这里 Norvig 的观点是正确的，不过需要小心一个概念错误。Norvig 对“静态语言”的概念是有局限性的。有的静态语言其实也能传递函数作为参数，而且不像 Java 那样什么都得放进 class 里。这样的静态语言，其实也可以避免大部分 GoF 设计模式。而“动态语言”这个概念，在程序语言的理论里面，其实是没有明确的定义的。“动态语言”其实也能进行某些“静态类型检查”。不过在 1998 年，我还是个啥都不懂的屁孩，所以这里就不跟 Norvig 大叔计较了。</p>

<p>既然老人们都有历史局限性，那么为啥我还跟 GoF 找茬？本来这本书很老了，如果没有人再被它误导的话，这篇博文也就不必存在了。可是当我在 Google 实习的时候，我发现几乎每个程序员的书架上都有一本 GoF！我在 Google 实习了两次，第一次的时候代码全都是我一个人写的，所以没有使用任何 GoF 设计模式。代码直接，精巧而简单。当我第二次回到 Google，发现我的代码里已经被加入了各种 factory，visitor，…… 其实啥好事也没做，只不过让我的代码弯了几道弯，让人难以理解。</p>

<p>可见一本坏书，毁掉的不只是一代程序员。鉴于如此，特发此文。各位新手，希望你们敲响警钟，不要再走上这条老路，写出代码来让大家痛苦。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>SQL，NoSQL 以及数据库的实质</h2>

    <p>在之前的一些博文里（比如<a href="http://www.yinwang.org/blog-cn/2013/11/08/voxer-sg">这篇</a>），我多次提到关系式数据库和 SQL 的缺陷。我觉得它们是制造了问题又自己来解决，而且没有解决好。现在有了点时间，我就把这里面的细节稍微说一下，希望有一定的启发作用。</p>

<h3>描述性语言的局限性</h3>

<p>当我指出 SQL 的问题时，总是避免不了有人反驳说：“SQL 是描述性的语言。你只告诉它 What，而不是告诉它 How。”我发现总是有人对一些我多年前就听腻了，看透了的“广告词”执迷不悟，而现在这同样的事又发生在 SQL 身上。他们没有发现，我不但能实现 SQL，而且已经实现过比 SQL 强大很多的语言（逻辑式语言），所以我其实早已看透了所有这些语言的实质，我知道那些广告词在很大程度上是误导。</p>

<p>现在我就来分析一下 SQL 与逻辑式语言之间的关系，并且找出这类“描述性语言”共同的弱点。</p>

<h4>Prolog 与人工智能的没落</h4>

<p>可以说，“只告诉它 What，而不是告诉它 How”，只是一个不切实际的妄想，而且它并不是 SQL 首创的口头禅。在 SQL 诞生两年以前，有人发明了 Prolog，著名的“逻辑式语言运动”的先锋。Prolog 使用了与 SQL 非常类似的广告词，声称自己能够一劳永逸的解决人工智能和自动编程的问题，这样人们不需要写程序，只需要告诉电脑“想要什么”，然后电脑就能自动生成算法，自动生成代码来解决这问题。</p>

<p>不需要理解数据结构和算法，直接告诉电脑需要什么，它就给你答案，这是多么美妙的事情。世界上总是有很多这种类似“减肥药”的东西，每一个都声称自己是“不需运动，不需节食，一个星期瘦 20 斤！”然而由于人类的智力和经验参差不齐，总会有人上当。Prolog 当年的风头之大，以至于它被日本政府采用并且大力推广，作为他们所谓的“第五代计算机”的编程语言。可惜的是，减肥药毕竟是减肥药，科学道理决定了 Prolog 必定失败，以及“人工智能冬天”（AI winter）的到来。</p>

<p>为什么 Prolog 会失败呢？这是因为 Prolog 虽然“终究”有可能自动解决某些问题，然而由于它的算法复杂度太高，所以没法在我们有生之年完成。说白了，Prolog 采用的“计算”方式就是“穷举法”。为了得到用户“描述”的问题的答案，而不需要用户指定具体的数据结构和算法，Prolog 必须对非常大的图状解空间进行完全的遍历（Prolog 采用深度优先搜索）。而这种解空间的“状态”数量往往是与程序运行时路过的分支数目成指数关系，这就决定了 Prolog 虽然“最终”可能找到问题的答案，却很有可能在地球毁灭之前都没法完成它的搜索。而且由于 Prolog 无法表达真正意义上的“逻辑否”操作，所以对于很多问题它永远无法得到正确的答案（这是一个非常深入的问题，30 多年的研究，仍然没有结果）。</p>

<p>过于具体的细节我不想在这里解释，你只需要明白的是我绝不是在信口开河。在 Indiana 的日子里，我重新实现，并且扩展了一种与 Prolog 类似的逻辑式语言，叫做 miniKanren。它也就是 Dan Friedman 的新书《<a href="http://www.amazon.com/The-Reasoned-Schemer-Daniel-Friedman/dp/0262562146">The Reasoned Schemer</a>》的主题。在两三个星期的时间内，我不但完全重写了 miniKanren 的代码（代码见<a href="https://github.com/yinwang0/ykanren">这里</a>），而且为它加入了一种技术叫做 constraint logic programming，并且在那之上实现了一个非常干净利落的“逻辑否”操作。经过这番动手操作，我对 miniKanren 和逻辑式语言的工作方式可以说是了如指掌。虽然 miniKanren 比起 Prolog 更加优雅，而且在搜索算法上有所改进（广度优先而非深度优先），它本质上采用的计算方式也是一样的：穷举法。所以在很多时候它的效率很低，用法不灵活。像 Prolog 一样，miniKanren 并不能用来解决很多实际的问题。有些很简单的 Scheme 代码，你却不能把它翻译成等价的 miniKanren。然而就是这样一种语言，比起 SQL 的表达能力，其实也是天上地下。所以在实现并且扩展了 miniKanren 这样的“智能语言”之后再来看 SQL，对于我来说就像是在解剖一只青蛙。</p>

<p>这里只举一个例子，说明我所看到的所谓“描述性语言”的局限，看不懂的人可以暂时跳过。在 IU 的时候总有一些人喜欢用 miniKanren 来实现 Haskell 和 OCaml 的 <a href="http://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system">Hindley-Milner 类型系统</a>（HM 系统）。HM 那种最基本的基于 unification 的类型推导，miniKanren 确实能做到，因为 miniKanren，Prolog 和 HM 系统一样，都是基于 <a href="http://en.wikipedia.org/wiki/Robinson%27s_unification_algorithm">Robinson unification 算法</a>。这种算法虽然精巧，表达能力却是非常有限的。如果遇到一些必要的扩展，比如 HM 系统所需要的 let-polymorphism，你就需要对 miniKanren 语言本身进行扩展。也就是说，你不再是用 miniKanren 实现你的算法，而是用一种过程式或者函数式语言（比如 Scheme）把你的算法加到 miniKanren 里面作为“语言特性”，然后再利用这个你刚实现的新特性来“实现”你的算法。于是你就发现，其实 miniKanren 本身并没有足够的表达力表示完整的 HM 类型推导算法。如果 miniKanren 必须经过 Scheme 扩展才能表达 HM 算法，那么比起直接的 Scheme 实现，miniKanren 并没有任何优势。一个新的语言特性要有价值，它必须能够在很多地方使用。然而这些 miniKanren 的扩展，每一个只能用到一个地方。所以它们其实完全失去了作为语言特性的价值，还不如直接写一段 Scheme 代码。</p>

<p>这也就是为什么虽然我很感谢 miniKanren 教会了我逻辑编程的原理，然而我实现过的所有强大的类型系统（有些的能力大大超过 HM 系统），全都是用最普通的过程式或者函数式语言。“描述性语言”声称的好处，其实在这种关键时刻总是微乎其微，还不如调用普通语言的库代码。</p>

<h4>从  Prolog 到 SQL</h4>

<p>扯了这么多 Prolog 和 miniKanren 的事情，这跟关系式数据库和 SQL 的讨论到底有何关系呢？其实，这些东西是有非常深层次的内在联系的。一个有趣的事情是，miniKanren 里面的“Kanren”一词并不是一个英语国家的人名，而是日语“<a href="http://en.wiktionary.org/wiki/%E9%96%A2%E9%80%A3">関連</a>”（かんれん，读作 kanren）。而“逻辑式语言”的另一个名字，其实叫做“关系式语言”（relational language）。</p>

<p>在数学上，“关系”（relation）意味着“没有方向”，意味着“可逆”。然而具有讽刺意味的是，所谓的“关系式数据库”并不具有这种可逆计算的能力。Prolog 和 miniKanren 其实是比 SQL 强大很多的语言，是真正的“关系式语言”，它们能够在比较大的程度上完成可逆计算。比如在 miniKanren 里面，你可以使用这样“查询操作”：如果 x+y 等于 10，y 等于 2，那么 x 等于几？很多 Prolog 和 miniKanren 可以表达的查询，SQL 没法表示。SQL 其实只能用于非常简单的，有“明确方向”的查询操作，基本上就像 Lisp 的 filter 函数。由于这些局限性，再加上很多其他的设计失误（比如语法像英语，组合能力弱），它只适合会计等人员使用，一旦遇到程序员需要的，稍微复杂一点的数据结构，它就没法表达了，而且会像 Prolog 一样引起诸多的性能问题。</p>

<p>由于 SQL 比起逻辑式语言有更多的限制，表达力弱很多，再加上 SQL 对于基本的数据结构进行了“索引”，逻辑式语言的性能问题在 SQL 里面得到了局部的缓解。比如，对于基本的算数操作  <code>x &lt; 10</code>，SQL 能够通过对索引（B树）的查找来进行“优化”，从而避免了对  <code>x</code> 所有可能的值（一个非常大的空间）进行完全的遍历。然而这种索引的能力是非常有限的，它几乎没有扩展能力，而且很难自动生成。所以一旦遇到更加复杂的情况，数据库自带的索引就没法满足需要了。除了极其简单的情况，SQL 的编译器无法自动生成高效的索引。</p>

<p>更要命的是，这种问题的来源是根本性的，不可解决的，而不只是因为某些数据库的 SQL 编译器不够“智能”。很多人不理解这一点，总是辩论说“我们为何需要 Java 而不是写汇编，也就是我们为何需要 SQL。”然而，把 Java 编译成高效的汇编，和把 SQL 编译成高效的汇编，是两种本质上不同的问题。前者可以比较容易的解决，而后者是不可能的（除了非常个别的情况）。如果你理解“编译器优化”的本质就会发现，这里面有一个拓扑学上的质的飞跃。把 Java 编译成高效的汇编，是一个非常简单的，线性的优化。这个过程就像改进一个已经连接好的电路，把里面太长的电线缩短一点，这样时延和电阻可以小一些。而把 SQL 优化成高效的汇编，是一个非线性的优化。这个过程不只是缩短电线那么简单的问题，它需要解开一些错综复杂的“结”。这种优化不但非常难以实现，需要大量的“潜在数学知识”，而且有可能花费比执行代码还多的时间。</p>

<p>我只举一个例子来说明这个问题。如果你需要迅速地在地图上找到一个点附近的城市，SQL 无法自动在平面点集上建造像 KD-tree 那样的数据结构。这是很显然的，因为 SQL 根本就不知道你的数据所表示的是平面上的点集，也不理解平面几何的公理和定理。跟 B-tree 类似，知道什么时候需要这种特殊的索引结构，需要非常多的潜在数学知识（比如高等平面几何），所以你肯定需要手动的建立这种数据结构。你发现了吗，你其实已经失去了所谓的“描述性”语言带来的好处，因为你完全可以用最普通的语言，加上一些构造 B-tree, KD-tree 的“库代码”，来实现你所需要的所有复杂查询操作。你的 SQL 代码并不会比直接的过程式代码更加清晰和简洁。再加上 SQL 本身的很多设计失误，你就发现使用 SQL 数据库其实比自己手工实现这些数据结构还要痛苦。你学会 SQL 是为了避免编程，结果你不得不做比编程还要苦逼的工作，还美其名曰“performance tuning”。</p>

<p>到这里也许有人仍然会说，这只是因为现在的 SQL 编译器不够智能，总有一天我们能够制造出能够“自动发明”像 B-tree, KD-tree 这样索引结构的“优化算法”。我对此持非常不乐观的态度。首先你要意识到，哪怕最基本的数学知识，也是经过了人类几千年的实践，研究和顿悟才得到的。计算机虽然越来越快，它却缺乏对于世界最直接的观察和探索能力，所以在相当长的时间内，计算机是根本不可能自动“想到”这些数学和算法问题的，就不要谈解决它们。其次，即使计算机有一天长了脚可以走路，有了眼睛可以看见东西，有了“自由意志”，可以自己去观察世界，它却不一定能够发现并且解决“人类关心的数学问题”，因为它根本不知道人类需要什么。最后，我们需要在有生之年解决这些迫切的问题，我们无法等待几十年几百年，就为了让计算机自己想出像 KD-tree 一类众所皆知的数据结构。</p>

<p>计算机不可能猜到人类到底想要什么，这就是为什么你几乎总是需要手动指定索引的原因，而且这种索引需要数据库“内部支持”。你一次又一次的希望 SQL 能够自动为你生成高效的索引和算法，却一次又一次的失望，也就是这个原因。当然，你永远可以使用所谓的 stored procedure 来扩展你的数据库，然而这就像是我的 IU 同学们用 miniKanren 来实现 HM 类型系统的方式——他们总是先使用一种过程式语言（Scheme）来添加这种描述性语言的“相关特性”，然后欢呼：“哇，miniKanren 解决了这个问题！”而其实呢，还不如直接使用过程式语言来得直接和容易。</p>

<p>这种总是需要扩展的显现也出现在数据库的语言里面。经验告诉我，如果想数据库处理大量数据时达到可以接受的性能，你几乎总是需要使用普通语言对手头的数据库进行所谓的“扩展”，然后从 SQL 等查询语言“调用”它们。这种扩展代码往往是一次性的，只能用在一个地方，从而使得这些查询语言失去了存在的意义。因为如果经常如此，我们为何不直接发送这种过程语言到数据库里面执行，从而完全取代 SQL？</p>

<p>另外有一种数据库查询语言叫 Datalog，它结合了 SQL 和 Prolog 的特点。然而以上对于 SQL 和 Prolog 的分析，同样也适用于 Datalog。</p>

<h3>关系模型的实质</h3>

<p>每当我批评 SQL，就有人说我其实不理解关系模型，说关系模型本身并没有问题，所以现在我就来分析一下什么是关系模型的实质。其实关系模型比起逻辑式语言，基本就是个衍生产物，算不上什么发明。关系代数其实对应逻辑式语言里面的一个很小的部分——它的数据结构及其基本操作，只不过关系模型有更大的局限性而已。所以学会了逻辑式语言的设计之后，你直接就可以把关系模型这种东西想出来。</p>

<p>每当谈到关系模型，总是有人很古板的追究它与 SQL，Datalog 等“查询语言”的区别。然而如果你看透了逻辑式语言的本质就会发现，其实“语言”和“模型”这两者并没有本质区别和明确界限。人们总是喜欢制造这些概念上的壁垒，用以防止自己的理论受到攻击。追究语言和模型的差别，把过错推到 SQL 和 IBM 身上，是关系式数据库领域常见的托词，用以掩盖其本质上的空洞和设计上的失误。所以在下面的讨论里为了方便，我仍然会使用少量 SQL 来表示关系模型里面对应的概念，但这并不削弱我对关系模型的批评。</p>

<h4>关系模型与逻辑式语言</h4>

<p>我们先来具体探讨一下关系模型与逻辑式语言的强弱关系。之前我们已经提到了，关系式数据库所谓的“关系”，比起逻辑式语言来说，其实是小巫见大巫。关系式数据库的表达能力，绝对不会超过逻辑式语言。关系式代数里面的“=”，join 等构造都是没有方向的。然而与逻辑式语言不同，这些“可逆操作符”在关系代数里的用法受到非常大的限制。比如，这些可逆操作都不能跨过程，而且关系模型并不包含递归函数。所以你并不能真正利用这种“无方向的代码”来完成比“有方向代码”更加强大的功能，大部分时候它们本质上只是普通程序语言里面最普通的一些表达式，只不过换了一种更“炫”的写法而已。</p>

<p>总是有人声称限制语言的表达力可以让语言更加容易优化，然而如果一个语言弱得不能用，优化做得再好又有什么用。关系模型的核心，其实是普通程序语言里面最简单的部分：表达式。如果缺乏控制结构和递归，这些表达式的能力只相当于最简单的计算器。经验告诉我，就算表达力这么弱的语言，很多数据库的编译器也不能把优化做好，所以这不过是为它的弱表达力找个借口。另外由于这种无方向的表达式让你在阅读的时候很难看清楚数据的“流向”，所以你很难理解这里面包含的算法。这种问题也存在于逻辑式语言，但因为逻辑式语言的表达力在某些方面强于过程式语言，所以感觉还不算白费劲。然而，关系模型有着逻辑式语言的各种缺点，却不能提供逻辑式语言最基本的长处，所以比起过程式语言来说其实是一无是处。</p>

<h4>关系模型与数据结构</h4>

<p>我们再来探讨一下关系模型与数据结构的关系。很多人认为关系式数据库比起数据结构是一个进步，然而经过仔细的思考之后我发现，它其实不但是一个退步，而且是故弄玄虚，是狗皮膏药。在 IU 的时候，我做过好几个学期数据库理论课程的助教。当时我的感受就是，很多计算机系学生上了“数据结构”课程之后，再来上“数据库理论”课程，却像是被洗脑了一样，仿佛根本没有理解数据结构。经过一段时间的接触之后，我发现其实他们大部分人只是被数据库领域的诸多所谓“理论”，“模型”或者“哲学”给迷惑了。本来是已经理解的数据结构和算法，却被数据库理论给换成了等价却又吓人的新名词，所以他们忽然搞不明白了。我是很负责的老师，所以我努力地思索，想让他们找回自我，最后我成功了。经过我如下的分析，他们大多数后来都茅塞顿开，对关系式数据库应用自如，最后取得了优异的成绩。</p>

<p>其实，关系模型的每一个“关系”或者“行”（row），表示的不过是一个普通语言里的“结构”（就像 C 的 struct）。一个表（table），其实不过是一个装着结构的数组。举个例子，以下 SQL 语句构造的数据库表：</p>

<pre><code>CREATE TABLE Students ( sid CHAR(20),
                        name CHAR(20),
                        login CHAR(20),
                        age INTEGER,
                        gpa REAL )
</code></pre>

<p>其实相当于以下 C 代码构造的结构的数组：</p>

<pre><code>struct student {
  char* sid;
  char* name;
  char* login;
  int age;
  double gpa;
}
</code></pre>

<p>每一个 join，本质上就是沿着行里的“指针”（foreign key）进行“寻址”，找到它所指向的东西。在实现上，join 跟指针引用有一定区别，因为 join 需要查软件哈希表，所以比指针引用要慢。指针引用本质上是在查硬件哈希表，所以快很多。当然，这些操作都是基于“集合”的，但其实普通语言也可以表示集合操作。</p>

<p>所谓的查询（query），其实就是普通的函数式语言里面的 filter, map 等抽象操作，只不过具体的数据结构有所不同。关系式代数更加笨拙一些，组合能力弱一些。比如，以下的 SQL 语句</p>

<pre><code>SELECT Book.title
 FROM Book
 WHERE price &gt; 100
</code></pre>

<p>本质其实相当于以下的 Lisp 代码（但不使用链表，执行机制有所不同而已）：</p>

<pre><code>(map book-title
     (filter (lambda (b) (&gt; (book-price b) 100)) Book)
</code></pre>

<p>所以关系模型所能表达的东西，其实不会超过普通过程式（函数式）语言所用的数据结构，然而关系模型却有过程式数据结构所不具有的局限性。由于经典的关系“行”只能有固定的宽度，所以导致了你没法在结构里面放进任何“变长”的东西。比如，如果你有一个变长的数组需要放进结构，你就需要把它单独拿出来，旋转 90 度，做成另外一个表，然后在原来的表里用一个“key”指向它们。在这个“中间表”的每一行，这个 key 都要被重复一次，产生大量冗余。这种做法通常被叫做 normalization。这种方法虽然可行，然而我不得不说这是一个“变通”。它的存在是为了绕过关系模型里面的无须有的限制，终究导致了关系式数据库使用的繁琐。说白了，normalization 就是让你手动做一些比 C 语言的“手动内存管理”还要低级的工作，因为连 C 这么低级的语言都允许你在结构里面嵌套数组！然而，很多人宝贵的时间，就是在构造，释放，调试这些“中间表格”的工作中消磨掉了。</p>

<p>这些就是关系模型所有的秘密。如果你深刻的理解了数据结构的用法，那么通过反复推敲，深入理解以上这番“补充知识”，你就能把已知的数据结构常识应用到所谓的“关系模型”上面，从而对关系式数据库应用自如，甚至可以使用 SQL 写出非常复杂和高效的算法。</p>

<p>另外有一些人（比如这篇<a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.113.5640">文章</a>）通过关系模型与其它数据模型（比如网状模型之类）的对比，以支持关系模型存在的必要性，然而如果你理解了这小节的所有细节就会发现，使用基本的数据结构，其实可以完全的表示关系模型以及被它所“超越”的那些数据模型。说实话，我觉得这些所谓“数据模型”全都是故弄玄虚，无中生有。数据模型可以完全被普通的数据结构所表示，然而它们却不可能表达数据结构带有的所有信息。这些模型之所以流行，是因为它们让人误以为知道了所谓的“一对一”，“一对多”等肤浅的概念就可以取代设计数据结构所需要的技能。所以我认为它们其实也属于技术上的“减肥药”。</p>

<h3>NoSQL 的“革命”</h3>

<p>SQL 和关系模型所引起的这一系列无须有的问题，终究引发了所谓 NoSQL 的诞生。很多人认为 NoSQL 是划时代的革命，然而在我看来它很难被称为是一次“革命”，最多可以被称为“不再愚蠢”。而且大多数 NoSQL 数据库的设计者们并没有看到以上所述的问题，所以他们的设计并没有完全摆脱关系模型以及 SQL 带来的思维枷锁。</p>

<p>最早试图冲破关系模型和 SQL 限制的一种数据库叫做“列模式数据库”（column-based database），其代表包括 Vertica, HBase 等产品。这种数据库其实就是针对了我刚刚提到的，关系模型无法保存可变长度数组的问题。它们所谓的“列压缩”，其实不过是在“行结构”里面增加了对“数组”的表示和实现。很显然，每一个数组需要一个字段来表示它的长度，剩下的空间用来依次保存每一个元素。所以在这种数据库里，你大部分时候不再需要进行 normalization，也不需要重复存储很多 key。这种对数组的表示，是一开始就应该有的，却被关系模型排除在外。然而，很多列模式数据库并没有看到这一实质。它们经常设定一些无端的限制，比如你的变长数组只能有非常有限的嵌套层数之类，所以它们其实没能完全逃脱关系式数据库带来的思想枷锁。让我很惊讶的是，如此明显的事情，数据库专家们最开头恁是看不到。到后来改来改去改得六成对，还美其名曰“优化”和“压缩”。</p>

<p>最新的一些 NoSQL 数据库，比如 Neo4j, MongoDB 等，部分的针对了 SQL 的表达力问题。Neo4j 设计了个古怪又不中用的查询语言叫 Cypher，MongoDB 使用冗长繁琐的 JSON 来直接表示对数据的查询，就像是在手写编译器里的 AST 数据结构。Neo4j 的 Cypher 语言不但语法古怪，表达力弱，而且效率非常低，以至于几乎任何有用的操作你都必须使用 Java 写扩展来完成（参考这篇<a href="http://www.yinwang.org/blog-cn/2013/11/08/voxer-sg">博文</a>）。所以到现在看来，数据库的主要问题已经转移到了语言设计的问题，而且它们会在很长一段时间之内处于混沌之中。</p>

<p>其实数据库的问题哪有那么困难。只要你有一个好的程序语言，你就可以发送这种语言的代码到“数据库服务器”，这个服务器可以远程执行你的代码，调用服务器上的“库代码”对数据进行索引，查询和重构，然后返回代码指定的结果。如果你看清了 SQL 的实质，就会发现这样的“过程式设计”其实并不会损失 SQL 的“描述性语言”的表达能力。反而由于过程式语言使用的简单性，直接性和普遍性，会使得开发效率大大提高。NoSQL 数据库比起 SQL 和关系式数据库存在一些优势，也就是因为它们在朦胧中朝着这个方向发展。</p>

<p>然而，NoSQL 并不总是朝着正确的方向发展。因为设计它们的人往往没有专业的修习过程序语言的设计，缺乏对历史教训的认识，所以他们经常犯下不应有的设计错误。我经历过好些 NoSQL 数据库之后发现，它们的查询语言设计几乎完全没有章法。而且由于具体的实现质量以及商业动机，这些数据库往往有各种各样恼人的问题。这是必然的现象，因为这些数据库公司靠的就是咨询和服务作为收入，如果他们把这些数据库高质量又开源的实现，没有烦人的问题，谁会给他们付费呢？</p>

<p>所以，这些 NoSQL 数据库问题的存在，也许并不是因为人们都很笨，而是因为世界的经济体制仍然是资本主义，大家都需要骗钱糊口，大家都舍不得给“小费”。有人说我这是“阴谋论”，可惜总有一天你会意识到，这的确是一个阴谋。如果你想知道跟 NoSQL 数据库公司打交道是什么感觉，可以参考一下我这篇<a href="http://www.yinwang.org/blog-cn/2013/11/08/voxer-sg">博文</a>里面关于 Neo4j 的部分。</p>

<h3>总结</h3>

<p>说了这么多，其实主要的只有几点：</p>

<ol>
<li>关系模型是一个无需有的东西。它严重束缚了人们的思想，其本质并不如普通的数据结构简单和高效。它比起逻辑式语言的理论来说是非常肤浅的。</li>
<li>SQL，Datalog，Prolog 等所谓“描述性语言”的价值被大大的高估了。使用它们的人往往有“避免编程”的心理，结果不得不做比编程还要痛苦的工作：数据库查询优化。</li>
<li>数据库完全可以使用普通的程序语言（Java，Scheme 等）的“远程执行”来进行查询，而不需要专门的查询语言。这在某种程度上就是 NoSQL 数据库的实质和终极发展方向。</li>
</ol>


<p>对数据库的问题有更多兴趣的人，可以参考我的一篇相关的<a href="http://yinwang0.wordpress.com/2013/04/05/database">英文博客</a>，以及这篇《<a href="http://www.yinwang.org/blog-cn/2013/04/14/os-design">一种新的操作系统的设计</a>》里面的相关部分。</p>

<h3>习题</h3>

<p>有人评论说我其实不懂 SQL，现在我就来考考你的 SQL 编程能力，看看到底是谁理解 SQL 多一些 :)</p>

<p>题目：请用 SQL 实现 Dijkstra 的最短路径算法。</p>

<p>为了加深对数据库的认识，每个人都应该用 SQL 来实现这样稍微复杂的算法，而不只是写一些高中生都会的基础程序。如果你仍然相信“What，not How”的广告，反对使用 SQL 来写这样的过程式算法，那么就请你更进一步，使用你所谓的“What 查询方式”来高效的解决最短路径问题。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>程序语言的常见设计错误(2) - 试图容纳世界</h2>

    <p>之前的一篇文章里，我谈到了程序语言设计的一个常见错误倾向：<a href="http://www.yinwang.org/blog-cn/2013/03/15/language-design-mistake1">片面追求短小</a>，它导致了一系列的历史性的设计错误。今天我来谈一下另外一种错误的倾向，这种倾向也导致了很多错误，并且继续在导致错误的产生。</p>

<p>今天我要说的错误倾向叫做“试图容纳世界”。这个错误导致了 Python，Ruby 和 JavaScript 等“动态语言”里面的一系列问题。我给 Python 写过一个静态分析器，所以我基本上实现了整个 Python 的语义，可以说是对 Python 了解的相当清楚了。在设计这个静态分析的时候，我发现 Python 的设计让静态分析异常的困难，Python 的程序出了问题很难找到错误的所在，Python 程序的执行速度比大部分程序语言都要慢，这其实是源自 Python 本身的设计问题。这些设计问题，其实大部分出自同一个设计倾向，也就是“试图容纳世界”。</p>

<p>在 Python 里面，每个“对象”都有一个“字典”（dictionary）。这个 dict 里面含有这个对象的 field 到它们的值之间的映射关系，其实就是一个哈希表。一般的语言都要求你事先定义这些名字，并且指定它们的类型。而 Python 不是这样，在 Python 里面你可以定义一个人，这个人的 field 包括“名字”，“头”，“手”，“脚”，……</p>

<p>但是 Python 觉得，程序应该可以随时创建或者删除这些 field。所以，你可以给一个特定的人增加一个 field，比如叫做“第三只手”。你也可以删除它的某个 field，比如“头”。Python 认为这更加符合这个世界的工作原理，有些人就是可以没有头，有些人又多长了一只手。</p>

<p>好吧，这真是太方便了。然后你就遇到这样的问题，你要给这世界上的每个人戴一顶帽子。当你写这段代码的时候，你意识中每个人都有头，所以你写了一个函数叫做 <code>putOnHat</code>，它的输入参数是任意一个人，然后它会给他（她）的头上戴上帽子。然后你想把这个函数 <code>map</code> 到一个国家的所有人的集合。</p>

<p>然而你没有想到的是，由于 Python 提供的这种“描述世界的能力”，其它写代码的人制造出各种你想都没想到的怪人。比如，无头人，或者有三只手，六只眼的人，…… 然后你就发现，无论你的 <code>putOnHat</code> 怎么写，总是会出意外。你惊讶的发现居然有人没有头！最悲惨的事情是，当你费了几个月时间和相当多的能源，给好几亿人戴上了帽子之后，才忽然遇到一个无头人，所以程序当掉了。然而即使你知道程序有 bug，你却很难找出这些无头人是从哪里来的，因为他们来到这个国家的道路相当曲折，绕了好多道弯。为了重现这个 bug，你得等好几个月，它还不一定会出现…… 这就是所谓 <a href="http://www.yinwang.org/blog-cn/2013/04/14/terminology">Higgs-Bugson</a> 吧。</p>

<p>怎么办呢？所以你想出了一个办法，把“正常人”单独放在一个列表里，其它的怪人另外处理。于是你就希望有一个办法，让别人无法把那些怪人放进这个列表里。你想要的其实就是 Java 里的“类型”，像这样：</p>

<pre><code>List&lt;有一个头和两只手的正常人&gt; normalPeople;
</code></pre>

<p>很可惜，Python 不提供给你这种机制，因为这种机制按照 Python 的“哲学”，不足以容纳这个世界的博大精深的万千变化。让程序员手工给参数和变量写上类型，被认为是“过多的劳动”。</p>

<p>这个问题也存在于 JavaScript 和 Ruby。</p>

<p>语言的设计者们都应该明白，程序语言不是用来“构造世界”的，而只是对它进行简单的模拟。试图容纳世界的倾向，没带来很多好处，没有节省程序员很多精力，却使得代码完全没有规则可言。这就像生活在一个没有规则，没有制度，没有法律的世界，经常发生无法预料的事情，到处跑着没有头，三只手，六只眼的怪人。这是无穷无尽的烦恼和时间精力的浪费。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>程序语言不是工具</h2>

    <p>在谈论到程序语言的好坏的时候，总是有人说：“程序语言只是一种工具。只要你的算法好，不管用什么语言都能写出一样好的程序。”在本科第一堂编程课上，我的教授就这么对我们说。可是现在我却发现，这是一个根本错误的说法。</p>

<p>我不知道这种说法确切的来源，然而昨天在浏览网页的时候，偶然发现了 C++ 的设计者 Bjarne Stroustrup 的一些类似的说法。这些说法来自于 2007 年 MIT Technology Review 对 Stroustrup 的<a href="http://www.technologyreview.com/qa/407076/bjarne-stroustrup">采访</a>。</p>

<ul>
<li><p>问：一个好的语言是什么样的？<br>
Stroustrup：所有能帮助人们表达他们的想法的东西都会让语言更好。一个语言在一个好的工匠手里应该能胜任每天的任务。语言是否优美是次要的问题。被认为是丑陋的语言开发出来的有用的系统，比优美的语言开发出来的系统要多得多。</p></li>
<li><p>问：优雅难道不重要吗？<br>
Stroustrup：优雅很重要，可是你如何衡量“优雅”？可以表达问题答案的最少字数？我觉得我们应该看构造出来的应用程序的优雅程度，而不是语言自身的优雅程度。就像你不能把木工的一套复杂的工具（很多是危险的工具）叫做“优雅”一样。但是我的餐桌和椅子却真的很优雅，很美。当然，如果一个语言本身也很美，那当然最好。</p></li>
</ul>


<h3>一些基本的错误</h3>

<p>对这两个回答，我都不满意，我觉得这只是他对于 C++ 的恶劣设计的借口而已。下面我对其中几个说法进行质疑：</p>

<blockquote><p>所有能帮助人们表达他们的想法的东西都会让语言更好。</p></blockquote>

<p>作为一个程序语言，并不是好心想“帮助人”就可以说是好的。如果是这样的话，那么我就可以把所有国家的脏话都加到你的语言里面，因为它们可以帮助我们骂人。</p>

<blockquote><p>被认为是丑陋的语言开发出来的有用的系统，比优美的语言开发出来的系统要多得多。</p></blockquote>

<p>系统的数量再多也不能说明这个语言好。正好相反，众多的系统由于语言的一些设计失误，把人们的生命置于危险之中，这说明了这个语言的危害性之大。一种像炸药一样的语言，用的人越多越是危险。</p>

<h3>语言不是工具，而是材料</h3>

<p>我这篇文章想说的最关键的部分，其实是他所支持的“语言工具论”的错误。</p>

<p>Stroustrup 说：</p>

<blockquote><p>我觉得我们应该看构造出来的应用程序的优雅程度，而不是语言自身的优雅程度。就像你不能把木工的一套复杂的工具（很多是危险的工具）叫做“优雅”一样。但是我的餐桌和椅子却很优雅，很美。</p></blockquote>

<p>他的言下之意就是把程序语言比作木工的工具，而餐桌也椅子就是这些工具做出来的产品。比方的威力是很大的，很多人一见到大牛给出这么形象的比方，想都不用想就接受了。如果你不仔细分析的话，这貌似一个恰当的比方，然而经过仔细推敲，这却是错误的比方。这是因为程序语言其实不是一种“工具”，而是一种“材料”。</p>

<p>木工不会把自己的锯子，墨线等东西放进餐桌和椅子里面，而程序员却需要把语言的代码放到应用程序里面。虽然这些程序经过了编译器的转化，但是程序本身却仍然带有语言的特征。这就像一种木材经过墨线和锯子的加工，仍然是同样的木材。一个 C++ 的程序在编译之后有可能产生内存泄漏和下标越界等低级错误，而更加安全的语言却不会出现这个问题。</p>

<p>所以在这个比方里面，程序语言所对应的应该是木工所用的木料，钉子和粘胶等“材料”，而不是锯子和墨线等“工具”。这些材料其实随着应用程序一起，到了用户的手里。那么对应木工工具的是什么呢？是 Emacs, vi, Eclipse，Visual Studio 等编程环境，以及各种编译器，调试器，make，界面设计工具，等等。这些真正的“工具”丑一点，真的暂时无所谓。</p>

<p>现在你还觉得程序语言的优雅程度是次要的问题吗？一个复杂而不安全的语言就像劣质的木料和粘胶。它不但会让餐桌和椅子的美观程度大打折扣，而且会造成它们结构的不牢靠，以至于威胁到用户的生命安全。同时它还可能会造成木工的工作效率低下以及工伤的产生。</p>

<p>这也许就是为什么我的一个同事说，他看 C++ 代码的时候都会带上 OSHA（美国职业安全与健康管理局）批准的护目镜。</p>

<p><img src="http://www.yinwang.org/images/osha-goggle.jpg"></p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>程序语言与……</h2>

    <p>程序语言的设计类似于其它很多东西的设计。有些微妙的地方只有用过更好的设计的人才能明白。现在我就简要介绍一下我自己的体会。</p>

<h3>程序语言与微波炉</h3>

<p><img src="http://www.yinwang.org/resources/microwave.png" width="60%"></p>

<p>有的程序语言就像左边的，现在中国市场上流行的微波炉。布满了花哨的一年都用不到一次的专用菜单，却连最基本的 0-9 数字键都没有。输入个时间都要费脑筋组合一下，按键位置不顺手，不能一次按到位，而且还不能达到需要的精度。</p>

<p>有的程序语言就像右边的，美国市场上常见的微波炉，几十年不变的设计。虽然按键很少，但十个数字键总是少不了，而且采用标准的“电话键盘”排列。十个数字能够组合产生出任意的时间，所以不管是在自己家里，别人家里，公司或者学校，你总是可以按照自己的经验，食物包装或者菜谱上的说明，迅速而精确的输入想要的时间。</p>

<p>可惜的是，在中国你已经买不到这么简单实惠的微波炉了。我们中国人学会了美国的很多糟粕，却没有把这么简单，这么好的设计思想学过去。</p>

<p>中国的微波炉厂商之所以放上这么多的花样，是因为商家抓住了中国人的贪便宜心理。看，一个微波炉可以煮米饭，烤肉串，还可以蒸排骨，那其他的厨具都可以不用买啦！可惜因为所以，科学道理，微波就是微波。加热牛奶剩饭之类的事它做得很好，可是要做美味佳肴它就不行了。煮米饭不如电饭煲，烤肉串不如烧烤架，蒸排骨不如蒸锅，炖东西不如砂锅…… 美国人和稍微有点经验的中国人早就知道这个道理，所以从来不期望微波炉能做超越它所擅长的事情。</p>

<p>虽然美国人在这些硬件上非常精明，可是在软件上还没发展到那种地步，很多时候对一些不可救药的软件技术寄予太多的希望。左边的微波炉就好像某些程序语言，本来当初设计就是给标准没那么高的人用来处理很简单的网页的。可是后来有人忽然想让它成为一个“万能语言”，用来做复杂的，对性能和可靠性都很高的服务器程序甚至机器人控制程序。然后你就发现类似微波炉的问题，因为一些不可逾越的设计差别决定了它是不可能把那些事情做好的，而且对有些应用还有严重的安全隐患。当然你可以缓慢的“改进”这语言，让它慢慢的提高做这些事的水平。可是这种改进的终点也许只是另一种早已存在的语言。而且由于不想破坏已有的代码和特性，所以每一步的改进都异常艰难。这种方式远远不如直接针对需要选择不同的语言，或者设计新的语言来的迅速和有效。</p>

<h3>程序语言与减肥</h3>

<p><img src="http://www.yinwang.org/images/jianfei.png" width="60%"></p>

<p>很多人都想减肥，就像很多人都想学会编程。姑且不说一味的减肥好不好，现在只谈一下什么是有效的减肥方法。</p>

<p>我自己也有一段时间很胖，也有减肥的经历，而且非常成功。如果有一天我不小心又变胖了，我有非常科学而可靠的办法减回去。我的方法就是一句话：让每天吃进去的热量比消耗的少一些，但是不至于难受，另外适当运动来增加热量的消耗。很显然嘛，根据热力学定律，每天消耗的能量比摄入的多，多出来的部分只能通过分解你身上的物质（脂肪）来产生。我的减肥方法就像某些程序语言教会我的编程理念，是不随潮流而改变的真理。它让我的程序不管用什么语言写都优美而精悍。</p>

<p>我不是自私的人，我希望大家都健康一点，养眼一点。我已经轻易地告诉了你减肥的终极真理，一分钱都不收，可是你不相信我。你觉得肯定没那么简单，或者你觉得那样太辛苦，自己不可能照办。这就像很多人对编程的希望：要是我不学编程也能编程该多好啊！</p>

<p>很多程序语言就是针对这群人而产生的，它们大部分的工作花在了研究人的心理和做广告上面。它们就像电视广告里铺天盖地的减肥药：不需运动，不用节食，一个星期瘦 20 斤！它们提出各种新的术语，什么减肥茶，片，胶囊，螺旋，燃脂，纤维，宫廷，祖传，秘方，各种生化术语…… 再加上一些 PS 出来的前后效果对比图，你痛快地花不菲的价钱买了这药，然后每天好几次的像做化学实验一样精确的按时按量服用。这时候任何人跟你说这药不灵的话你都不会相信，你觉得这些人都是想跟你争夺异性的目光故意想让你继续胖下去而其实她（他）们自己背地里也吃这药，所以你对此减肥药必胜的信心有增无减。</p>

<p>当然你不会成功。在持续服用好多个月，甚至好几年之后，你按照广告里说的“无效退款”条例要求退款。可是减肥药公司说，是你自己没有按说明书服用，或者你吃药之前肯定比现在还胖很多。你拿不出证据，后悔当初没到公证处开你当时体重的证明。可是你仍然相信，世界上一定会有真正有效的减肥药。你觉得国内的公司喜欢骗人，所以你到了美国，寻找传说中那世界一流的减肥药……</p>

<h3>程序语言与棋</h3>

<p><img src="http://www.yinwang.org/images/chess.png" width="80%"></p>

<p>有人说好的程序语言就像国际象棋（chess），在了解简单的规则之后，你就可以用它们组合出变幻无穷的棋局。而我认为，好的程序语言应该像国际象棋去掉像“王车易位”（castling）一类<a href="http://en.wikipedia.org/wiki/Chess#Castling">复杂古怪的规则</a>。实际上，好的程序语言会更加近似于中国象棋，而不是国际象棋。中国象棋只有一条规则比较特殊—“蹩脚马”，可是它其实很直观，容易理解。其它的规则，比如兵卒过河才能横行，几乎都画在棋盘上了。</p>

<p>可不要小看国际象棋里这少数几个特殊规则，它们需要在好几个非常特殊的条件满足之后才会生效，而且路线诡异。比如，王车易位必须满足：</p>

<ol>
<li>王和跟他换位的车都没有移动过</li>
<li>王和车之间没有其它棋子</li>
<li>王不能处于被“将军”的状态而且王在换位之后不能处于被攻击的位置但是车可以在换位后处于被攻击位置</li>
<li>王和车处于同一条水平线上</li>
</ol>


<p>另外换位的时候王和车不是直接互换位置那么简单，而是这样的路线：</p>

<p><img src="http://www.yinwang.org/images/ChessCastlingMovie.gif"></p>

<p>一条这样的特殊规则就够伤脑筋了，据我所知国际象棋还有至少其它两条类似的规则。它们跟其他的规则组合在一起的时候就产生了组合爆炸效应，你发现每走一步，甚至貌似无关的动作都得检查它们是否会出现。你不得不随时把这么复杂的规则放在脑子里。没事找事也不要找这么麻烦的事啊。</p>

<p>这些规则就像是要你记住 C 语言里的 ++i+i++ 或者 if (x = "foo") {...} 是什么意思。经过多年的痛苦经历之后，你多希望不再需要理解这样的代码。可是一旦这样的规则被加到语言里面，总会有人为了显示自己的水平和记忆力去用它们。不得已，你只好陪他们玩。</p>

<p>如果你觉得多了这些无厘头的规则会让国际象棋比中国象棋难度大或者更加有趣，那你就低估了中国象棋了。中国象棋的“游戏树复杂度”其实比国际象棋还要高，高达 10<sup>150</sup>，而国际象棋只有 10<sup>123</sup>。这跟中国象棋的棋盘要稍微大点有关系，但是总比记忆那些麻烦的规则好多了。所以相对来说中国象棋既简单又耐玩。</p>

<p>如果国际象棋还凑合算是简单的话，大部分的程序语言就像是魔鬼棋，飞行棋，或者三国杀。它们几乎完全由类似的特殊规则构成。哇，那么多的人物，道具和特殊技，好玩！可是会玩象棋或者国际象棋的人都会觉得它们无聊透顶。</p>

<p>那么是不是规则越简单越少的棋越好呢？围棋就比中国象棋还简单，那么围棋是不是更好玩呢？我觉得不是的。围棋对我来说太慢，太单调，棋盘太大，耗时太多，而且胜负居然不能一眼就看出来，要数好一会儿！这哪里是在玩，纯粹就是在做组合优化题嘛。我觉得这种任务适合交给电脑去做。所以其实简单也有一个界限，超过了这个界限对于人就没有很大区别了，反而会开始感觉缺少一些东西。</p>

<p>我觉得中国象棋和围棋一样简单，它的规则虽然比围棋多，但是仍然处于人脑容易记忆的范围，而且每条规则都很直接了当，没有很隐晦的条件。中国象棋的长距离武器（车和炮）让它比围棋多了很多乐趣，而对于象，马和王的走法的限制，让它比起国际象棋多了几分安心和舒适。国际象棋的后，两个车，两个相的攻击距离和范围太大，让人觉得眼睛很辛苦，因为每一个位置都可能被从太多个方向远距离攻击。而那个王，由于可以到处乱跑，以至于你感觉不是在抓一个住在戒备森严的城堡里的人，而是一只在野外乱跑的老鼠。</p>

<p>什么游戏会让人觉得有趣，真是一个值得研究的问题。我觉得象棋和我以前推荐过的一个游戏 <a href="http://www.yinwang.org/blog-cn/2013/03/04/braid/">Braid</a> 里面含有同一种吸引人的设计：屈指可数但又有足够变化的简单规则，组合起来制造出许许多多的变化。这种特征其实也是鉴别一个优秀的程序语言的标准。</p>

<h3>程序语言与音乐</h3>

<p><img src="http://www.yinwang.org/images/goldberg.png" width="200"></p>

<p>程序语言就像音乐。当听过很好的音乐之后，你会自然而然的厌倦以前曾经喜欢过，为之疯狂过的那些，觉得它们很无趣，甚至很惊讶自己以前怎么会喜欢它们。当有人问你为什么不喜欢他们推荐给你的音乐，你却说不出来。你只是自然而然觉得太单调，不入耳，不对劲，甚至扰乱你美好的心情。你的判断完全是依靠声波对鼓膜的震动而引起的脑电波的起伏，而不带有任何的成见。完全根据这音乐自己，而不需要知道它的作者是谁。就像玩过像《Braid》之类的游戏之后，你再也不想玩像《生化危机》那种搞不清楚到底是自己在玩游戏还是游戏在玩自己的。你的脑子里有一种对“趣味”的新定义，但是你却说不出来它到底是怎么回事。</p>

<p>程序语言是同样的感觉，这是一个“流行语言”招摇过市的年代。每当有人问我喜欢什么程序语言我都不好跟他说，因为一旦说出来就有显摆之嫌，而其实真正显摆的是其他人。很多人期望你的回答是他所膜拜的那个最近很热门的语言，你一旦告诉他你喜欢的语言就会被冷嘲热讽，因为你的语言不热门。他们会说你是“学院派”，而他们是“工程派”，而其实这只是给垃圾的存在找借口。他们利用你害怕自己被认为是附庸风雅或者居高临下的心理来变相地压制你，让你不敢直率的袒露自己的兴趣。你不敢显示对有些东西的不屑，而他们却可以任意的显示对真正优秀的技术的不屑。你觉得应该手下留情一些，谦虚一些，结果最后一些垃圾一样的语言就骑到你头上来，让你不得不用它们。</p>

<p>用过很好的语言，然后自己设计过程序语言之后，我再也不对很多新的语言，或者有些人很崇拜的古老的语言感兴趣了。我完全是凭自己的感觉来判断，一些所谓的“新特性”其实是老酒换新瓶，或者是勾兑的假酒。程序语言本来就只有那么点东西，为什么有人仍然像对那些扮相的流行歌手一样热衷和疯狂。</p>

<p>我知道这些话说了也白说，因为他们没有用过我用过的语言，他们只看到名字却感觉不到本质，他们靠别人的评价来判断，而不是靠自己的心。所以像音乐一样，只有等有一天他们忽然觉悟，就像很多年前的我一样。</p>

<h3>程序语言与武器</h3>

<p><a href="http://weaponsman.com/?p=12534"><img src="http://www.yinwang.org/images/AK-47.png" width="400"></a></p>

<p>前段时间 AK-47 的设计者 <a href="http://en.wikipedia.org/wiki/Mikhail_Kalashnikov">Kalashnikov</a> 去世的时候，我从一篇文章了解到他设计 <a href="http://weaponsman.com/?p=12534">AK-47 的故事</a>，发现 AK 跟我喜欢的程序语言设计有异曲同工之妙。</p>

<blockquote><p>AK 简单得就像一把锤子。它身上没有太空时代的材料。大多数汽车修理店都有可以制造出 AK 的工具。</p></blockquote>

<p>这篇文章首先提到，AK 的高可靠性最主要来自于它的简单，而其实简单也是程序语言最重要的东西。程序员需要解决的问题一般都挺复杂，如果他们的工具再被设计得复杂，那么他们大量的脑力就被浪费在解决这语言的问题，而不是真正需要解决的问题了。</p>

<blockquote><p>Kalashnikov 开始的时候把任何有可能出问题的设计都排除在外了。</p></blockquote>

<p>与简单的设计背道而驰，现在很多程序语言为了赶潮流或者吸引眼球，喜欢标新立异，喜欢加入很多“特性”，可是这些特性很有可能不但不解决问题，而且会制造问题。绝大部分程序员都不理解这个道理，所以有些人听说我在设计自己的语言就问我：“它有什么新特性吗？”我没法回答他们，因为我的设计几乎没有新的特性。我现在所做的一切思考和试验都是在去掉不必要的麻烦。一个语言缺少一些好的特性，以后还可以加进去，可是它如果多了一些问题特性，那一旦有人开始用就没法去掉了。</p>

<blockquote><p>AK 上面没有袖珍和娇气的部件。这样你就不用费事在草丛里，泥地上或者溪流里找它们了。</p></blockquote>

<p>士兵是人，会摔跤犯错误，程序员也是人，所以程序员的武器应该像士兵的武器一样，方便他们找到问题。可是很多程序语言让程序员犯错误之后花很多时间和精力才能找到错误的所在，浪费大量本来可以用来解决问题的时间。我的前同事 TJ 说他刚进入博士学习的时候花了好几个月，就为了找到 C 代码里面一个指针计算错误，导致内存结构破坏和莫名其妙的错误结果，而出现指针计算错误的位置跟错误结果出现的位置毫无关系。我也遇到过类似的问题。C 语言的指针不就像是某些武器上面的袖珍部件吗？一不小心掉在地上就找不到了。</p>

<blockquote><p>AK 只有一个复杂一点的部件，那就是它的弹夹。弹夹的设计很大程度上影响到枪的整体性能，所以 Kalashnikov 在上面花了很多设计时间。</p></blockquote>

<p><img src="http://www.yinwang.org/images/ak-magazine.png" width="300"></p>

<p>这个工程经验其实对于程序语言的设计者有启发意义，因为弹夹与枪主体的接口，和程序语言的函数接口很类似。Tony Hoare 在他的《<a href="https://www.cs.berkeley.edu/~necula/cs263_sp14/handouts/hoarehints.pdf">给程序语言设计的建议</a>》中也提到，函数的调用必须简单而且快速，因为调用的开销会累积起来形成很大的性能问题。可惜的是很多语言没有注意到这个问题，函数调用时总是有一堆的动态检查和重载要做，很大程度的影响了它们的性能。</p>

<blockquote><p>AK 的美，在于它身上没有部件具有不必要的精确性。</p></blockquote>

<p>这对于程序语言或者编程来说也是有启发意义的。有些人为了所谓的程序“正确性”，损害了它的简单性。他们的代码异常复杂，而且喜欢写很多测试，让自己感觉对程序的“质量”有个底。然而这其实是自欺欺人。这些测试不但不能保证程序的正确，它们阻碍了程序员对程序进行彻底性的修改，防止了他们看到更加简单，甚至一眼就知道是正确的解决方案。</p>

<p>程序语言的设计也是。有些语言（特别是所谓 dependent type 的语言）想达到程序的完全正确，加入了很多很多的限制条件，要求程序员写很多的辅助声明甚至机器证明。结果很简单一个问题都需要很长的代码才能写出来，这些辅助的逻辑代码严重的影响了程序的阅读和转换。而且由于数理逻辑本身的局限性，它们经常迫使程序员的思路绕弯子。其实起到了相反的结果，让他们看不到更简单的方法。</p>

<blockquote><p>Kalashnikov 不是天才，他不是为了发明而发明，他解决不了问题的时候就高兴地从别人那里学过来。</p></blockquote>

<p>这是非常值得我们程序语言设计者学习的。很多程序语言专家都有盲目排斥“对手”的心理，“自己人”的东西就不假思索的表扬，对手的东西就一味的批评。最后的结果是没有把敌人的好东西学过来，让自己人吃亏。在操作系统和数据库等领域也有类似的思维方式，这是非常有害的。</p>

<blockquote><p>直到被更好的东西取代，AK 会继续和我们在一起。什么才是“更好”，这是由历史和民族来定义的，而不是枪支设计专家。</p></blockquote>

<p>在计算机的世界里也是一样，程序语言，操作系统，数据库…… 它们的好坏不应该是由它们的设计者决定的，而是看它们是否经得起时间的考验。很多几十年前以为是好的设计，到现在已经很明显的显示出了它们的缺点。这就是为什么我喜欢批评一些语言，操作系统和数据库的设计，因为我看到了它们在历史的长河中已经快要到达终点。自欺欺人的掩盖这些缺陷只会让我们输掉战争。</p>


  </body>
<h1>=======================================================<h1>
<body>

    <h2>GTF - Great Teacher Friedman</h2>

    <h3>写小人书的老顽童</h3>

<p>Dan Friedman 是 Indiana 大学的教授，程序语言领域的创始人之一。他主要的著作《The Little Schemer》（前身叫《The Little Lisper》) 是程序语言界最具影响力的书籍之一。现在很多程序语言界的元老级人物，当年都是看这本“小人书”学会了 Lisp/Scheme，才决心进入这一领域。</p>

<p><img src="http://www.yinwang.org/images/the-little-schemer.jpeg" alt="The Little Schemer">
<img src="http://www.yinwang.org/images/the-little-lisper.jpeg" alt="The Little Lisper"></p>

<p>Friedman 对程序语言的理解可以说是世界的最高标准，很可惜的是，由于他个人的低调，他受到很多人的误解。很多人以为他只懂得 Scheme 这种“类型系统落后的语言”。有些人觉得他只顾自己玩，不求“上进”，觉得他的研究闭门造车，不“前沿”。我也误解过他，甚至在见面之前，根据这些书的封面，我断定他肯定是个年轻小伙。结果呢，第一次见到他的时候，他已经过了60岁大寿。</p>

<p>程序语言的研究者们往往追逐一些“新概念”，却未能想到很多这些新概念早在几十年前就被 Friedman 想到了。举个例子，Haskell 所用的 lazy evaluation 模型，最早就是他在 1976 年在与 David Wise 合写的论文“CONS should not Evaluate its Arguments”中提出来的。</p>

<p>虽然写了 The Little Schemer， 但 Friedman 的学识并不限于 Scheme。他不断地实验各种其它的语言设计，包括像 ML 一类的含有静态类型系统的函数式语言，逻辑式语言，面向对象语言，用于定理证明的语言等等。在每次的试验之后，他几乎都会写一本书，揭示这些语言最精要的部分。</p>

<p>觉得 ML 比 Scheme 先进很多的人们应该看看 Friedman 这本书：The Little MLer：</p>

<p><img src="http://www.yinwang.org/images/the-little-mler.jpeg" alt="The Little MLer"></p>

<p>想要真正理解 Java 设计模式的人可以看看这本：A Little Java, A Few Patterns:</p>

<p><img src="http://www.yinwang.org/images/the-little-java.jpeg" alt="java"></p>

<p>这些东西的优点和弱点仿佛在他心里都有数，他几乎总是指向正确的前进方向。</p>

<h3>你知道些什么？</h3>

<p>可惜的是，由于个人原因，Friedman 始终没有成为我正式的导师（他 “超然物外”，几乎完全不关心自己的学生什么时候能毕业），但他确实是这一生中教会我最多东西的人。所以我想写一些关于他的小故事。也许你能从中看出一个世界级的教育者是什么样子的。我来 IU 之前一位师兄告诉我，Dan Friedman 就像指环王里的甘道夫 (Gandalf)，来了之后发现确实很像。</p>

<p>第一次在办公室见到 Friedman 的时候，他对我说：“来，给我讲讲你知道些什么？”我自豪地说：“我在 Cornell 上过研究生的程序语言课，会用 ML 和 Haskell，看过 Paul Graham 的 On Lisp，Peter Norvig 的 Paradigms of Artificial Intelligence Programming, Richard Gabriel 的一些文章……” 他看着我平静地笑了：“不错，你已经有一定基础……”</p>

<p>这么几年以后，我才发现他善良的微笑里面其实隐藏着难以启齿的秘密：当时的我是多么的幼稚。在他的这种循循善诱之下，我才逐渐的明白了，知识的深度是无止境的。他的水平其实远在以上这些人之上，可是出于谦虚，他不能自己把这话说出来。</p>

<h3>反向运行</h3>

<p>Dan Friedman 已经远远超过了退休年龄，却仍然坚持教学。他的本科生程序语言课程 C311 是 IU 的“星级课程”。我最敬佩的，其实是他那孩子般的好奇心和探索精神。几乎每一年的 C311，他都会发明不同的东西来充实课程内容。有时候是一种新的逻辑编程语言 (叫 miniKanren)，有时候是些小技巧 （比如把 Scheme 编译成 C 却不会堆栈溢出），等等。</p>

<p>Friedman 研究一个东西的时候总是全身心的投入，执着的热爱。自从开始设计一个叫 miniKanren 的逻辑编程语言，Friedman 多了一句口头禅：“Does it run backwards?”（能反向运行吗？）因为逻辑式的语言（像Prolog）的程序都是能“反向运行”的。普通程序语言写的程序，如果你给它一个输入，它会给你一个输出。但是逻辑式语言很特别，如果你给它一个输出，它可以反过来运行，给你所有可能的输入。但是 Friedman 真的走火入魔了。不管别人在讲什么，经常最后都会被他问一句：“Does it run backwards?”让你哭笑不得。</p>

<p>Friedman 有一个本领域的人都知道的“弱点”——他不喜欢静态类型系统 (static type system)。其实 Scheme 专家们大部分都不喜欢静态类型系统。为此，他深受“类型专家”们的误解甚至鄙视，可是他都从容对待之。</p>

<p>有一次在他的进阶课程 B621 上，他给我们出了一道题：用 Scheme 实现 ML 和 Haskell 所用的 Hindley-Milner 类型系统。这种类型系统的工作原理一般是，输入一个程序，它经过对程序进行类型推导（type inference），输出一个类型。如果程序里有类型错误，它就会报错。由于之前在 Cornell 用 ML 实现过这东西，再加上来到 IU 之后对抽象解释 (abstract interpretation) 的进一步理解，我很快做出了这个东西，而且比在 Cornell 的时候做的还要优雅。</p>

<p>他知道我做出来了，很高兴的样子，让我给全班同学（也就8，9个人）讲我的做法。当我自豪的讲完，他问：“Does it run backwards? 如果我给它一个类型，它能自动生成出符合这个类型的程序来吗？”我愣了，欲哭无泪啊，“不能……”他往沙发靠背上一躺，得意的笑了：“我的系统可以！哈哈！我当年写的那个类型系统比你这个还要短呢。我早就知道这些类型系统怎么做，可我就是不喜欢。哈哈哈哈……”</p>

<p>我后来对类型系统的进一步研究显示，Hindley-Milner 类型系统确实有很多不必要的问题，才导致了他不喜欢。他就是这样一个老顽童。他喜欢先把你捧上天，再把你打下来，让你知道天外有天 :-)</p>

<h3>miniCoq</h3>

<p>你永远想象不到 Dan Friedman 的思维的极限在哪里。当你认为他是一个函数式语言专家的时候，他设计了 miniKanren，一种逻辑式编程语言 (logic programming language)，并且写出 《The Reasoned Schemer》这样的书，用于教授逻辑编程。当你认为他不懂类型系统的时候，他开始捣鼓最尖端的 Martin-Löf 类型理论，并且开始设计机器证明系统。而他做这些，完全是出于自己的兴趣。他从来不在乎别人在这个方向已经做到了什么程度，却经常能出乎意料的简化别人的设计。</p>

<p>有一次系里举办教授们的“闪电式演讲”(lightening talk)，每位教授只有5分钟时间上去介绍自己的研究。轮到 Friedman 的时候，他慢条斯理的走上去，说：“我不着急。我只有几句话要说。我不知道我能不能拖够5分钟……”大家都笑了。他接着说：“我现在最喜欢的东西是 Curry-Howard correspondence 和定理证明。我觉得现在的机器证明系统太复杂了，比如 Coq 有 nnnnn 行代码。我想在 x 年之内，简化 Coq，得到一个 miniCoq……”</p>

<p>miniCoq... 听到这个词全场都笑翻了。为什么呢？自己去联想吧。从此，“Dan Friedman 的 miniCoq” 成为了 IU 的程序语言学生茶余饭后的笑话。</p>

<p>但是 Firedman 没有吹牛。他总是说到做到。他已经写出一个简单的定理证明工具叫 JBob（迫于社会舆论压力，不能叫 miniCoq），而且正在写一本书叫 《The Little Prover》，用来教授最重要的定理证明思想。他开始在 C311 上给本科生教授这些内容。我看了那本书的初稿，获益至深，那是很多 Coq 的教材都不涉及的最精华的道理。它不仅教会我如何使用定理证明系统，而且教会了我如何设计一个定理证明系统。我对他说：“你总是有新的东西教给我们。每隔两年，我们就得重新上一次你的课！”</p>

<h3>C311</h3>

<p>当我刚从 Cornell 转学到 IU 的时候，Dan Friedman 叫我去上他的研究生程序语言课 B521。我当时以自己在 Cornell 上过程序语言课程为由，想不去上他的课。Friedman 把我叫到他的办公室，和蔼的对我说：“王垠，我知道你在 Cornell 上过这种课。我也知道 Cornell 是比 IU 好很多的学校。可是每个老师的教学方法都是不一样的，你应该来上我的课。我和我的朋友们在这里做教授，不是因为喜欢这个学校，而是因为我们的家人和朋友都在这里。”后来由于跟 Amr Sabry（我现在的导师）的课程 B522 时间重合，他特别安排我坐在本科生的 C311 的课堂上，却拿研究生课程的学分。后来发现，这两门课的内容基本没有区别，只不过研究生的作业要多一些。</p>

<p>在第一堂课上，他说了一句让我记忆至今的话：“《The Little Schemer》和《Essentials of Programming Languages》是这门课的参考教材，但是我上课从来不讲我的书里的内容。”刚一开始，我就发现这门课跟我在 Cornell 学到的东西很不一样。虽然有些概念，比如 closure，CPS，我在 Cornell 都学过，在他的课堂上，我却看到这些概念完全不同的一面，以至于我觉得其实我之前完全不懂这些概念！这是因为在 Cornell 学到这些东西的时候只是用来应付作业，而在 Friedman 的课上，我利用它们来完成有实际意义的目标，所以才真正的体会到这些概念的内涵和价值。</p>

<p>一个例子就是课程进入到没几个星期的时候，我们开始写解释器来执行简单的 Scheme 程序。然后我们把这个解释器进行 CPS 变换，引入全局变量作为"寄存器" (register)，把 CPS 产生的 continuation 转换成数据结构（也就是堆栈）。最后我们得到的是一个抽象机 (abstract machine)，而这在本质上相当于一个真实机器里的中央处理器（CPU）或者虚拟机（比如 JVM）。所以我们其实从无到有，“发明”了 CPU！从这里，我才真正的理解到寄存器，堆栈等的本质，以及我们为什么需要它们。我才真正的明白了，冯诺依曼体系构架为什么要设计成这个样子。后来他让我们去看一篇他的好朋友 Olivier Danvy 的论文，讲述如何从各种不同的解释器经过 CPS 变换得出不同种类的抽象机模型。这是我第一次感觉到程序语言的理论对于现实世界的巨大威力，也让我理解到，机器并不是计算的本质。机器可以用任何可行的技术实现，比如集成电路，激光，分子，DNA…… 但是无论用什么作为机器的材料，我们所要表达的语义，也就是计算的本质，却是不变的。</p>

<p>而这些还不是我那届 C311 全部的内容。后半学期，我们开始学习 miniKanren，一种他自己设计的用于教学的逻辑式语言 (logic programming language)。这个语言类似 Prolog，但是它把 Prolog 的很多缺点给去掉了，而且变得更加容易理解。教材是免费送给我们的《The Reasoned Schemer》。在书的最后，两页纸的篇幅，就是整个 miniKanren 语言的实现！我学得比较快，后来就开始捣鼓这个实现，把有些部分重新设计了一下，然后加入了一些我想要的功能。这样的教学，给了我设计逻辑式语言的能力，而不只是停留于一个使用者。这是学习 Prolog 不可能做到的事情，因为 Prolog 的复杂性会让初学者无从下手，只能停留在使用者的阶段。</p>

<p>我很幸运当初听了他的话去上了这门课，否则我就不会是今天的我。</p>

<h3>独立思维</h3>

<p>Dan Friedman 是一个不随波逐流，有独立思想的人。他的眼里容不下过于复杂的东西，他喜欢把一个东西简化到容得进几行程序，把相关的问 题理解得非常清楚。他的书是一种独特的“问答式”的结构，很像孔夫子或者苏格拉底的讲学方式。他的教学方式也非常独特。这在本科生课程 C311 里已经有一些表现，但是在研究生的课程 B621 里，才全部的显示出来。</p>

<p>我写过的最满意的一个程序，自动 CPS 变换，就是在 C311 产生的。在 C311 的作业里，Friedman 经常加入一些“智力题”（brain teaser），做出来了可以加分。因为我已经有一定基础，所以我有精力来做那些智力题。开头那些题还不是很难，直到开始学 CPS 的时候，出现了这么一道：“请写出一个叫 CPSer 的程序，它的作用是自动的把 Scheme 程序转换成 CPS 形式。”那次作业的其它题目都是要求“手动”把程序变成 CPS 形式，这道智力题却要求一个“自动”的——用一个程序来转换另一个程序。</p>

<p>我觉得很有意思。如果能写出一个自动的 CPS 转换程序，那我岂不是可以用它完成所有其它的题目了！所以我就开始捣鼓这个东西，最初的想法其实就是“模拟”一个手动转换的过程。然后我发现这真是个怪物，就那么几十行程序，不是这里不对劲，就是那里不对劲。这里按下去一个 bug，那里又冒出来一个，从来没见过这么麻烦的东西。我就跟它死磕了，废寝忘食几乎一星期。经常走进死胡同，就只有重新开始，不知道推翻重来了多少次。到快要交作业的时候，我把它给弄出来了。最后我用它生成了所有其它的答案，产生的 CPS 代码跟手工转换出来的看不出任何区别。当然我这次我又得了满分（因为每次都做智力题，我的分数总是在100以上）。</p>

<p>作业发下来那天下课后，我跟 Friedman 一起走回 Lindley Hall（IU 计算机系的楼）。半路上他问我：“这次的 brain teaser 做了没有。”我说：“做了。这是个好东西啊，帮我把其它作业都做出来了。”他有点吃惊，又有点将信将疑的样子：“你确信你做对了？”我说：“不确信它是完全正确，但是转换后的作业程序全都跟手工做的一样。”走回办公室之后，他给了我一篇30多页的论文 “Representing control: a study of the CPS transformation”，作者是他的好朋友 Olivier Danvy 和 Andrzej Filinski。然后我才了解到，这是这个方向最厉害的两个人。正是这篇论文，解决了这个悬而不决十多年的难题。其实自动的 CPS 转换，可以被用于实现高效的函数式语言编译器。Princeton 大学的著名教授 Andrew Appel 写了一本书叫《Compiling with Continuations》，就是专门讲这个问题的。Amr Sabry（我现在的导师）当年的博士论文就是一个比 CPS 还要简单的变换（叫做 ANF）。凭这个东西，他几乎灭掉了这整个 CPS 领域，并且拿到了终身教授职位。在他的论文发表10年之内也没有 CPS 的论文出现。</p>

<p>Friedman 啊，把这样一个问题作为“智力题”，真有你的！我开玩笑地对他说：“我保证，我不会把这个程序开源，不然以后你的 C311 学生们就可以拿来作弊了。”回到家，我开始看那篇 Danvy 和 Filinski 的论文。这篇 1991 年的论文的想法，是从 1975 年一篇 Gordon Plotkin 的论文的基础上经过一系列繁琐的推导得出来的，而它最后的结果几乎跟我的程序一模一样，只不过我的程序可以处理更加复杂的 Scheme，而不只是 lambda calculus。我之前完全不知道 Plotkin 的做法，从而完全没有收到他的思想的影响，直接就得到了最好的结果。这是我第一次认识到自己头脑的威力。</p>

<p>第二个学期，当我去上 Friedman 的进阶课程 B621 的时候，他给我们出了同样的题目。两个星期下来，没有其它人真正的做对了。最后他对全班同学说：“现在请王垠给大家讲一下他的做法。你们要听仔细了哦。这个程序价值100美元！”</p>

<p>下面就是我的程序对于 lambda calculus 的缩减版本。我怎么也没想到，这短短 30 行代码耗费了很多人 10 年的时间才琢磨出来。</p>

<pre><code>(define cps
  (lambda (exp)
    (letrec
        ([trivs '(zero? add1 sub1)]
         [id (lambda (v) v)]
         [C~ (lambda (v) `(k ,v))]
         [fv (let ((n -1))
               (lambda ()
                 (set! n (+ 1 n))
                 (string-&gt;symbol (string-append "v" (number-&gt;string n)))))]
         [cps1
          (lambda (exp C)
            (pmatch exp
              [,x (guard (not (pair? x))) (C x)]
              [(lambda (,x) ,body)
               (C `(lambda (,x k) ,(cps1 body C~)))]
              [(,rator ,rand)
               (cps1 rator
                     (lambda (r)
                       (cps1 rand
                             (lambda (d)
                               (cond
                                [(memq r trivs)
                                 (C `(,r ,d))]
                                [(eq? C C~)         ; tail call
                                 `(,r ,d k)]
                                [else
                                 (let ([v* (fv)])
                                   `(,r ,d (lambda (,v*) ,(C v*))))])))))]))])
      (cps1 exp id))))
</code></pre>

<p>而这还不是 B621 的全部，每一个星期 Friedman 会在黑板上写下一道很难的题目。他不让你看书或者看论文。他有时甚至不告诉你题目里相关概念的名字，或者故意给它们起个新名字，让你想查都查不到。他要求你完全靠自己把这些难题解出来，下一个星期的时候在黑板上给其它同学讲解。他没有明确的评分标准，让你感觉完全没有成绩的压力。</p>

<p>这些题目包括一些很难的问题， 比如 church numeral 的前驱 (predecessor)。这个问题，当年是 Stephen Kleene （图灵的学长） 花了三个月冥思苦想才做出来的。不幸的是我在 Cornell 就学到了 Kleene 的做法，造成了思维的定势，所以这个训练当时对我来说失去了意义。而我们班上却有一个数学系的同学，出人意料的在一个星期之内做出了一个比 Kleene 还要简单的方法。他的完整的代码（用传统的 lambda calculus 语法表示）如下：</p>

<pre><code>λn w z. ((n λl h. h (l w)) (λd.z)) (λx.x)
</code></pre>

<p>其它的问题包括从 lambda calculus 到 SKI combinator 的编译器，逻辑式（可逆）CPS 变换，实现 Hindley-Milner 类型系统，等等。我发现，就算自认为明白了的东西，经过一番思索，认识居然还可以更进一步。</p>

<p>当然，重新发明东西并不会给我带来论文发表，但是它却给我带来了更重要的东西，这就是独立的思考能力。一旦一个东西被你“想”出来，而不是从别人那里 “学”过来，那么你就知道这个想法是如何产生的。这比起直接学会这个想法要有用很多，因为你知道这里面所有的细节和犯过的错误。而最重要的，其实是由此得到的直觉。如果直接去看别人的书或者论文，你就很难得到这种直觉，因为一般人写论文都会把直觉埋藏在一堆符号公式之下，让你看不到背后的真实想法。如果得到了直觉，下一次遇到类似的问题，你就有可能很快的利用已有的直觉来解决新的问题。</p>

<p>而这一切都已经发生在我身上。比如在听说 ANF 之后，我没有看 Amr Sabry 的论文，只把我原来的 CPSer 程序改了一点点，就得到了 ANF 变换，整个过程只花了十几分钟。而在 R. Kent Dybvig 的编译器课程上，我利用 CPS 变换里面的直觉，改造和合并了 Dybvig 提供的编译器框架的好几个 pass，使得它们变得比原来短小好几倍，却生成更好的代码。</p>

<p>现在我仍然是这样，喜欢故意重新发明一些东西，探索不止一个领域。这让我获得了直觉，不再受别人思想的限制，节省了看论文的时间，而且多了一些乐趣。一个问题，当我相信自己能想得出来，一般都能解决。虽然我经常不把我埋头做出来的东西放在心上，把它们叫做“重新发明”(reinvention)，但是出乎意料的是，最近我发现这里面其实隐藏了一些真正的发明。我准备慢慢把其中一些想法发掘整理出来，发表成论文或者做成产品。</p>

<p>俗话说“授人以鱼，不如授人以渔。”就是这个道理吧。Dan Friedman，谢谢你教会我钓鱼。</p>


  </body>
<h1>=======================================================<h1>
{ [Error: connect ETIMEDOUT] code: 'ETIMEDOUT', errno: 'ETIMEDOUT', syscall: 'connect' }
{ [Error: connect ETIMEDOUT] code: 'ETIMEDOUT', errno: 'ETIMEDOUT', syscall: 'connect' }
{ [Error: connect ETIMEDOUT] code: 'ETIMEDOUT', errno: 'ETIMEDOUT', syscall: 'connect' }
{ [Error: connect ETIMEDOUT] code: 'ETIMEDOUT', errno: 'ETIMEDOUT', syscall: 'connect' }
{ [Error: connect ETIMEDOUT] code: 'ETIMEDOUT', errno: 'ETIMEDOUT', syscall: 'connect' }
{ [Error: connect ETIMEDOUT] code: 'ETIMEDOUT', errno: 'ETIMEDOUT', syscall: 'connect' }
{ [Error: connect ETIMEDOUT] code: 'ETIMEDOUT', errno: 'ETIMEDOUT', syscall: 'connect' }
{ [Error: connect ETIMEDOUT] code: 'ETIMEDOUT', errno: 'ETIMEDOUT', syscall: 'connect' }
{ [Error: connect ETIMEDOUT] code: 'ETIMEDOUT', errno: 'ETIMEDOUT', syscall: 'connect' }
